<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wayne-98.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Keep Moving">
<meta property="og:type" content="website">
<meta property="og:title" content="Wayne">
<meta property="og:url" content="http://wayne-98.github.io/page/4/index.html">
<meta property="og:site_name" content="Wayne">
<meta property="og:description" content="Keep Moving">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wayne">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://wayne-98.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wayne</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wayne" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wayne</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Love Yourz</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Internet/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Internet/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">可靠传输原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 21:39:10" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 10:27:04" itemprop="dateModified" datetime="2020-05-21T10:27:04+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">计算机网络:自顶向下方法读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="可靠传输原理"><a href="#可靠传输原理" class="headerlink" title="可靠传输原理"></a>可靠传输原理</h2><h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><ul>
<li>增加序号范围</li>
<li>协议的发送方和接收方两端需要缓存分组。(发送方最低限度应当能缓冲那些已经发送但是没有被确认的分组，接收方需要缓存那些已正确接收的分组)</li>
</ul>
<h3 id="回退N步-GBN-滑动窗口协议"><a href="#回退N步-GBN-滑动窗口协议" class="headerlink" title="回退N步(GBN)滑动窗口协议"></a>回退N步(GBN)滑动窗口协议</h3><ul>
<li>GBN 发送方需要响应的三种类型的事件：<ol>
<li>上层的调用: 发送方需要检查发送窗口是否已满，既是否有 N 个已发送但未被确认的分组。</li>
<li>收到一个 ACK: GBN 协议中，对序号为N的分组的确认采取<strong>累积确认</strong>的方式，表明接收方已正确接收到序号为 N 的以前且包括 N 在内的所有的分组</li>
<li>超时事件: 如果出现超时，发送方重传所有已发送但还未被确认过的分组。(只采用了一个定时器，在 base 处)</li>
</ol>
</li>
<li>GBN 接收方：<br>如果一个序号为 N 的分组被正确接收，并且按序(既上一次交付给上层的数据是序号为 N - 1 的分组),则接收方为分组 N 发送一个 ACK ，并将该分组中的数据部分交付给上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送 ACK 。<br>(接收方不需要缓存任何失序分组。因为发送方会重传所有已发送但还未被确认过的分组)</li>
</ul>
<h3 id="选择重传-SR"><a href="#选择重传-SR" class="headerlink" title="选择重传(SR)"></a>选择重传(SR)</h3><p>当窗口长度和时延带宽积都很大的时候，在流水线中会有很多分组更是如此。单个分组的差错就能够引起 GBN 重传大量分组，很多分组根本没必要重传。<br>选择重传协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。</p>
<ul>
<li>SR 发送方的事件和动作：</li>
</ul>
<ol>
<li>从上层收到数据：发送方需要检查发送窗口是否已满，既是否有N个已发送但未被确认的分组。</li>
<li>收到 ACK : 如果收到 ACK ，倘若该分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接受。如果该分组的序号等于 send_base ，则窗口基序号向前移动到具有最小序号的未确认分组处。</li>
<li>超时事件：每个分组都必须拥有其自己的逻辑定时器。</li>
</ol>
<ul>
<li>SR接收方的事件和动作：</li>
</ul>
<ol>
<li>序号在 [ rcv_base, rcv_base + N - 1 ] 内的分组被正确接受。在此情况下，收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接受窗口的基序号，则该分组以及以前缓存的序号连续的分组交付给上层。然后接受窗口按向前移动分组的编号向上交付这些分组。</li>
<li>序号在 [ rcv_base - N, rcv_base - 1 ] 内的分组被正确接收到。在此情况下，必须产生一个 ACK ，即使该分组是接收方以前已确认过的分组。</li>
<li>其他情况，忽略该分组。</li>
</ol>
<ul>
<li>窗口长度必须小于等于序号空间大小的一半</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Internet/TCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Internet/TCP/" class="post-title-link" itemprop="url">TCP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 21:39:10" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 10:27:29" itemprop="dateModified" datetime="2020-05-21T10:27:29+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">计算机网络:自顶向下方法读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p><strong>TCP连接的组成</strong><br>    一台主机上的缓存、变量和与进程连接的套接字 ，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。</p>
<ul>
<li><strong>最大报文段长度</strong><br>TCP可以从缓存中取出并放入报文段中的数据数量受限于最大报文段长度(Maximum Segment Size)。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（Maximum Transmission Unit, MTU）来设置。</li>
</ul>
<hr>
<h2 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h2><ul>
<li>16比特的<strong>源端口号</strong>和<strong>目的端口号</strong></li>
<li>16比特的<strong>校验和</strong>字段</li>
<li>32比特的<strong>序号</strong>字段和<strong>确认号</strong>字段</li>
<li>16比特的<strong>接收窗口</strong>字段</li>
<li>4比特<strong>首部长度</strong>字段</li>
<li>可选与变长的<strong>选项</strong>字段</li>
<li>6比特的<strong>标志</strong>字段，ACK，RST，SYN，FIN</li>
</ul>
<ol>
<li><p><strong>序号和确认号</strong></p>
<p>TCP把数据看成一个无结构的、有序的字节流。序号是建立在传送的字节流上，而不是建立在传送的报文段的序列之上。<strong>一个报文段的序号</strong>因此是该报文段首字节的字节流编号。<br>确认号：A填充进报文段的确认号是主机A期望从主机B收到的下一个字节的序号。</p>
<p>TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供<strong>累计确认</strong>。</p>
<p>接收方保留失序的字节，并等待缺少的字节以填补该间隔。</p>
</li>
<li><p><strong>往返时间的估计与超时</strong></p>
</li>
</ol>
<p>EstimatedRTT = (1-a)EstimatedRTT + a * SampleRTT<br>            （a一般取0.125）SampleRTT的均值</p>
<p>DevRTT = (1-b) * DevRTT + b * | SampleRTT - EstimatedRTT|<br>            （b一般取0.25）</p>
<p>TimeoutInterval = EstimatedRTT +　４ * DevRTT<br>    （要求将超时间隔设为EstimatedRTT加上一定余量，当波动较大的时候，这个余量应该大一点）</p>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p><strong>TCP发送方有3个与发送和重传有关的主要事件：</strong><br>       1. 从上层应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP<br>       2. 当报文段被传给IP时，TCP就启动该定时器。（将定时器想象为与最早的未被确认的报文段相关联的）<br>       3. 来自接收方的确认报文段(ACK)。TCP将ACK的值y与它的变量SendBase进行比较(SendBase是最早未被确认的字节的序号，因此SendBase-1是指接收方已正确按序接收到的数据的最后一个字节的序号)。<br>           TCP采用累计确认，所以y确认了编号在y之前的所有字节都已经收到。</p>
<p><strong>TCP接收方产生ACK：</strong></p>
<ol>
<li>具有所期望序号的按序报文段到达。所有在期望序号以及以前的数据都已经被确认。<ul>
<li>延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下一个按序报文段在这个时间间隔内没有到达，则发送一个ACK</li>
</ul>
</li>
<li>具有所期望序号的按序报文段到达。另一个按序报文段等待ACK传输。<ul>
<li>立即发送单个累积ACK，以确认两个按序报文段</li>
</ul>
</li>
<li>比期望序号大的失序报文段到达。检测出间隔 <ul>
<li>立即发送冗余ACK，指示下一个期待字节的序号</li>
</ul>
</li>
<li>能部分或者完全填充接收数据间隔的报文段到达<ul>
<li>倘若该报文段起始于间隔的低端，则立即发送ACK</li>
</ul>
</li>
</ol>
<ul>
<li><strong>超时间隔加倍</strong><br>TCP重传时都会将下一次的时间间隔设为先前值的两倍，而不是用从EstimateRTT和DevRTT推算出的值。提供了一个形式受限的拥塞控制</li>
<li><strong>快速重传</strong></li>
</ul>
<p>超时触发重传存在的问题之一是超时周期可能相对较长，增加了端到端时延。幸运的是，发送方通常可在超时事件发生之前通过注意所谓冗余 ACK 来较好的检测到丢包情况。</p>
<p>一旦收到3个冗余ACK，TCP 就执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。</p>
<ul>
<li><strong>是回退N步还是选择重传</strong></li>
</ul>
<p>TCP确认是累积的，正确接收但失序的报文段是不会被接收方逐个确认的。</p>
<p>TCP发送方仅需维持已发送过但未被确认的字节的最小序号(SendBase)和下一个要发送的字节的序号(NextSeqNum)</p>
<p>选择确认允许TCP接收方有选择的确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。</p>
<p>TCP的差错恢复机制也是最好被分类为GBN协议与SR协议的混合体。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p><strong>流量控制</strong>用以消除发送方使接收方缓存溢出的可能性。TCP通过让发送方维护一个称为<strong>接受窗口</strong>的变量来提供流量控制。</p>
<p>TCP发送方也可能因为IP网络的拥塞而被遏制，这种形式的发送方的控制被称为<strong>拥塞控制</strong>。</p>
<p>LastByteSent - LastByteAcked &lt;= rwnd<br>rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]</p>
<p>LastByteSent - LastByteAcked &lt;= rwnd<br>主机A发送到连接中但未被确认的数据量小于等于主机B的缓存允许接收的数据量。</p>
<h2 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h2><ul>
<li><strong>三次握手</strong> <ol>
<li>发送SYN(Synchronize Sequence Numbers)报文段(报文段的首部中的SYN标志位被置为1，此外客户会随机选择一个初始序号，放在序号字段中)。</li>
<li>服务器提取出TCP SYN报文段，向该客户发送允许连接报文段。SYNACK报文段：这个报文段首部包含3个重要信息：SYN置为1，确认号字段被置为client_isn +１，服务器自己的初始序号。</li>
<li>收到SYNACK报文段后，客户也要给该连接分配缓存和变量。 发送报文段，此TCP报文段的首部的确认字段的序号为server_isn + 1，SYN被置为0，可以携带客户到服务器的数据。服务器收到客户端的确认后，连接建立。</li>
</ol>
</li>
<li><strong>三次握手的原因</strong> </li>
</ul>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<ul>
<li><strong>四次挥手</strong><ol>
<li>客户应用进程发送一个特殊的报文段，其首部的FIN(finish)标志位被置为1</li>
<li>服务器收到后回送一个ACK报文段，此时 TCP 属于半关闭状态，服务器能向客户端发送数据但是客户端不能向服务器发送数据。</li>
<li>当服务器不再需要连接时，服务器发送它自己的终止报文段，其首部的FIN标志位也被置为1</li>
<li>该客户对这个服务器的终止报文段进行确认。此时两台主机上用于该连接的所有资源都被释放了。</li>
</ol>
</li>
<li><strong>四次挥手的原因</strong></li>
</ul>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<ul>
<li><strong>TIME_WAIT</strong></li>
</ul>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器<br>设置的时间 2MSL。这么做有两个理由：<br>       1. 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。<br>       2. 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
<ul>
<li><strong>客户TCP经历的典型的TCP状态序列</strong></li>
</ul>
<p>建立：</p>
<ol>
<li>客户 TCP 开始时处于 CLOSE 状态</li>
<li>发送 SYN 报文段后，进入 SYN_SENT 状态。然后等待服务器 TCP 的对客户所发报文段进行确认且 SYN 比特置为 1 的一个报文段</li>
<li>收到来自服务器的确认后，客户 TCP 进入 ESTABLISHED 状态。TCP 客户就能发送和接收包含有效荷载数据的TCP报文段了</li>
</ol>
<p>拆除：</p>
<ol>
<li>客户 TCP 发送一个带有FIN比特被置为 1 的 TCP 报文段，并进入 FIN_WAIT_1 状态。客户 TCP 等待一个来自服务器的带有确认的 TCP 报文段。</li>
<li>收到来自服务器的确认后，客户 TCP 进入 FIN_WAIT_2 状态。客户等待来自服务器的 FIN 比特被置为1的另一个报文段</li>
<li>收到服务器的 FIN 比特被置为 1 的报文段后，客户 TCP 对服务器的报文段进行确认，然后进去 TIME_WAIT 状态。(假定 ACK 丢失，TIME_WAIT 状态使 TCP 客户重传最后的确认报文)</li>
</ol>
<ul>
<li><strong>SYN洪泛攻击</strong></li>
</ul>
<p>SYN cookie</p>
<ul>
<li>服务器收到一个 SYN 报文段时，并不会立即生成一个半开连接，而是生成一个初始 TCP 序列号，该序列号是 SYN 报文段的源和目的 IP 地址与端口号以及仅有该服务器知道的秘密数的一个复杂函数。这种精心制作的初试序列号被称为 cookie。服务器并不记忆该 cookie 或任何对应于 SYN 的其他状态信息。</li>
<li>如果客户合法，返回一个 ACK 报文段，这个合法的 ACK ，在确认字段中的值等于在 SYNACK 字段(此时为 cookie 的值)中的值 + 1 .</li>
</ul>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><ul>
<li><strong>拥塞网络的代价：</strong></li>
</ul>
<ol>
<li>分组的到达速率接近链路容量时，分组经历巨大的排队时延。</li>
<li>发送方必须执行重传以补偿因为缓存溢出而丢弃(丢失)的分组。</li>
<li>发送方在遇到大时延时所进行的不必要的重传会引起路由器利用其链路带宽来转发不必要的副本。</li>
<li>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了。</li>
</ol>
<ul>
<li><strong>拥塞控制方法</strong>：</li>
</ul>
<ol>
<li>端到端拥塞控制：网络层没有为运输层拥塞控制提供显示支持，端系统通过对网络行为的观察(如分组丢失与时延)来推断之</li>
<li>网络辅助的拥塞控制：路由器向发送方提供关于网络中拥塞状态的显示反馈信息。ATM可用比特率拥塞控制中，路由器显示的通知发送方它能在输出链路上支持的最大主机发送速率。<ul>
<li>网络辅助的拥塞控制有两种方式：<ul>
<li>直接网络反馈：由网络路由器发给发送方。（通常采用一种阻塞分组的形式）</li>
<li>路由器标记或更新从发送方流向接受方的分组中的某个字段来指示拥塞的产生。（更为通用，但是要经过一个RTT）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><ul>
<li><strong>TCP发送方如何限制它向其连接发送流量的速率呢？</strong></li>
</ul>
<p>TCP拥塞控制机制跟踪一个额外的变量，<strong>拥塞窗口cwnd</strong></p>
<p>LastByteSent - LastByteAcked &lt;=min｛cwnd,rwnd｝</p>
<p>通过限制了发送方中未被确认的数据量，间接的限制了发送方的发送速率。</p>
<ul>
<li><strong>TCP发送方如何感知它到目的地之间的路径上存在拥塞的呢？</strong></li>
</ul>
<p>“丢包事件”：超时事件和收到三个冗余的ACK。</p>
<p>因为TCP使用确认来触发增大它的拥塞窗口长度，TCP被称做自计时的。</p>
<ul>
<li><strong>TCP发送方怎样确定它应当发送的速率呢？</strong></li>
</ul>
<ol>
<li>一个丢失的报文段意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率。</li>
<li>一个确认的报文段指示该网络正在向接受方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率。</li>
<li>带宽探测，除非出现丢包才减慢速率，不然会一直加快。</li>
</ol>
<ul>
<li><p><strong>TCP拥塞控制算法</strong></p>
</li>
<li><p><strong>慢启动</strong></p>
</li>
</ul>
<ol>
<li>初始cwnd设置为一个MSS，当该确认到达时，TCP将以指数形式增大拥塞窗口。</li>
<li>何时结束指数增长：        <ul>
<li>当出现由超时指示的丢包事件 TCP发送方将cwnd设置为1，并重新开始慢启动，并且将ssthresh(<strong>慢启动阈值</strong>)设置为cwnd/2。</li>
<li>当cwnd到达或者超过ssthresh的值时，结束慢启动并且TCP转移到拥塞避免模式。</li>
<li>当检测到3个冗余ACK，这时TCP将执行一种快速重传并进入快速恢复状态。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>拥塞避免</strong></li>
</ul>
<ol>
<li>每个RTT只将cwnd的值增加一个MSS，发送方无论何时到达一个新的确认，就将cwnd增加一个MSS字节。</li>
</ol>
<ul>
<li><strong>快速重传</strong></li>
</ul>
<ol>
<li>把ssthresh设置为cwnd的一半 </li>
<li>把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3) </li>
<li>重新进入拥塞避免阶段。</li>
</ol>
<ul>
<li><strong>快速恢复</strong></li>
</ul>
<ol>
<li>收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。</li>
<li>再收到重复的ACK时，拥塞窗口增加1。</li>
<li>当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Internet/HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Internet/HTTP/" class="post-title-link" itemprop="url">HTTP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 21:39:10" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 10:27:26" itemprop="dateModified" datetime="2020-05-21T10:27:26+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">计算机网络:自顶向下方法读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><p><strong>无状态协议</strong><br>HTTP服务器并不保存关于客户的任何信息，所以我们说 HTTP 是一个无状态协议（stateless protocol）</p>
</li>
<li><p><strong>怎么实现有状态呢？</strong><br>Cookie 和 Session 保存会话状态，用 Session 来唯一标识用户，用 Cookie 当作用户通行证。</p>
<p>session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行证。</p>
</li>
</ul>
<ol>
<li><p><strong>cookie</strong>(客户端)</p>
<ul>
<li>cookie 的4个技术组件：</li>
</ul>
<ol>
<li>在 HTTP 响应报文中的一个 cookie 首部行</li>
<li>在 HTTP 请求报文中的一个 cookie 首部行</li>
<li>在用户端系统中保留有一个 cookie 文件，并由用户的浏览器进行管理</li>
<li>位于 Web 站点的一个后端数据库<br><img src="https://github.com/Wayne-98/image/blob/master/Internet/Cookie.png?raw=true" alt=""></li>
</ol>
</li>
</ol>
<ol start="2">
<li><strong>session</strong>(服务端)</li>
</ol>
<p>Session 是服务器在和客户端建立连接时添加客户端连接标志，最终会在服务器软件（Apache、Tomcat、JBoss）转化为一个临时 Cookie 发送给给客户端，当客户端第一请求时服务器会检查是否携带了这个Session（临时 Cookie ），如果没有则会添加 Session，如果有就拿出这个 Session 来做相关操作</p>
<ul>
<li>session 安全性的保证<ul>
<li>HttpOnly 属性<br>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。</li>
<li>HTTPS传输</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>token</strong></li>
</ol>
<p>token 也称作令牌，由 uid + time + sign[+固定参数]</p>
<p><strong>token认证流程</strong></p>
<ul>
<li>token 的认证流程与 cookie 很相似，用户登录成功后服务器返回 Token 给客户端。</li>
<li>客户端收到数据后保存在客户端</li>
<li>再次访问服务器，将 token 放入 headers 中</li>
<li>服务器端采用 filter 过滤器校验。校验成功则返回请求数据，校验失败则返回错误码。</li>
</ul>
<p><strong>区别和联系</strong><br>session 存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号 sessionId，通常存放于 cookie 中。服务器收到 cookie 后解析出 sessionId ，再去 session 列表中查找，才能找到相应 session ，依赖cookie。cookie 类似一个令牌，装有 sessionId ，存储在客户端，浏览器通常会自动添加。token 也类似一个令牌，无状态，用户信息都被加密到 token 中，服务器收到 token 后解密就可知道是哪个用户。需要开发者手动添加。</p>
<hr>
<ul>
<li><strong>非持续性</strong>连接和<strong>持续性</strong>连接<br>每个请求/响应对是经一个单独的TCP连接发送，还是所有的请求及响应经相同的TCP连接发送呢？<br>前者是非持续性连接，后者是持续性连接。（HTTP在其默认方式下使用持续性连接）<ul>
<li>非持续连接的缺点<ol>
<li>每个连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量，浪费资源</li>
<li>每个对象经受2倍的RTT(Round-Trip Time，往返时间),一个RTT用于创建TCP,一个RTT用于请求和接收一个对象。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>HTTP报文格式</strong></li>
<li>HTTP请求报文<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;somedir&#x2F;page.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.someschool.edu</span><br><span class="line">Connection: close</span><br><span class="line">User-agent: Mozilla&#x2F;5.0     &#x2F;&#x2F;浏览器类型</span><br><span class="line">Accept-language: fr</span><br></pre></td></tr></table></figure>
HTTP请求报文的第一行叫做请求行（request line），其后继的行叫做首部行（header line）</li>
</ul>
<ol>
<li><strong>请求行</strong></li>
</ol>
<ul>
<li>方法字段：方法字段可以取不同的值：<ol>
<li>GET：实体体为空</li>
<li>POST：实体体中包含的就是用户在表单字段中的输入值。</li>
</ol>
<ul>
<li>当用户向搜索引擎提供搜索关键词时，使用post报文时，用户仍可以向服务器请求一个Web界面，但Web界面的特定内容依赖于用户在表单字段中输入的内容。  </li>
<li>GET方法也可以提交表单，在所请求的URL中包括输入的数据。<br><code>www.somesite.com/animalsearch?monkey&amp;bananas</code></li>
</ul>
<ol start="3">
<li>HEAD：HEAD方法类似与GET方法。当服务器收到一个使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回对象。应用程序开发者常用HEAD方法进行调试跟踪，用于确认 URL 的有效性以及资源更新的日期时间等。</li>
<li>PUT：它允许用户上传对象到指定的Web服务器上指定的路径。由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</li>
<li>PATCH：修改资源，PATCH 允许部分修改。</li>
<li>DELETE：允许用户或者应用程序删除Web服务器上的对象。并且同样不带验证机制。</li>
<li>OPTIONS：查询指定的 URL 能够支持的方法。</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道</li>
</ol>
</li>
<li>URL字段：URL字段带有请求对象的标识</li>
<li>HTTP版本字段</li>
</ul>
<ol start="2">
<li><strong>首部行</strong><br> Host：指明了对象所在的主机。（为什么已经有一条TCP连接存在了，还需要这个字段呢，因为Web代理高速缓存需要该首部行提供的信息）<br> Connection：close首部行，该浏览器告诉服务器不要麻烦地使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条连接。</li>
</ol>
<ul>
<li>HTTP响应报文<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line">Date: Tue, 18 Aug 2015 15:44:04 GMT</span><br><span class="line">Server: Apache&#x2F;2.2.3 (CentOS)</span><br><span class="line">Last-Modified: Tue, 18 Aug 2015 15:11:04 GMT</span><br><span class="line">Content-Length: 6821</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line"></span><br><span class="line">(data data data data ....)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>初始状态行(status line)<br> 协议版本字段，状态码和相应状态信息<ul>
<li>200 OK ：请求成功，信息在返回的响应报文中</li>
<li>301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL</li>
<li>400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解</li>
<li>404 Not Found：被请求的文档不在服务器上</li>
<li>505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。</li>
</ul>
</li>
<li>6个首部行(header line)<ul>
<li>Connection: close：首部行告诉客户，发送完报文后关闭该TCP连接</li>
<li>Date：首部行指示服务器产生并发送该响应报文的日期和时间。（不是指这个对象创建或者最后修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间）</li>
<li>Server</li>
<li>Last-Modified：指示了这个对象创建或者最后修改的时间。(对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要)</li>
<li>Length：指示了被发送对象中的字节数</li>
<li>Content-Type：</li>
</ul>
</li>
<li>实体体(entity body)</li>
</ol>
<hr>
<ul>
<li>Web缓存<br>Web缓存器(Web cache)也叫代理服务器(proxy server)，它是能够代表初始Web服务器来满足HTTP请求的网络实体。<ul>
<li>可以配置用户的浏览器，使得用户所有的HTTP请求首先指向Web缓存器。</li>
</ul>
</li>
</ul>
<ol>
<li>浏览器建立一个到web缓存器的TCP连接，并向web缓存器发送一个请求报文；</li>
<li>web缓存器检查本地是否存储了该对象的拷贝：如果有，向初始服务器发送一个条件GET请求报文（if-modified-since标记），检查本地拷贝是否是最新的：服务器会返回一个响应报文，如果是最新的，响应报文中不会包含请求对象(304 Not Modified)；如果不是最新的，响应报文中会包含请求对象，web缓存器更新其本地存储及相应的if-modified-since标记。如果没有，向初始服务器发送一个请求报文，收到请求后，更新本地存储。发送响应报文给客户端浏览器。</li>
</ol>
<p>GET /fruit/kiwi.gif HTTP/1.1<br>Host: <a href="http://www.exotiquecuisine.com" target="_blank" rel="noopener">www.exotiquecuisine.com</a></p>
<p>HTTP/1.1 200 Ok<br>Date: Sat, 3 Oct 2015 15:39:29<br>Server: Apache/1.3.0 (Unix)<br>Last-Modified: Wed, 9 Sep 2015 09:23:24<br>Content-Type: image/gif<br>(data data data data … ) </p>
<p>GET /fruit/kiwi.gif HTTP/1.1<br>Host: <a href="http://www.exotiquecuisine.com" target="_blank" rel="noopener">www.exotiquecuisine.com</a><br>If-modified-since：Wed, 9 Sep 2015 09:23:24</p>
<p>HTTP/1.1 304 Not Modified<br>Date: Sat, 10 Oct 2015 15:39:29<br>Server: Apache/1.3.0 (Unix)<br>(empty entity body)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Internet/DNS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Internet/DNS/" class="post-title-link" itemprop="url">DNS</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 21:39:10" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 10:27:23" itemprop="dateModified" datetime="2020-05-21T10:27:23+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">计算机网络:自顶向下方法读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名系统(Domain Name System)能进行<strong>主机名到IP地址转换</strong>的目录服务。</p>
<ul>
<li>DNS：</li>
</ul>
<ol>
<li><strong>一个由分层的 DNS 服务器实现的分布式数据库</strong></li>
<li><strong>一个使得主机能够查询分布式数据的应用层协议</strong></li>
</ol>
<p>DNS 协议运行在 UDP 之上，使用53端口号。</p>
<blockquote>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<p>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。<br>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</p>
</blockquote>
<ol>
<li>主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>。        </li>
</ol>
<p>所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p>
<ol start="2">
<li><p>本地域名服务器向根域名服务器的查询的<strong>迭代查询</strong><br> 迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。</p>
<p> 搜索浏览器DNS缓存 –&gt; 操作系统DNS缓存 –&gt; 向本地DNS服务器发起DNS请求</p>
</li>
</ol>
<p>本地DNS服务器 –&gt; 根DNS服务器 –&gt; 根DNS服务器向本地DNS服务器响应：你去找哪个哪个顶级域DNS服务器 –&gt; 顶级域DNS服务器：你去找哪个哪个权威DNS服务器</p>
<ul>
<li>除了进行主机名到IP地址的转换之外，DNS还提供了一些重要的服务：</li>
</ul>
<ol>
<li>主机别名 2. 邮件服务器别名 3. 负载分配</li>
</ol>
<h1 id="DNS工作机理"><a href="#DNS工作机理" class="headerlink" title="DNS工作机理"></a>DNS工作机理</h1><ul>
<li>分布式、层次数据库<br>大致来说，有三种类型的 DNS 服务器：<ol>
<li>根 DNS 服务器</li>
<li>顶级域(Top-Level Domain, TLD)DNS服务器(com. org. net. edu. fr. ca. jp)</li>
<li>权威 DNS 服务器。</li>
</ol>
</li>
</ul>
<p><strong>本地DNS服务器</strong>并不属于该服务器的层级结构，但它对DNS层次结构是至关重要的。每个ISP都有一台本地DNS服务器。</p>
<ul>
<li>DNS 缓存<br>在一个请求链中，当某 DNS 服务器接受一个 DNS 回答时，它能将映射换存在本地存储器中。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Git/Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Git/Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Git 学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:08:50" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index"><span itemprop="name">开发工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Git是目前世界上最先进的分布式版本控制系统</p>
<h1 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h1><p><strong>$ git config –global user.name “Your Name”<br>$ git config –global user.email “<a href="mailto:email@example.com">email@example.com</a>“</strong></p>
<hr>
<ul>
<li>初始化一个Git仓库，使用<strong>git init</strong>命令。</li>
<li>添加文件到Git仓库，分两步：<ol>
<li>使用命令<strong>git add <file></strong>，注意，可反复多次使用，添加多个文件；</li>
<li>使用命令<strong>git commit -m <message></strong>，完成。</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li>要随时掌握工作区的状态，使用<strong>git status</strong>命令。</li>
<li>如果git status告诉你有文件被修改过，用<strong>git diff</strong>可以查看修改内容。</li>
</ul>
<hr>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，<br>使用命令<strong>git reset –hard commit_id</strong>。</li>
<li>穿梭前，用<strong>git log</strong>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<strong>git reflog</strong>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<hr>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p><strong>暂存区</strong>是Git非常重要的概念<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hcAUgRih-1587607662307)(en-resource://database/1321:1)]</p>
<hr>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><ol>
<li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<strong>git checkout – file</strong>。</li>
<li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，<br>分两步，第一步用命令<strong>git reset HEAD <file></strong>，就回到了场景1，第二步按场景1操作。</li>
<li>已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</li>
</ol>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><ul>
<li><p>要关联一个远程库，使用命令</p>
</li>
<li><p><em>git remote add origin git@server-name:path/repo-name.git；*</em></p>
</li>
<li><p>关联后，使用命令<strong>git push -u origin master</strong>第一次推送master分支的所有内容；</p>
</li>
<li><p>此后，每次本地提交后，只要有必要，就可以使用命令<strong>git push origin master</strong>推送最新修改；</p>
</li>
</ul>
<hr>
<h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><ul>
<li>git clone <a href="mailto:git@github.com">git@github.com</a>:Winter-XJTU/gitskills.git</li>
</ul>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p>Git鼓励大量使用分支：</p>
<ul>
<li>查看分支：git branch</li>
<li>创建分支：git branch <name></li>
<li>切换分支：git checkout <name></li>
<li>创建+切换分支：git checkout -b <name></li>
<li>合并某分支到当前分支：git merge <name></li>
<li>删除分支：git branch -d <name></li>
</ul>
<hr>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。<br>解决冲突后，再提交，合并完成。<br>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。<br>用<strong>git log –graph</strong>命令可以看到分支合并图。</p>
<ul>
<li>分支策略<br>分支策略在实际开发中，我们应该按照几个基本原则进行分支管理：<br>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</li>
</ul>
<p><strong>git merge –no-ff -m “merge with no ff” dev</strong><br>Git分支十分强大，在团队开发中应该充分应用。合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<ul>
<li>bug分支</li>
</ul>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">168  vim hello.py</span><br><span class="line">170  git add hello.py</span><br><span class="line">171  git commit -m <span class="string">"hello.py"</span></span><br><span class="line">172  git stash</span><br><span class="line">//保留工作现场</span><br><span class="line"></span><br><span class="line">176  git checkout master</span><br><span class="line">177  git checkout -b issue</span><br><span class="line">179  vim readme.txt</span><br><span class="line">180  git add readme.txt</span><br><span class="line">181  git commit -m <span class="string">"fix bug"</span></span><br><span class="line">182  git checkout master</span><br><span class="line">183  git merge --no-ff -m <span class="string">"merge bug fix issue with no ff"</span> issue</span><br><span class="line">//修复bug并且合并到master</span><br><span class="line"></span><br><span class="line">186  git checkout dev</span><br><span class="line">190  git stash list</span><br><span class="line">191  git stash pop</span><br><span class="line">//恢复工作现场</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">201  git cherry-pick 891c0cf</span><br><span class="line">//在master分支上修复的bug，想要合并到当前dev分支</span><br></pre></td></tr></table></figure>





<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>因此，多人协作的工作模式通常是这样：<br>首先，可以试图用git push origin <branch-name>推送自己的修改；<br>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；<br>如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p>小结</p>
<p>查看远程库信息，使用git remote -v；<br>本地新建的分支如果不推送到远程，对其他人就是不可见的；<br>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；<br>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；<br>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；<br>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Distributed%20System/%E4%BB%8EPaxos%E5%88%B0Zookeeper%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9AZookeeper%20%E4%B8%8E%20Paxos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Distributed%20System/%E4%BB%8EPaxos%E5%88%B0Zookeeper%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9AZookeeper%20%E4%B8%8E%20Paxos/" class="post-title-link" itemprop="url">从Paxos到Zookeeper 第四章：Zookeeper 与 Paxos</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 21:39:10" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 10:28:31" itemprop="dateModified" datetime="2020-05-21T10:28:31+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8EPaxos%E5%88%B0Zookeeper%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">从Paxos到Zookeeper读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Zookeeper基本概念"><a href="#Zookeeper基本概念" class="headerlink" title="Zookeeper基本概念"></a>Zookeeper基本概念</h2><p>Zookeeper 是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅，负载均衡，命名服务，分布式协调/通知，集群管理，Master 选举，分布式锁和分布式队列等功能。</p>
<ul>
<li>集群角色<ul>
<li>Leader：为客户端提供读和写服务。</li>
<li>Follower：提供读服务</li>
<li>Observer：提供读服务，但是不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，可以在不影响写性能的情况下提升集群的读性能。</li>
</ul>
</li>
<li>会话<ul>
<li>客户端与 Zookeeper 的连接是一个 TCP 的长连接。ZK 对外提供服务的端口号为 2181。</li>
</ul>
</li>
<li>ZNode<ul>
<li>ZNode 指的是数据模型中的数据单元，称之为数据节点。ZK 的所有数据存储在内存当中，数据模型是一棵树。</li>
<li>ZNode 可以分为持久性或临时性节点</li>
</ul>
</li>
<li>版本<ul>
<li>每个ZNode，Zookeeper都会维护一个 Stat 的数据结构，Stat 记录了该 ZNode 的三个数据版本。version(当前ZNode 的版本)，cversion(当前ZNode子节点的版本)和aversion(当前ZNode的ACL版本)。</li>
</ul>
</li>
<li>Watcher<ul>
<li>ZK 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZK 服务端会将事件通知到感兴趣的客户端上去</li>
</ul>
</li>
<li>ACL<ul>
<li>Access Control List 来进行权限控制<ol>
<li>CREATE：创建子节点的权限</li>
<li>READ：获取节点数据和子节点列表的权限</li>
<li>WRITE：更新节点数据的权限</li>
<li>DELETE：删除子节点的权限</li>
<li>ADMIN：设置节点 ACL 的权限</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="ZAB-协议"><a href="#ZAB-协议" class="headerlink" title="ZAB 协议"></a>ZAB 协议</h1><p>Zookeeper Atomic  Broadcast（ZK原子消息广播协议）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Distributed%20System/%E4%BB%8EPaxos%E5%88%B0Zookeeper%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Distributed%20System/%E4%BB%8EPaxos%E5%88%B0Zookeeper%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">从Paxos到Zookeeper 第二章：一致性协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 21:39:10" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 10:28:29" itemprop="dateModified" datetime="2020-05-21T10:28:29+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8EPaxos%E5%88%B0Zookeeper%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">从Paxos到Zookeeper读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在分布式系统中，每一个机器节点能够明确知道自己在进行事务操作中的结果的成败，但是无法直接获取到其他分布式节点的操作结果。因此，但一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的 ACID 的特性，就需要引入一个称为“协调者”（Coordinator）的组件来统一调度所有分布式节点的执行逻辑，这些被调度的节点被称为“参与者”（Participant）。协调者负责调度参与者的行为，并最终决定参与者是否要把事务真正进行提交。基于这个思想，衍生了二阶段提交和三阶段提交两种协议。</p>
<h2 id="2PC-Two-Phase-Commit"><a href="#2PC-Two-Phase-Commit" class="headerlink" title="2PC(Two-Phase Commit)"></a>2PC(Two-Phase Commit)</h2><p><strong>阶段一：提交事务请求</strong> （投票阶段：即各参与者投票表明是否要继续执行接下来的事务提交操作）</p>
<ol>
<li><p>事务询问</p>
<p>协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p>
</li>
<li><p>执行事务</p>
<p>各参与者节点执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。</p>
</li>
<li><p>各参与者向协调者反馈事务询问的响应</p>
<p>如果参与者成功执行了事务操作，那么就反馈给协调者 Yes 响应，表示事务可以执行</p>
</li>
</ol>
<p><strong>阶段二：执行事务提交</strong></p>
<ol>
<li><p>执行事务提交：所有的参与者反馈的都是 Yes 响应</p>
<ul>
<li>发送提交请求： 协调者向所有参与者发送 Commit 请求。</li>
<li>事务提交：参与者收到 Commit 请求后，会正式的执行事务提交操作，并在完成提交之后释放在整个事务期间占用的事务资源。</li>
<li>反馈事务提交结果：参与者在事务提交之后，向协调者发送 ACK 消息。</li>
<li>完成事务：协调者收到所有参与者反馈的 ACK 消息后，完成事务。</li>
</ul>
</li>
<li><p>中断事务：如果任何一个参与者向协调者发送了 No 响应，或者在等待超时之后，协调者尚无法收到所有参与者的反馈响应，那么就会中断事务。</p>
<ul>
<li>发送回滚请求：协调者向所有参与者发送 Rollback 请求。</li>
<li>事务回滚：参与者在收到 Rollback 请求后，会利用其在阶段一中记录的 Undo 信息来执行事务回滚操作，并在完成回滚后释放在整个事务期间占用的事务资源。</li>
<li>反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送 ACK 消息。</li>
<li>中断事务：协调者收到所有参与者反馈的 ACK 消息后，完成事务中断</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><strong>优点</strong>：原理简单，实现方便</li>
<li><strong>缺点</strong>：同步阻塞，单点问题，脑裂，太过保守<ul>
<li>同步阻塞：2PC 的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态。也就是说，各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作。</li>
<li>单点问题：如果协调者崩了，那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。</li>
<li>数据不一致：2PC 的阶段二，即执行事务提交的时候，当协调者向所有的参与者发送 Commit 请求后，由于种种原因（局部网络异常，协调者尚未发送完所有 Commit 自身发生崩溃）导致最终只有部分参与者收到了 Commit 请求。那么收到 Commit 请求的参与者就会进行事务的提交，而其他没有收到 Commit 的参与者则无法进行事务提交。于是整个分布式系统出现了数据不一致的现象。</li>
<li>太过保守：如果在协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的相应信息的话，这时协调者只能依靠自身的超时机制来判断是否需要中断事务，这样的策略太过保守。 也就是 2PC 协议没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3PC-Three-Phase-Commit"><a href="#3PC-Three-Phase-Commit" class="headerlink" title="3PC(Three-Phase Commit)"></a>3PC(Three-Phase Commit)</h2><p>是 2PC 的改进版，将二阶段提交协议的“提交事务请求”过程一分为二，形成了由 CanCommit、PreCommit 和 do Commit 三个阶段组成的事务处理协议。</p>
<p><strong>阶段一：CanCommit</strong></p>
<ol>
<li><p>事务询问：协调者向所有参与者发送一个包含事务内容的 CanCommit 请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p>
</li>
<li><p>各参与者向协调者反馈事务询问的响应：参与者在接收到来自协调者的 CanCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么就会反馈 Yes 响应，并进入预备状态，否则反馈 No 响应。</p>
</li>
</ol>
<p><strong>阶段二：PreCommit</strong></p>
<p>在阶段二中，协调者会根据参与者的反馈情况来决定是否可以进行事务的 PreCommit 操作，正常情况下，包含两种情况</p>
<ul>
<li><p>执行事务预提交</p>
<p>假如协调者从所有的参与者获得的反馈都是 Yes ，那么就会执行事务的预提交</p>
<ol>
<li>发送预提交请求：协调者向所有参与者节点发出 PreCommit 的请求，并进入 Prepared 阶段。</li>
<li>事务预提交：参与者收到  PreCommit 请求后，会执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。</li>
<li>各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，那么就反馈给协调者 Ack 响应，同时等待最终的指令：提交(commit) 或者 终止(abort).</li>
</ol>
</li>
<li><p>中断事务</p>
<p>假如任意一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p>
<ol>
<li>发送中断请求：协调者向所有参与者节点发送 abort 请求。</li>
<li>中断事务：无论是收到来自协调者的 abort 请求，或者是在等待协调者请求的过程中出现超时，参与者都会中断事务。</li>
</ol>
</li>
</ul>
<p><strong>阶段三： doCommit</strong></p>
<p>该阶段会执行真正的事务提交，会存在以下两种情况</p>
<ul>
<li><p>执行提交</p>
<ol>
<li>发送提交请求：假设协调者处于正常工作状态，并且收到了来自所有参与者的 Ack 响应，那么它将从“预提交”状态转换到“提交”状态，并向所有的参与者发出 doCommit 请求。</li>
<li>事务提交：参与者收到 doCommit 请求后，会正式的执行事务提交操作，并在完成提交之后释放在整个事务期间占用的事务资源。</li>
<li>反馈事务提交结果：参与者在事务提交之后，向协调者发送 ACK 消息。</li>
<li>完成事务：协调者收到所有参与者反馈的 ACK 消息后，完成事务。</li>
</ol>
</li>
<li><p>中断事务</p>
<p>进入这一阶段，假设协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者尚无法收到所有参与者的反馈响应，那么就会中断事务。</p>
<ol>
<li>发送中断请求：协调者向所有参与者节点发送 abort 请求。</li>
<li>事务回滚：参与者在收到 abort 请求后，会利用其在阶段二中记录的 Undo 信息来执行事务回滚操作，并在完成回滚后释放在整个事务期间占用的事务资源。</li>
<li>反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送 ACK 消息。</li>
<li>中断事务：协调者收到所有参与者反馈的 ACK 消息后，完成事务中断。</li>
</ol>
</li>
</ul>
<hr>
<p>一旦进入阶段三，可能会出现以下两种故障：</p>
<ul>
<li>协调者出现问题</li>
<li>协调者和参与者之间的网络出现故障</li>
</ul>
<p>无论出现哪种情况，最终都会导致参与者无法收到来自协调者的 doCommit 或是 abort 请求，针对这样的异常情况，参与者都会在等待超时之后，继续进行事务提交。</p>
<hr>
<ul>
<li><strong>优点：</strong>相对于 2PC ，3PC 最大的优点是减低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。</li>
<li><strong>缺点：</strong>参与者在收到 PreCommit 消息后，如果出现了网络分区，此时协调者所在的节点无法与参与者进行网络通信，这种情况下，参与者依然会进行事务的提交，这样会出现数据的不一致。</li>
</ul>
<hr>
<h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><p><a href="https://mp.weixin.qq.com/s/aJoXSQo9-zmukN2RsiZ3_g" target="_blank" rel="noopener">微信PaxosStore：深入浅出Paxos算法协议</a></p>
<p><a href="https://mp.weixin.qq.com/s/6VWUA5EDV2UIq4NqmQYWUA" target="_blank" rel="noopener">微信自研生产级paxos类库PhxPaxos实现原理介绍</a></p>
<p> <strong>Proposer 生成提案</strong></p>
<ol>
<li><p>Proposer 选择一个新的提案编号 Mn，然后向某个  Acceptor 集合的成员发送请求，要求该集合中 Acceptor 作出如下回应：</p>
<ul>
<li>向 Proposer 承诺，保证不再批准任何编号小于 Mn 的提案</li>
<li>如果 Acceptor 已经批准过任何提案，那么其就向 Proposer 反馈当前该 Acceptor 已经批准的编号小于 Mn 但为最大编号的那个提案的值。</li>
</ul>
</li>
</ol>
<p>   我们将请求编号为 Mn 的提案的 Prepare 请求。</p>
<ol start="2">
<li>如果 Proposer 收到了来自半数以上的 Acceptor 的响应结果，那么它就可以产生编号为 Mn，value 的值为 Vn 的提案，这里的 Vn 是所有响应中编号最大的提案的 Value 值。（半数以上的 Acceptor 都没有批准过任何提案，即响应中不包含任何的提案，那么 Vn 的值可以由 Proposer 任意选择）。</li>
</ol>
<p>在确定提案以后，Proposer 就会将该提案再次发给某个 Acceptor 集合，并期望获得他们的批准，称为 Accept 请求。</p>
<p><strong>Acceptor 批准提案</strong></p>
<ul>
<li>Prepare 请求：Acceptor 可以在任何时候响应一个 Prepare 请求。</li>
<li>Accept 请求：在不违背 Acceptor 现有承诺的前提下，可以任意响应 Accept 请求。</li>
</ul>
<p>一个 Acceptor 只要尚未响应过任何编号大于 Mn 的 Prepare 请求，那么它就可以接受这个编号为 Mn 的提案。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Distributed%20System/%E4%BB%8EPaxos%E5%88%B0Zookeeper%20%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Distributed%20System/%E4%BB%8EPaxos%E5%88%B0Zookeeper%20%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">从Paxos到Zookeeper 第一章：分布式架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 21:39:10" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 10:28:33" itemprop="dateModified" datetime="2020-05-21T10:28:33+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BB%8EPaxos%E5%88%B0Zookeeper%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">从Paxos到Zookeeper读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第一章：分布式架构"><a href="#第一章：分布式架构" class="headerlink" title="第一章：分布式架构"></a>第一章：分布式架构</h1><h2 id="从集中式到分布式"><a href="#从集中式到分布式" class="headerlink" title="从集中式到分布式"></a>从集中式到分布式</h2><ul>
<li><p>分布式系统的定义：分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p>
</li>
<li><p>分布式环境的各种问题：</p>
<ul>
<li>通信异常</li>
<li>网络分区：当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点能够进行正常的通信，俗称“脑裂”</li>
<li>三态：成功、失败和超时</li>
<li>节点故障</li>
</ul>
</li>
</ul>
<h2 id="从ACID到CAP-BASE"><a href="#从ACID到CAP-BASE" class="headerlink" title="从ACID到CAP/BASE"></a>从ACID到CAP/BASE</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>一个分布式系统不可能同时满足 一致性(C: Consistency)、可用性(A: Availability) 和分区容错性(P: Partition tolerance) 这三个基本需求，最多只能同时满足其中两项。</p>
<ul>
<li>一致性：在分布式系统中，一致性是指数据在多个副本之间是否能够保持一致的特性。</li>
<li>可用性：可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</li>
<li>分区容错性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</li>
</ul>
<p><img src="https://github.com/Wayne-98/image/blob/master/Distributed%20System/cap.png?raw=true" alt=""></p>
<ul>
<li>分区容错性是一个最基本的需求。因为既然是一个分布式系统，那么分布式系统的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然会出现子网络。而对于分布式系统而言，网络问题又是一个必然会出现的异常情况，因此分区容错性也就成了一个分布式系统必然需要面对和解决的问题。因此系统架构师往往需要把精力花在如何根据业务特点在C（一致性）和 A （可用性）之间寻求平衡。</li>
</ul>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>BASE 是  Basically Available(基本可用)、Soft State(软状态) 和 Eventually Consistent(最终一致性) 三个短语的简写。</p>
<p>BASE 是对 CAP 中一致性和可用性权衡的结果， 其来源于对大规模互联网系统分布式实践的总结，基于 CAP 定理逐渐演化而来，其核心思想是即使无法做到 强一致性(Strong consistency)，但每个应用可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)。</p>
<ul>
<li>基本可用：分布式系统在出现不可预知的故障的时候，允许损失部分可用性。</li>
<li>弱状态(软状态)：是指系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</li>
<li>最终一致性：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。最终一致性的本质是需要系统保证最终数据能够达成一致，而不需要实时保证系统数据的强一致性。</li>
</ul>
<p>最终一致性的主要变种：</p>
<ol>
<li>因果一致性(Causal consistency)：如果进程 A 在更新完某个数据项后通知了进程 B ，那么进程 B 之后对该数据项的访问都应该能够获取到进程 A 更新后的最新值，并且如果进程 B 要对该数据项进行更新操作的话，务必基于进程 A 更新后的最新值，即不能发生丢失更新的情况。</li>
<li>读己之所写(Read your writes)：进程 A 更新一个数据项之后，它总是能够访问到更新后的最新值，而不会看到旧值。</li>
<li>会话一致性(Session consistency)：会话一致性将对系统数据的访问过程框定在一个会话当中：系统能够保证在同一个有效的会话中实现“读己之所写”的一致性。也就是说，执行更新操作后，客户端能够在同一个会话中始终读取到该数据项的最新值。</li>
<li>单调读一致性(Monotonic read consistency)：如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。</li>
<li>单调写一致性(Monotonic write consistency)：一个系统需要能够保证来自同一个进程的写操作被顺序地执行。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Design%20Pattern/Head%20First%20Design%20Pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Design%20Pattern/Head%20First%20Design%20Pattern/" class="post-title-link" itemprop="url">Head First Desig Pattern</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:06:04" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Desig-Pattern/" itemprop="url" rel="index"><span itemprop="name">Desig Pattern</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式入门"><a href="#设计模式入门" class="headerlink" title="设计模式入门"></a>设计模式入门</h1><p><strong>设计原则</strong>：</p>
<ol>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>多用组合，少用继承。</li>
<li>为了交互对象之间的松耦合而努力。</li>
<li>类应该对扩展开放，对修改关闭。</li>
<li>要依赖抽象，不要依赖具体实现类。（依赖倒置原则）</li>
</ol>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><a href="https://github.com/Wayne-98/Note/tree/master/Design%20Pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/Duck" target="_blank" rel="noopener">策略模式</a></h2><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><a href="https://github.com/Wayne-98/Note/tree/master/Design%20Pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/Weather" target="_blank" rel="noopener">观察者模式</a></h2><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有的依赖者都会收到通知并自动更新。</p>
<p>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。</p>
<p>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a><a href="https://github.com/Wayne-98/Note/tree/master/Design%20Pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/Beverage" target="_blank" rel="noopener">装饰者模式</a></h2><p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
<p>装饰者和被装饰对象都有相同的超类型。</p>
<p>可以用一个或多个装饰者包装一个对象</p>
<p>既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象(被包装的)的场合，可以用装饰过的对象替代它。</p>
<p>装饰者可以在所委托被装饰者的行为之前 与/或 之后，加上自己的行为，以达到特定的目的。</p>
<p>对象可以在任何时候被装饰，所以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><a href="https://github.com/Wayne-98/Note/tree/master/Design%20Pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/Pizza" target="_blank" rel="noopener">工厂模式</a></h2><p>所有<strong>工厂模式</strong>都用来封装对象的创建。工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>
<p>抽象的<strong>创建者类</strong>：</p>
<ol>
<li><p>定义了<strong>一个抽象的工厂方法</strong>，所有的子类必须实现此方法制造产品。</p>
<ol start="2">
<li>通常会包含<strong>依赖于抽象产品的代码</strong>，而这些抽象产品由子类制造。创建者不需要真的知道在制造哪种具体产品。</li>
</ol>
</li>
</ol>
<p><strong>工厂方法模式</strong>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。</p>
<p><strong>抽象工厂模式</strong>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式确保一个类只有一个实例，并提供一个全局访问点。</p>
<p>全局变量 VS 单例模式</p>
<ol>
<li>急切实例化 VS 延迟实例化</li>
<li>全局变量可以提供全局访问，但是不能确保只有一个实例。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">并发控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:01:46" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">数据库系统概论</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>封锁协议：</li>
</ul>
<ol>
<li>一级封锁协议：事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。（解决了丢失修改）</li>
<li>二级封锁协议：在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁。（解决了 读“脏”数据）</li>
<li>三级封锁协议：在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放。（解决了不可重复读）</li>
</ol>
<ul>
<li>活锁：类似于操作系统“饿死进程”的情况，解决方案 先来先服务</li>
<li>死锁：</li>
</ul>
<ul>
<li><p>并发调度的可串行性：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，称这种调度策略为可串行化调度。</p>
<p>可串行化是并发事务正确调度的准则。</p>
</li>
</ul>
<ul>
<li>两段锁协议：所有事务必须分两个阶段对数据项进行加锁和解锁<ul>
<li>在对任何数据进行读、写之前，首先要申请并获得对该数据的封锁</li>
<li>在释放一个封锁之后，事务不再申请和获得任何其他封锁。</li>
</ul>
</li>
</ul>
<p>事务遵守两段锁协议是可串行化调度的充分不必要条件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wayne"
      src="/images/808.jpg">
  <p class="site-author-name" itemprop="name">Wayne</p>
  <div class="site-description" itemprop="description">Keep Moving</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:winter98@foxmail.com" title="E-Mail → mailto:winter98@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Wayne_98" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Wayne_98" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wayne</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
