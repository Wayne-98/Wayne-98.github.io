<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wayne-98.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Keep Moving">
<meta property="og:type" content="website">
<meta property="og:title" content="Wayne">
<meta property="og:url" content="http://wayne-98.github.io/page/6/index.html">
<meta property="og:site_name" content="Wayne">
<meta property="og:description" content="Keep Moving">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wayne">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://wayne-98.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wayne</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wayne" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wayne</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Love Yourz</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Design%20Pattern/Head%20First%20Design%20Pattern/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Design%20Pattern/Head%20First%20Design%20Pattern/" class="post-title-link" itemprop="url">Head First Desig Pattern</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:06:04" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Desig-Pattern/" itemprop="url" rel="index"><span itemprop="name">Desig Pattern</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式入门"><a href="#设计模式入门" class="headerlink" title="设计模式入门"></a>设计模式入门</h1><p><strong>设计原则</strong>：</p>
<ol>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>多用组合，少用继承。</li>
<li>为了交互对象之间的松耦合而努力。</li>
<li>类应该对扩展开放，对修改关闭。</li>
<li>要依赖抽象，不要依赖具体实现类。（依赖倒置原则）</li>
</ol>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><a href="https://github.com/Wayne-98/Note/tree/master/Design%20Pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/Duck" target="_blank" rel="noopener">策略模式</a></h2><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><a href="https://github.com/Wayne-98/Note/tree/master/Design%20Pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/Weather" target="_blank" rel="noopener">观察者模式</a></h2><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有的依赖者都会收到通知并自动更新。</p>
<p>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。</p>
<p>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a><a href="https://github.com/Wayne-98/Note/tree/master/Design%20Pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/Beverage" target="_blank" rel="noopener">装饰者模式</a></h2><p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
<p>装饰者和被装饰对象都有相同的超类型。</p>
<p>可以用一个或多个装饰者包装一个对象</p>
<p>既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象(被包装的)的场合，可以用装饰过的对象替代它。</p>
<p>装饰者可以在所委托被装饰者的行为之前 与/或 之后，加上自己的行为，以达到特定的目的。</p>
<p>对象可以在任何时候被装饰，所以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><a href="https://github.com/Wayne-98/Note/tree/master/Design%20Pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/Pizza" target="_blank" rel="noopener">工厂模式</a></h2><p>所有<strong>工厂模式</strong>都用来封装对象的创建。工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>
<p>抽象的<strong>创建者类</strong>：</p>
<ol>
<li><p>定义了<strong>一个抽象的工厂方法</strong>，所有的子类必须实现此方法制造产品。</p>
<ol start="2">
<li>通常会包含<strong>依赖于抽象产品的代码</strong>，而这些抽象产品由子类制造。创建者不需要真的知道在制造哪种具体产品。</li>
</ol>
</li>
</ol>
<p><strong>工厂方法模式</strong>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。</p>
<p><strong>抽象工厂模式</strong>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式确保一个类只有一个实例，并提供一个全局访问点。</p>
<p>全局变量 VS 单例模式</p>
<ol>
<li>急切实例化 VS 延迟实例化</li>
<li>全局变量可以提供全局访问，但是不能确保只有一个实例。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" class="post-title-link" itemprop="url">并发控制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:01:46" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">数据库系统概论</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>封锁协议：</li>
</ul>
<ol>
<li>一级封锁协议：事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。（解决了丢失修改）</li>
<li>二级封锁协议：在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁。（解决了 读“脏”数据）</li>
<li>三级封锁协议：在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放。（解决了不可重复读）</li>
</ol>
<ul>
<li>活锁：类似于操作系统“饿死进程”的情况，解决方案 先来先服务</li>
<li>死锁：</li>
</ul>
<ul>
<li><p>并发调度的可串行性：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，称这种调度策略为可串行化调度。</p>
<p>可串行化是并发事务正确调度的准则。</p>
</li>
</ul>
<ul>
<li>两段锁协议：所有事务必须分两个阶段对数据项进行加锁和解锁<ul>
<li>在对任何数据进行读、写之前，首先要申请并获得对该数据的封锁</li>
<li>在释放一个封锁之后，事务不再申请和获得任何其他封锁。</li>
</ul>
</li>
</ul>
<p>事务遵守两段锁协议是可串行化调度的充分不必要条件。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/" class="post-title-link" itemprop="url">关系数据理论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:02:00" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/" itemprop="url" rel="index"><span itemprop="name">数据库系统概论</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="不规范的模式存在的问题"><a href="#不规范的模式存在的问题" class="headerlink" title="不规范的模式存在的问题"></a>不规范的模式存在的问题</h1><ol>
<li>数据冗余</li>
<li>更新异常</li>
<li>插入异常</li>
<li>删除异常</li>
</ol>
<h1 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>定义：设 R(U) 是属性集 U 上的关系模式，X, Y 是 U 的子集。若对于 R(U) 的任意一个可能的关系r, r中不可能存在两个元组在 X 上的属性值相等，而在 Y 上的属性值不相等，则称 <strong>X 函数决定于 Y 或 Y 函数依赖于 X</strong>, 记作 X –&gt; Y</p>
<p>X 函数决定于 Y, 但 Y ∉ X，则称 X 函数决定于 Y 是非平凡的函数依赖。</p>
<p>X 函数决定于 Y, 但 Y ∈ X，则称X 函数决定于 Y 是平凡的函数依赖。(必然成立)</p>
<p>在 R(U) 中，如果 X 函数决定于 Y, 并且对于 X 的任意一个真子集 X’, 都有 X‘ 不能函数决定于 Y, 则称 Y 对 X <strong>完全函数依赖</strong>。</p>
<p>在 R(U)中，如果 X 函数决定于 Y (Y ∉ X)，Y 不函数决定于 X，Y 函数决定于 Z，Z ∉ Y 则称 Z 对 X 传递函数依赖。 </p>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>第一范式：二维表中每一个分量必须是不可分的数据项。</p>
<hr>
<p><strong>第二范式</strong>：若 R ∈ 1 NF, 并且每一个非主属性完全函数依赖于任何一个候选键。</p>
<p>例如 S-L-C(<u>Sno</u>, Sdept, Sloc, <u>Cno</u>, Grade)</p>
<p>函数依赖有</p>
<p>(Sno, Cno) –&gt; Grande 完全函数依赖</p>
<p>Sno –&gt; Sdept</p>
<p>Sno –&gt; Sloc</p>
<p>Sdept –&gt; Sloc</p>
<p>(Sno, Cno) –&gt; Sdept 部分函数依赖</p>
<p>(Sno, Cno) –&gt; Sloc 部分函数依赖</p>
<p>则 S-L-C 不属于第二范式，因为非主属性 Sdept, Sloc 并不完全函数依赖于键。</p>
<p>因此可能产生的问题：</p>
<ol>
<li><p>插入异常：如果此学生还未选课，则不能插入。因为键值一部分为空。</p>
</li>
<li><p>删除异常：如果一个学生只选了一门课，则他退课的时候，所有关于该生的信息都删除了。</p>
</li>
<li><p>修改复杂：如果一个学生转系了，则需要更新所有的 Sdept, Sloc。</p>
</li>
</ol>
<p>进行模式分解：SC(<u>Sno, Cno</u>, Grade) 和 SL(<u>Sno</u>, Sdept, Sloc)</p>
<hr>
<p><strong>第三范式</strong>：若 R 属于第三范式，则每一个非主属性既不传递依赖于键，也不部分依赖于键。</p>
<p>例如 SL(<u>Sno</u>, Sdept, Sloc), 其中 Sloc 传递依赖于 Sno，因此SL不属于第三范式。</p>
<p>继续模式分解：SD(Sno, Sdept) 和 DL(Sdept, Sloc)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Database/SQL/sql%20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Database/SQL/sql%20%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">SQL 语句</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:00:39" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL/" itemprop="url" rel="index"><span itemprop="name">SQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取 Employee 表中第 n 高的薪水（Salary）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">set</span> n = N - <span class="number">1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      <span class="comment"># Write your MySQL query statement below.</span></span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">ifnull</span>( <span class="comment"># 如果第一个值为 null，则返回第二个值</span></span><br><span class="line">            (</span><br><span class="line">              <span class="keyword">select</span> <span class="keyword">distinct</span> salary </span><br><span class="line">              <span class="keyword">from</span> employee </span><br><span class="line">              <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">               <span class="keyword">limit</span> n, <span class="number">1</span> <span class="comment"># 从第 n 行开始，返回一行数据</span></span><br><span class="line">            ), <span class="literal">null</span>)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Score, </span><br><span class="line">       <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> <span class="string">'Rank'</span></span><br><span class="line"><span class="keyword">from</span> Scores;</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> Email</span><br><span class="line"><span class="keyword">from</span> person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Email</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(Email) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'Name'</span> <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> Customers a <span class="keyword">left</span> <span class="keyword">join</span> Orders b <span class="keyword">on</span> a.id = b.CustomerId <span class="keyword">where</span> b.id <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment"># 要判断一个数是否等于NULL只能用 IS NULL 或者 IS NOT NULL 来判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">Name</span> <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> Customers</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> CustomerId </span><br><span class="line">    <span class="keyword">from</span> orders</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p1</span><br><span class="line"><span class="keyword">from</span> (person p1 <span class="keyword">left</span> <span class="keyword">join</span> person p2 <span class="keyword">on</span> p1.email = p2.email )</span><br><span class="line"><span class="keyword">where</span> p1.id &gt; p2.id;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E5%A4%8D%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E5%A4%8D%E5%88%B6/" class="post-title-link" itemprop="url">高性能MySQL读书笔记第十章：复制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 21:39:10" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 10:28:04" itemprop="dateModified" datetime="2020-05-21T10:28:04+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">高性能MySQL读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="复制概述"><a href="#复制概述" class="headerlink" title="复制概述"></a>复制概述</h2><p>基于行的复制和基于语句的复制，都是通过在主库上记录二进制日志，在备库重放日志的方式来实现异步的数据复制。</p>
<h3 id="复制解决的问题"><a href="#复制解决的问题" class="headerlink" title="复制解决的问题"></a>复制解决的问题</h3><ol>
<li>数据分布</li>
<li>负载均衡</li>
<li>备份</li>
<li>高可用性和故障切换</li>
<li>MySQL升级测试</li>
</ol>
<h3 id="复制如何工作"><a href="#复制如何工作" class="headerlink" title="复制如何工作"></a>复制如何工作</h3><ul>
<li>在主库上把数据更改记录到二进制日志中</li>
</ul>
<p>在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。</p>
<ul>
<li>备库将主库上的日志复制到自己的中继日志中</li>
</ul>
<p>首先，备库会启动一个 I/O 线程，该线程和主库建立一个普通的客户端连接</p>
<p>然后在主库中建立启动一个特殊的二进制转储线程，该线程会读取主库上二进制日志中的事件。（wait，notify）</p>
<ul>
<li>备库读取中继日志中的事件，将其重放到备库数据之上</li>
</ul>
<p>这种复制架构实现了事件的获取和重返事件的解耦，允许这两个过程异步进行。也就是 I/O 线程能够独立于 SQL 线程之外工作。</p>
<p>主库上并发运行的查询到备库上只能串行化执行，因为只有一个 SQL 线程来重放中继日志中的事件</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%89%A9%E5%B1%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%89%A9%E5%B1%95/" class="post-title-link" itemprop="url">高性能MySQL读书笔记第十一章：扩展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 21:39:10" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 10:28:03" itemprop="dateModified" datetime="2020-05-21T10:28:03+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">高性能MySQL读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="向上扩展"><a href="#向上扩展" class="headerlink" title="向上扩展"></a>向上扩展</h1><p>加强服务器性能</p>
<h1 id="向外扩展"><a href="#向外扩展" class="headerlink" title="向外扩展"></a>向外扩展</h1><ol>
<li>按功能拆分</li>
<li>数据分片：通用且成功</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">高性能MySQL读书笔记第六章：查询性能优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 21:39:10" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 10:28:00" itemprop="dateModified" datetime="2020-05-21T10:28:00+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">高性能MySQL读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="为什么查询速度会慢？"><a href="#为什么查询速度会慢？" class="headerlink" title="为什么查询速度会慢？"></a>为什么查询速度会慢？</h2><ul>
<li><p>查询的生命周期</p>
<p>查询的生命周期，从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。执行是查询生命周期最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等等。</p>
</li>
</ul>
<h2 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h2><ul>
<li>分析步骤</li>
</ul>
<ol>
<li><p>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也是可能访问了太多的列</p>
</li>
<li><p>确认MySQL服务器层是否在分析大量超过需要的数据行</p>
</li>
</ol>
<h3 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h3><ol>
<li>查询不需要的记录（加上limit）</li>
<li>多表关联时返回全部列（查询涉及三张表的时候，使用select *）</li>
<li>总是取出全部列（无法使用索引覆盖扫描，慎用select*）</li>
<li>重复查询相同的数据（缓存）</li>
</ol>
<h3 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h3><ul>
<li><strong>衡量查询开销的三个指标：</strong></li>
</ul>
<ol>
<li><p>响应时间：</p>
<ul>
<li>服务时间是指数据库处理这个查询花了多少时间</li>
<li>排队时间是指服务器因为等待某些资源而没有真正执行查询的时间。可能是等I/O操作完成，等行锁</li>
</ul>
</li>
<li><p>扫描的行数：</p>
</li>
<li><p>返回的行数：</p>
</li>
</ol>
<p>这三个指标都会存放在MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。</p>
<ul>
<li><strong>访问类型：</strong></li>
</ul>
<p>全表扫描，索引扫描，范围扫描，唯一索引查询，常数引用</p>
<ul>
<li><strong>MySQL 应用 where ：</strong></li>
</ul>
<ol>
<li>在索引中使用 where 条件来过滤不匹配的记录。在存储引擎层完成的。</li>
<li>使用索引扫描(在 Extra 列中出现了 Using Index )来返回记录，直接从索引中过滤不需要的记录并返回命中结果。这是在 MySQL 服务器层完成的，但无须回表查询记录</li>
<li>在数据表中返回数据，然后过滤不满足条件的记录(在 Extra 列中出现 Using Where)。这是在 MySQL 服务器层完成，MySQL 需要先从数据表读出记录然后过滤</li>
</ol>
<h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><ul>
<li><p><strong>一个复杂的查询还是多个简单的查询</strong></p>
</li>
<li><p><strong>切分查询：</strong>大查询切分成小查询，每个查询功能完全一样，每次只完成一小部分</p>
</li>
<li><p><strong>分解关联查询：</strong></p>
</li>
</ul>
<ol>
<li><p>对每一个表进行一次单表查询，然后将结果在应用程序中进行关联</p>
</li>
<li><p>让缓存的效率更高  </p>
</li>
<li><p>将查询分解后，执行单个查询可以减少锁的竞争</p>
</li>
<li><p>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展</p>
</li>
</ol>
<h2 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h2><ol>
<li><p>客服端发送一条查询给服务器</p>
</li>
<li><p>服务器先检查查询缓存，如果命中缓存，则立即返回</p>
</li>
<li><p>服务器端进行SQL解析，预处理，再由优化器生成对应的执行计划</p>
</li>
<li><p>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询</p>
</li>
<li><p>返回结果给客户端</p>
</li>
</ol>
<h3 id="MySQL客户端-服务端通信协议：半双工"><a href="#MySQL客户端-服务端通信协议：半双工" class="headerlink" title="MySQL客户端/服务端通信协议：半双工"></a>MySQL客户端/服务端通信协议：半双工</h3><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><h3 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h3><ol>
<li><p>语法解析器和预处理：生成“解析树”并验证解析树是否合法，验证权限</p>
</li>
<li><p>查询优化器：基于成本的优化器</p>
</li>
<li><p>数据和索引统计信息：统计信息在存储引擎层，服务器层在执行查询优化的时候需要调用api</p>
</li>
<li><p>MySQL如何执行关联查询：嵌套循环关联操作</p>
<ul>
<li>MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的列。<ul>
<li>如果是左外连接，取出单条数据遍历下一个表的时候，如果没有匹配，则输出当前行+NULL</li>
<li>右连接改正等价的左外连接</li>
</ul>
</li>
</ul>
</li>
<li><p>执行计划：生成一颗查询的指令树</p>
</li>
<li><p>关联查询优化器：</p>
</li>
<li><p>排序优化：</p>
<ul>
<li><p>如果需要排序的数据量小于“排序缓冲区”，MySQL使用内存进行“快排”。如果内存不够，MySQL先将数据分块，每个独立的块使用快排然后刷到磁盘上，最后将各个排好序的块合并。</p>
</li>
<li><p>排序算法：</p>
<ul>
<li><p>两次传输排序：读取行指针和需要排序的字段，对其进行排序，然后根据排序结果读取所需要的数据行。优点是排序的时候存储尽可能少的数据，缺点是第二次数据传输的时候又大量的随机I/O</p>
</li>
<li><p>单次传输排序：先读取查询所需要的所有的列，然后再根据给定列进行排序，最后直接返回结果</p>
</li>
</ul>
</li>
<li><p>关联查询的时候如果需要排序：</p>
<ul>
<li>orderBy 子句中的所有列全部来自关联的第一个表，那么 MySQL 在关联处理第一个表时就进行文件排序。Extra：Using filesort</li>
<li>除此之外，MySQL 都会将关联的结果存放在一个临时表中，在所有的关联都结束的时候，再进行文件排序。Extra：Using temporary；Using filesort</li>
<li>有limit，也会对全量数据排序，然后返回较少的数据（5.6版本之后，对这个有优化，不再是全量数据排序）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h3><ul>
<li>解析和优化阶段，MySQL生成对应的执行计划(数据结构)</li>
<li>查询中的每个表有一个handler的实例表示，存储引擎的接口称为handler API</li>
</ul>
<h3 id="返回结果给客户端：TCP"><a href="#返回结果给客户端：TCP" class="headerlink" title="返回结果给客户端：TCP"></a>返回结果给客户端：TCP</h3>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/" class="post-title-link" itemprop="url">高性能MySQL读书笔记第五章：创建高性能的索引</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 21:39:10" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 10:28:06" itemprop="dateModified" datetime="2020-05-21T10:28:06+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">高性能MySQL读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h1><p>MySQL的索引是在存储引擎层实现的</p>
<h2 id="磁盘IO与预读"><a href="#磁盘IO与预读" class="headerlink" title="磁盘IO与预读"></a>磁盘IO与预读</h2><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为<strong>寻道时间</strong>、<strong>旋转延迟</strong>、<strong>传输时间</strong>三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在<strong>5ms</strong>以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = <strong>4.17ms</strong>；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</p>
<p>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，<strong>当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内</strong>，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为<strong>4k</strong>或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<p>3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><ol>
<li>B+Tree索引</li>
</ol>
<ul>
<li><p>B+Tree索引有不同的<strong>实现方式</strong>，各有优劣。</p>
<ul>
<li>MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储</li>
<li>MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行</li>
</ul>
</li>
<li><p>可以使用B+Tree索引的类型</p>
<ul>
<li>B+Tree索引适合于全键值、键值范围或键前缀查找(根据最左前缀的查找)<br>  <strong>B+Tree索引的有效查询类型</strong>：<ul>
<li>全值匹配</li>
<li><strong>匹配最左前缀</strong></li>
<li>匹配列前缀</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另一列</li>
<li>只访问索引的查询</li>
<li>如果orderby子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求</li>
</ul>
</li>
</ul>
</li>
<li><p>B+Tree索引的一些<strong>限制</strong></p>
<ul>
<li>如果不是从索引的最左列开始查找，则无法使用索引</li>
<li>不能跳过索引中的列（比如说我查询第一列和第三列，则索引只能使用第一列）</li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</li>
</ul>
</li>
</ul>
<h1 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h1><ul>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变为顺序I/O</li>
</ul>
<h1 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h1><h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p>指索引列不能是表达式的一部分，也不能是函数的参数</p>
<h2 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h2><ul>
<li>索引很长的字符串，需要使用前缀索引，这样可以大大减少索引空间，从而提升索引效率。但是会降低索引的选择性。（BLOB，TEXT必须使用前缀索引）</li>
<li>索引的选择性是指，不重复的索引值和数据表记录总数的比值。</li>
<li>MySQL无法使用前缀索引做 order by和 group by，也无法使用前缀索引做覆盖扫描。</li>
</ul>
<h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>为每一个列创建单独的索引，或者按照错误的顺序创建多列索引，是错误的。</p>
<h2 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h2><ul>
<li>当不需要考虑排序和分组的时候，将选择性最高的列放到前面通常是很好的。这时索引的作用是优化where条件的查找</li>
<li>将选择性最高的列放在索引的最前列，在某些场景可能有帮助，但通常不如避免随机I/O和排序那么重要，考虑问题需要全面。</li>
</ul>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。<br>数据行实际存放在索引的叶子页中，“聚簇”表示数据行和相邻的键值紧凑的存储在一起。</p>
<h3 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h3><ul>
<li>可以把相关的数据保存在一起</li>
<li>因为聚簇索引把索引和数据保存在同一个B+Tree中，所以数据访问更快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li>
<li>使用主键值当作指针会让二级索引占用更多的空间，换来的好处是，InnoDB在移动行的时候无须更新二级索引中这个“指针”</li>
</ul>
<h3 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h3><ul>
<li>聚簇索引最大限度的提高了 I/O 密集型应用的提升，如果数据全部在内存中，则访问的顺序就没有那么重要了，聚簇索引的优势也就没了。</li>
<li>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式。如果不是，插入完成后最好使用 OPTIMIZE TABLE 命令重新组织一下表。</li>
<li>更新聚簇索引的代价很高，因为会强制 InnoDB 将每个被更新的行移动到新的位置</li>
<li>基于聚簇索引的表在插入新行或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。<ul>
<li>当行的主键值要求必须将这一行插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，这就是一项页分裂的操作。页分裂会导致占用更多的磁盘空间</li>
</ul>
</li>
<li>聚簇索引可能会导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候</li>
<li>二级索引(非聚簇索引)可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</li>
<li>二级索引访问需要两次索引查找，而不是一次<ul>
<li>二级索引叶子结点保存的不是指向行物理位置的指针，而是行的主键值</li>
<li>存储引擎需要找到二级索引的叶子结点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行  </li>
</ul>
</li>
</ul>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果一个索引包含所有需要查询的值，我们就称之为覆盖索引。</p>
<ul>
<li>覆盖索引的优点：<ol>
<li>索引条目通常远小于数据行的大小，如果只需要读取索引，MySQL就会极大地减少数据访问量。</li>
<li>因为索引是按照列值顺序存储的，所以对于 I/O 密集型的范围查询会比随机磁盘读取每一行的数据的 I/O 要少得多。</li>
<li>因为 InnoDB 的聚簇索引，覆盖索引可以避免回表查询。</li>
</ol>
</li>
</ul>
<p>当发起一个被索引覆盖的查询时，在 explain 的 Extra 列可以看到 “Using index” 的信息。</p>
<h3 id="使用索引扫描来排序"><a href="#使用索引扫描来排序" class="headerlink" title="使用索引扫描来排序"></a>使用索引扫描来排序</h3><p>EXPLAIN 出来的列的 type 列的值为 “index” ，则说明 MySQL 使用了索引扫描来做排序。</p>
<p>MySQL使用索引来对结果做排序的一些限制：</p>
<ol>
<li><p>只有当索引列的顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向都一样时</p>
<ol start="2">
<li>如果需要关联多张表，则只有当 ORDER BY 子句引用的字段全部为第一个表时</li>
<li>其他查找型的限制(最左前缀优先等等)</li>
</ol>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AMySQL%E6%9E%B6%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AMySQL%E6%9E%B6%E6%9E%84/" class="post-title-link" itemprop="url">高性能MySQL读书笔记第一章：MySQL架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-10 21:39:10" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-21 10:28:08" itemprop="dateModified" datetime="2020-05-21T10:28:08+08:00">2020-05-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">高性能MySQL读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><ul>
<li><strong>连接管理、授权认证与安全</strong><br>  每个客户端连接都会在服务器进程中拥有一个线程<br>  认证基于用户名、原始主机信息和密码</li>
<li><strong>优化与执行</strong><br>MySQL 会解析查询，并创建内部数据结构，然后对其进行各种优化，包括重写查询、决定表的读取顺序以及选择合适的索引等。</li>
</ul>
<hr>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ul>
<li><strong>并发控制的两个层面：</strong><br>  服务器层和存储引擎层</li>
<li><strong>读写锁</strong><br>  读锁是共享的，相互不堵塞的<br>  写锁是排他的，一个写锁会堵塞其他读锁和写锁</li>
<li><strong>锁粒度</strong><br>  表锁：最基本的锁策略，开销最小的策略，（一般是在服务器层实现）<br>  行锁：支持最大程度的并发处理，同时也带来了最大的锁开销，行级锁只在存储引擎实现</li>
</ul>
<hr>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务就是一个原子性的 SQL 查询或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。</p>
<ul>
<li><p><strong>ACID</strong></p>
<ol>
<li>Atomicity 原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对一个事务来说，不可能只执行其中的一部分操作。</li>
<li>Consistency 一致性：数据库总是从一个一致性状态转换到另外一个一致性状态。</li>
<li>Isolation 隔离性：一个事务所做的修改在最终提交以前，对其他事务是不可见的。</li>
<li>Durability 持续性：一旦事务提交，其所做的修改就会永久保存到数据库中。</li>
</ol>
</li>
<li><p><strong>隔离级别</strong></p>
<ol>
<li>READ UNCOMMITTED (未提交读)<ul>
<li>在未提交读级别，事务中的修改，即使没有提交，对其他事务也是可见的</li>
<li>事务可以读取未提交的数据，被称为脏读</li>
</ul>
</li>
<li>READ COMMITTED (提交读)<ul>
<li>提交读满足隔离性的定义。一个事务开始时，只能“看见”已经提交的事务所做的修改</li>
<li>也称作不可重复读，一个事务内执行两次同样的查询，可能会得到不一样的结果</li>
</ul>
</li>
<li>REPEATABLE READ (可重复读)（是 MySQL 默认事务隔离级别）<ul>
<li>解决了脏读的问题，该级别保证了在同一个事务中多次读取同样记录的结果是一致的</li>
<li>幻读：当某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的时候就会产生幻行。多版本并发控制 MVCC 解决了幻读的问题</li>
</ul>
</li>
<li>SERIALIZABLE (可串行化)<ul>
<li>强制事务串行执行</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>死锁</strong><br>  死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。<br>  InnoDB目前处理死锁的方法是将持有最少行级排他锁的事务进行回滚</p>
</li>
<li><p><strong>事务日志</strong></p>
<ol>
<li>可以帮助提高事务的效率</li>
<li>使用事务日志，存储引擎在修改表数据的时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</li>
<li>事务日志采取的是追加的方式，因此写日志的操作是磁盘上一小块区域的顺序 I/O ,而不是像随机 I/O 需要在磁盘的多个地方移动磁头</li>
<li>事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘</li>
</ol>
</li>
<li><p><strong>MySQL中的事务</strong></p>
<ol>
<li>自动提交：如果不显式的开始一个事务，则每个查询都会被当成一个事务执行操作</li>
<li>在事务中混合使用存储引擎：MySQL 服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。</li>
<li>隐式和显式锁定：InnoDB 采用的是两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行 commit 或者 rollback 的时候才会释放，并且所有的锁是在同一时刻被释放。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><ul>
<li><p>可以认为 MVCC 是行级锁的一个变种，但是它在很多情况下避免的加锁操作，因此开销更低。虽然实现的机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p>
</li>
<li><p>MVCC 的实现，是通过保存数据在某个时间点上的快照实现的。</p>
<ul>
<li>事务快照是用来存储数据库的事务运行情况，用来做可见性判断</li>
<li>一个事务快照的创建过程可以概括为：<ol>
<li>查看当前所有的未提交并活跃的事务，存储在数组中</li>
<li>选取未提交并活跃的事务中最小的XID，记录在快照的xmin中</li>
<li>选取所有已提交事务中最大的XID，加1后记录在xmax中</li>
</ol>
</li>
<li>快照生成时机的不同, 造成了RC,RR两种隔离级别的不同可见性<ol>
<li>repeatable read 级别, 事务在 begin/start transaction 之后的第一条 select 读操作后, 会创建一个快照(read view), 将当前系统中活跃的其他事务记录记录起来;</li>
<li>read committed 级别, 事务中每条 select 语句都会创建一个快照(read view);</li>
</ol>
</li>
</ul>
</li>
<li><p>InnoDB 的 MVCC，InnoDB存储引擎在数据库每行数据的后面添加了三个字段来实现的。一个字段保存了行的创建时间，一个保存了行的过期(删除)时间。存储并不是实际时间值，而是系统版本号。每开始一个事务，系统版本号都会自动递增。还有一个是回滚指针(DB_ROLL_PTR)字段: 指写入回滚段(rollback segment)的 undo log record (撤销日志记录)。</p>
<ol>
<li>SELECT：<ul>
<li>InnoDB只查找版本早于当前事务版本的数据行。这样可以确保事务读取的行要么是在事务开始前就已经存在的，要么是事务自身插入或修改过的</li>
<li>行的删除版本号要么未定义，要么大于当前事务版本号。这可以确保事务读到的行，在事务开始之前未被删除</li>
</ul>
</li>
<li>INSERT<br> InnoDB为新插入的每一行保存当前系统版本号作为行版本号</li>
<li>DELETE<br> InnoDB为删除的每一行保存当前系统版本号作为行删除标识</li>
<li>UPDATE<br> InnoDB为插入一行新数据，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识</li>
</ol>
</li>
<li><p>MVCC只在可重复读和提交读两个隔离级别下工作</p>
<ol>
<li>未提交读总是读取最新的数据行，而不是符合当前事务版本的数据行。</li>
<li>SERIALIZABLE 则会对所有读取的行都加锁。</li>
</ol>
</li>
<li><p>Undo-log</p>
<ol>
<li>Undo log 是 InnoDB MVCC 事务特性的重要组成部分。当我们对记录做了变更操作时就会产生 undo记录，Undo 记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。</li>
<li>Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作（例如bug#69812）。</li>
<li>大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo</li>
<li>另外, 在回滚段中的undo logs分为: insert undo log 和 update undo log<ul>
<li>insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</li>
<li>update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><ul>
<li>InnoDB<ol>
<li>InnoDB的数据存储在表空间中，表空间是由InnoDB管理的黑盒子，由一系列的数据文件组成。InnoDB可以将每个表的数据和索引放在单独的文件中。</li>
<li>InnoDB采用MVCC来支持高并发，默认的隔离级别是可重复读，并且通过间隙锁(next-key locking)策略防止幻读的出现。间隙锁是的InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入<ul>
<li>InnoDB支持行锁（锁定字段含有索引的情况下，否则走表锁），但锁定方式并非简单的锁定指定行上的索引，而是分为3种锁定算法：<br>1）记录锁（Record Locks）：锁定指定行的索引项<br>2）Gap Locks：锁定某一个范围内的索引，但不包括记录本身<br>3）间隙锁定（Next-Key Locks）：锁定一个范围内的索引，并且锁定记录本身   Next-Key Locks = Record Locks + Gap Locks<br>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record</li>
</ul>
</li>
<li>InnoDB表是基于聚簇索引来实现的，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列。因此若表上的索引较多的话，主键应当尽可能的小。</li>
</ol>
</li>
<li>MyISAM<ol>
<li>MySQL5.1及之前的版本，是默认存储引擎。MyISAM提供了大量的特性，包括全文索引，压缩，空间函数等</li>
<li>MyISAM不支持事务和行级锁，并且崩溃后无法安全恢复</li>
<li>存储：MyISAM将表存储在两个文件中：数据文件和索引文件。表可以包括动态或静态行</li>
<li>特性<ul>
<li>加锁和并发：对整张表加锁；在表有读取查询的同时，也可以往表中插入新的记录，称为并发插入</li>
<li>修复：check table mytable; repair table mytable</li>
<li>索引：即使是BLOB和TEXT等长字段，基于前500个字符创建索引；支持全文索引，是一种基于分词创建的索引</li>
<li>延迟更新索引键：在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘</li>
</ul>
</li>
<li>压缩表：压缩表是不能修改的，可以极大的减少磁盘空间占用，因此也可以减少磁盘I/O，从而提升查询性能。支持索引，索引也是只读的</li>
</ol>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Algorithms/May/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Algorithms/May/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">图论算法复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：21:56:07" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h1><p>图的定义：图 G 由顶点集 V 和边集 E 组成，记为 G = (V, E), 其中 V(G) 表示图 G 中顶点的有限非空集；E(G) 表示图中顶点之间的关系(边)集合。</p>
<p>连通：在无向图中，若从顶点 v 到顶点 w 之间有路径存在，则称 v 和 w 是连通的。</p>
<p>连通分量：无向图中的极大连通子图称为连通分量。</p>
<p>生成树：连通图的生成树是包含图中所有顶点的一个极小连通子图。若图中订点数为 n，则它的生成树含有 n - 1 条边。对于生成树而言，去掉它的一条边，则会变成非连通图，若加上一条边，则会形成一条回路。</p>
<p>顶点的度：图中每个顶点的度被定义为以该顶点为端点的边的数目。</p>
<h1 id="图的存储及基本操作"><a href="#图的存储及基本操作" class="headerlink" title="图的存储及基本操作"></a>图的存储及基本操作</h1><ul>
<li><p>邻接矩阵法</p>
</li>
<li><p>邻接表法</p>
</li>
</ul>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><ul>
<li>BFS</li>
</ul>
<p>BFS 的时间复杂度：</p>
<ol>
<li>如果图是邻接表存储的。每个顶点需要访问一次，每个顶点的邻接点也需要搜索一次。O(V) + O(E)</li>
<li>如果图是邻接矩阵存储的。搜索一个顶点的邻接点需要O(V). 所以时间复杂度是O(V²)</li>
</ol>
<p><img src="" alt=""></p>
<ul>
<li>DFS</li>
</ul>
<h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><ul>
<li>最小生成树</li>
</ul>
<ol>
<li><p>Prim</p>
<ul>
<li>初始化：向空树 T = (Vt, Et) 中添加图 G = {V, E} 的任一顶点 u0，使 Vt = {u0}, Et = ∅</li>
<li>循环（重复操作直至 Vt  =  V）: 从图 G 中选出满足 {(u, v) | u ∈ Vt, v ∈ V - Vt} 且具有最小权值的边 (u, v) , 并置 Vt = Vt ∪ {v}, Et = Et ∪ {u, v}。</li>
</ul>
<p><img src="" alt=""></p>
</li>
</ol>
<p>Prim 算法的时间复杂度是O(V²)，不依赖于 E ，适合求解边稠密的图的最小生成树。</p>
<ol start="2">
<li><p>Kruskal</p>
<ul>
<li>初始化：Vt = V, Et = ∅。即每一个顶点构成一棵独立的树，T 此时是一个仅含 V 个顶点的森林。</li>
<li>循环（重复操作直至 T 是一棵树）：按 G 的边的权值递增顺序依次从 E - Et 中选择一条边，若这条边加入 T 后不构成回路，则将其加入 Et，否则舍弃，直到 Et 中含有 n - 1 条边。</li>
</ul>
<p><img src="" alt=""></p>
</li>
</ol>
<p>Kruskal 算法的时间复杂度是 O(E log E)</p>
<ul>
<li>最短路径</li>
</ul>
<p>两点之间的最短路径也包含了路径上其他顶点间的最短路径。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wayne"
      src="/images/808.jpg">
  <p class="site-author-name" itemprop="name">Wayne</p>
  <div class="site-description" itemprop="description">Keep Moving</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">65</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:winter98@foxmail.com" title="E-Mail → mailto:winter98@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Wayne_98" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Wayne_98" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wayne</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
