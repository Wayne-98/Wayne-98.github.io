<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wayne-98.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Keep Moving">
<meta property="og:type" content="website">
<meta property="og:title" content="Wayne">
<meta property="og:url" content="http://wayne-98.github.io/index.html">
<meta property="og:site_name" content="Wayne">
<meta property="og:description" content="Keep Moving">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wayne">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://wayne-98.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wayne</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wayne" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wayne</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Love Yourz</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/27/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%8D%81%E7%AB%A0RDB%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/27/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%8D%81%E7%AB%A0RDB%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第二部分:单机数据的实现:第十章:RDB持久化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-27 11:27:08 / 修改时间：11:27:45" itemprop="dateCreated datePublished" datetime="2020-05-27T11:27:08+08:00">2020-05-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/26/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B9%9D%E7%AB%A0%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/26/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B9%9D%E7%AB%A0%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第二部分:单机数据的实现:第九章:数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-26 10:44:43" itemprop="dateCreated datePublished" datetime="2020-05-26T10:44:43+08:00">2020-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-27 11:27:01" itemprop="dateModified" datetime="2020-05-27T11:27:01+08:00">2020-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器的数据库数量</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;<span class="comment">// default 16</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h1><p>Redis 客户端的默认目标数据库为 0 号数据库，SELECT </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>



<h1 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h1><p>Redis 是一个 KV 数据库服务器，服务器中的每个数据库都由一个 redis.h / redisDb 结构表示，其中 redisDb 结构的 dict 字典保存了数据库中的所有键值对，我们将这个字典称为键空间(key space).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>键空间和用户所见的数据库是直接对应的：</p>
<ul>
<li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li>
<li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种 Redis 对象。</li>
</ul>
<h2 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h2><p>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的 Redis 对象。</p>
<h2 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h2><p>删除一个数据库中一个键，实际上就是在键空间里面删除键所对应的键值对对象。</p>
<h2 id="更新键"><a href="#更新键" class="headerlink" title="更新键"></a>更新键</h2><p>对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。</p>
<h2 id="对键取值"><a href="#对键取值" class="headerlink" title="对键取值"></a>对键取值</h2><p>对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值的对象，根据值对象的类型不同，具体的取值方法也有所不同。</p>
<h2 id="其他键空间操作"><a href="#其他键空间操作" class="headerlink" title="其他键空间操作"></a>其他键空间操作</h2><p>还有很多针对数据库本身的 Redis 命令，也是通过对键空间进行处理来完成的。</p>
<ul>
<li><em>FLUSHDB</em>：通过删除键空间中的所有键值对来实现。</li>
<li><em>RANDOMKEY</em>：通过在键空间中随机返回一个键来实现的。</li>
<li><em>DBSIZE</em>：通过返回键空间中包含的键值对的数量来实现的。</li>
<li><em>EXISTS</em>, <em>RENAME</em>, <em>KEYS</em></li>
</ul>
<h2 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h2><p>当使用 Redis 命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的操作：</p>
<ul>
<li><p>读取一个键之后（读写操作都需要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数。<em>INFO stats</em> keyspace_hits keyspace_misses</p>
</li>
<li><p>读取一个键之后，服务器会更新键的 LRU 时间，这个值可以用于计算键的闲置时间，使用 OBJECT idletime 命令可以查看键的闲置时间。</p>
</li>
<li><p>如果服务器在读取一个键的时候发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。</p>
</li>
<li><p>如果有客户端使用 <em>WATCH</em> 命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过了</p>
</li>
<li><p>服务器每次修改一个键之后，都会对脏键计数器的值增 1， 这个计数器会触发服务器的持久化以及复制操作。</p>
</li>
<li><p>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送响应的数据库通知。</p>
</li>
</ul>
<h1 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h1><p>通过 <em>EXPIRE</em> 命令或者 <em>PEXPIRE</em> 命令，客户端可以以秒或者毫秒的精度为数据库中的某个键设置生存时间，在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为 0 的键</p>
<p>通过 <em>EXPIREAT</em> 命令或者 <em>PEXPIREAT</em> 命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（一个 UNIX 时间戳），当键的过期时间来临时，服务器就会自动从数据库中删除这个键。</p>
<p><em>TTL</em> 命令和 <em>PTTL</em> 命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间。</p>
<h2 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h2><ul>
<li><p><code>EXPIRE &lt;key&gt; &lt;ttl&gt;</code> ：将键 key 的生存时间设置为 ttl 秒。</p>
</li>
<li><p><code>PEXPIRE &lt;key&gt; &lt;ttl&gt;</code>：将键 key 的生存时间设置为 ttl 毫秒。</p>
</li>
<li><p><code>EXPIREAT &lt;key&gt; &lt;timestamp&gt;</code>：将键 key 的过期时间设置为 timestamp 所指定的秒数时间戳。</p>
</li>
<li><p><code>PEXPIREAT &lt;key&gt; &lt;timestamp&gt;</code>：将键 key 的过期时间设置为 timestamp 所指定的毫秒数时间戳。</p>
</li>
</ul>
<p>最终，<em>EXPIRE, PEXPIRE, EXPIREAT</em> 三个命令都会转换成 <em>PEXPIREAT</em> 命令来执行。</p>
<h2 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h2><p>redisDb 结构的 expires 字典保存了数据库中所有键的过期时间，称之为过期字典。</p>
<ul>
<li>过期字典的键是一个指针，指向键空间中某个键对象。</li>
<li>过期字典的值是一个 long long 类型的整数，保存了键所指向的数据库键的过期时间（一个毫秒精度的 UNIX 时间戳）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>当客户端执行 <em>PEXPIREAT</em> 命令为一个数据库键设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。</p>
<h2 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h2><p><em>PERSIST</em>  命令可以移除一个键的过期时间</p>
<p><em>PERSIST</em>  命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p>
<h2 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h2><p><em>TTL, PTTL</em> 两个命令都是通过计算键的过期时间和当前时间之间的差来实现的。</p>
<h2 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h2><ol>
<li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。</li>
<li>检查当前 UNIX 时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则未过期</li>
</ol>
<h1 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h1><h2 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h2><ul>
<li><p>对内存是友好的：通过使用计时器，定时删除策略可以保证过期的键会尽可能快地被删除，并释放过期键所占用的内存。</p>
</li>
<li><p>对 CPU 时间是最不友好的：过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分 CPU 时间。</p>
</li>
<li><p>创建一个定时器需要用到 Redis 服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为 <em>O(N)</em>， 效率低</p>
</li>
<li><p>要让服务器创建大量的定时器，从而实现定时删除策略，现阶段不现实。</p>
</li>
</ul>
<h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><ul>
<li>对 CPU 时间是友好的：程序只会在取出键时才对键进行过期检查，可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会再删除其他无关的过期建上花费任何 CPU 时间。</li>
<li>对内存不友好：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会被释放。</li>
</ul>
<h2 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h2><ul>
<li>定期删除策略每隔一段时间执行一次删除过期操作，并通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
<li>通过定期删除过期键，有效地减少了因为过期键而带来的内存浪费。</li>
<li>服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</li>
</ul>
<h1 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h1><p>Redis 服务器实际使用的是惰性删除和定期删除两种策略。</p>
<h2 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h2><p>所有读写数据库的 Redis 命令在执行之前都会调用 expireIfNeeded 函数对输入键进行检查：</p>
<ul>
<li>如果输入键已经过期，那么 expireIfNeeded  函数键输入键从数据库中删除。</li>
<li>如果输入键未过期，那么 expireIfNeeded 不做动作。</li>
</ul>
<h2 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h2><p>每当 Redis 的服务器周期性操作 redis.c/serverCron 函数执行时，activeExpireCycle 函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的 expire 字典中随机检查一部分键的过期时间，并删除其中的过期键。</p>
<h1 id="AOF、RDB-和复制功能对过期键的处理"><a href="#AOF、RDB-和复制功能对过期键的处理" class="headerlink" title="AOF、RDB 和复制功能对过期键的处理"></a>AOF、RDB 和复制功能对过期键的处理</h1><h2 id="生成-RDB-文件"><a href="#生成-RDB-文件" class="headerlink" title="生成 RDB 文件"></a>生成 RDB 文件</h2><p>在执行 SAVE 命令或者 BGSAVE 命令创建一个新的 RDB 文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的 RDB 文件中。</p>
<h2 id="载入-RDB-文件"><a href="#载入-RDB-文件" class="headerlink" title="载入 RDB 文件"></a>载入 RDB 文件</h2><p>在启动 Redis 服务器时，如果服务器开启了 RDB 功能，那么服务器将对 RDB 文件进行载入：</p>
<ul>
<li>如果服务器以主服务器模式运行，那么在载入 RDB 文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入 RDB 文件的主服务器不会造成影响。</li>
<li>从服务器则会载入所有的键。不过，因为主服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入 RDB 文件的从服务器也不会造成影响。</li>
</ul>
<h2 id="AOF-文件写入"><a href="#AOF-文件写入" class="headerlink" title="AOF 文件写入"></a>AOF 文件写入</h2><p>当服务器以 AOF 持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么 AOF 文件不会因为这个过期键而产生任何影响。</p>
<p>当过期键被惰性删除或者定期删除后，程序会向 AOF 文件 append 一条 DEL 命令，来显示地记录改键已被删除。</p>
<blockquote>
<p>GET message</p>
<ul>
<li>如果 message 键已经过期，服务器将执行<ol>
<li>从数据库中删除 message 键。</li>
<li>追加一条 DEL message 命令到 AOF 文件。</li>
<li>向执行 GET 命令的客户端返回空回复。</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><p>执行 AOF 重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的 AOF 文件中。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>当服务器运行在复制模式之下时，从服务器的过期键删除动作由主服务器控制：</p>
<ul>
<li>从服务器在删除一个过期键之后，会显示地向所有从服务器发送一个 DEL 命令，告知从服务器删除这个过期键。</li>
<li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将其删除，而是继续像处理未过期的键一样来处理过期键。（会返回过期键的值）</li>
<li>从服务器只有在接到主服务器发来的 DEL 命令之后，才会删除过期键。</li>
</ul>
<p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器的一致性。同时当一个过期键仍然存在于主服务器的数据库中，这个过期键在从服务器的复制品也会继续存在。</p>
<h1 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h1><p>通过让客户端订阅给定的频道或者模式，来获知数据库中的键的变化，以及数据库中命令的执行情况。</p>
<p>可以关注“某个键执行了什么命令”（键空间通知）或者关注“某个命令被什么键执行了”（键事件通知）</p>
<h2 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">notify.c/notifyKeyspaceEvent 函数实现的：</span><br><span class="line"></span><br><span class="line"><span class="comment">// @param: type: 当前想要发送的通知的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @param: event: 事件的名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @param: keys: 产生事件的键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @param: dbid: 产生事件的数据库号码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, rboj *key, <span class="keyword">int</span> dbid)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="发送通知的实现"><a href="#发送通知的实现" class="headerlink" title="发送通知的实现"></a>发送通知的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(type, event, key, dbid)</span>:</span></span><br><span class="line">    <span class="comment"># 如果给定的通知不是服务器允许的通知</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span>(server.notify_keyspace_events &amp; type):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 发送键空间通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYSPACE:</span><br><span class="line">        <span class="comment"># 将通知发送给频道 __keyspace@&lt;dbid&gt;__:&lt;key&gt;</span></span><br><span class="line">        <span class="comment"># 内容为键所发生的事件 &lt;event&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">"_keyspace@&#123;dbid&#125;__:&#123;key&#125;"</span>.format(dbid=dbid, key=key)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, event)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 发送键事件通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYEVENT:</span><br><span class="line">        <span class="comment"># 将通知发送给频道 __keyspace@&lt;dbid&gt;__:&lt;event&gt;</span></span><br><span class="line">        <span class="comment"># 内容为发生事件的键 &lt;key&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">"_keyevent@&#123;dbid&#125;__:&#123;key&#125;"</span>.format(dbid=dbid, key=key)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, key)</span><br></pre></td></tr></table></figure>



<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>Redis 服务器的所有数据库都保存在 redisServer.db 数组中，而数据库的数量则由 redisServer.dbnum 属性保存。</li>
<li>客户端通过修改目标数据库指针，让它指向的 redisServer.db 数组中的不同元素来切换不同的数据库。</li>
<li>数据库主要由 dict 和 expires 两个字典构成，其中 dict 字典负责保存键值对，expires 字典则负责保存键的过期时间。</li>
<li>因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。</li>
<li>数据库的键总是一个字符串对象，值可以是任意一种 Redis 对象类型，包括 字符串对象、哈希对象、列表对象、集合对象、有序集合对象，分别对应 字符串键、哈希键、列表键、集合键、有序集合建。</li>
<li>expires 字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的 UNIX 的时间戳。</li>
<li>Redis 使用惰性删除和定期删除两种策略来删除过期键</li>
<li>执行 <em>SAVE</em> 命令或者 <em>BGSAVE</em> 命令所产生的新 RDB 文件不会包含已经过期的键。</li>
<li>执行 <em>BGREWRITEAOF</em> 命令所产生的重写 AOF 文件不会包含已经过期的键。</li>
<li>当一个过期键被删除之后，服务器会追加一条 <em>DEL</em> 命令到现有的 AOF 文件的末尾，显示删除过期键。</li>
<li>从服务器即使发现过期键也不会自作主张的删除它，而是等待主节点的 <em>DEL</em> 命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li>
<li>当 Redis 命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/25/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/25/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第一部分:数据结构与对象:第八章:对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-25 09:33:18" itemprop="dateCreated datePublished" datetime="2020-05-25T09:33:18+08:00">2020-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-26 10:57:36" itemprop="dateModified" datetime="2020-05-26T10:57:36+08:00">2020-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Redis 没有直接使用数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统。这个系统包含了字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种。</p>
<ul>
<li>Redis 可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。</li>
<li>可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</li>
</ul>
<h1 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h1><p>Redis 中的每个对象都由一个 RedisObject 结构表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>



<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Redis 数据库保存的键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象的其中一种。</p>
<h2 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h2><p>通过 encoding 属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了 Redis 的灵活性和效率，因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。</p>
<ul>
<li>列表对象包含的元素比较少时，Redis 使用压缩列表作为列表对象的底层实现：<ul>
<li>相对于双端链表，压缩列表更节约内存，并且元素数量较少的时候，在内存中以连续块方式保存的压缩列表比起双端链表可以更快的被载入到缓存中；</li>
<li>随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层的实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面。</li>
</ul>
</li>
</ul>
<h1 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h1><p>字符串对象的编码可以是 int, raw 或者 embstr</p>
<ul>
<li>如果一个字符串保存的是整数值，并且这个整数值可以用 long 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面(将 void* 转换成 long)，并将字符串对象的编码设置为 int.</li>
<li>如果一个字符串保存的是一个字符串值，并且这个字符串值的长度大于 32 字节，那么字符串对象将使用一个 SDS 来保存这个字符串值，并将对象的编码设置为 raw.</li>
<li>如果一个字符串保存的是一个字符串值，并且这个字符串值的长度小于等于 32 字节，那么字符串对象将使用一个 embstr 编码的方式来保存这个字符串值。<ul>
<li>embstr 编码是专门用于保存短字符串的一种优化编码方式，这种编码和 raw 编码一样，都使用 RedisObject 结构和 sdshdr 结构来表示字符串对象，但 raw 编码会调用两次内存分配来分别创建 redisObject 结构和 sdshdr 结构，而 embstr 编码则通过调用一次内存分配函数来分配一块空间，空间中依次包含 redisObject 和 sdshdr 两个结构。</li>
<li>embstr 编码的字符串对象来保存短字符串值的好处：<ol>
<li>embstr 编码将创建字符串对象所需的内存分配次数从 raw 的两次降低为 1 次。</li>
<li>释放 embstr 编码的字符串对象只需要调用一次内存释放函数，而释放 raw 编码的字符串对象需要调用两次内存释放函数。</li>
<li>因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h2><ul>
<li>embstr 编码的字符串对象是只读的</li>
<li>对 int, embstr 编码的字符串修改之后，对象的编码会变为 raw</li>
</ul>
<h2 id="字符串命令的实现"><a href="#字符串命令的实现" class="headerlink" title="字符串命令的实现"></a>字符串命令的实现</h2><p>编码转换到合适的类型然后操作</p>
<h1 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h1><p>列表对象的编码可以是 ziplist 或者 linkedlist.</p>
<h2 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h2><p>当列表对象可以同时满足以下两个条件时，列表对象使用 ziplist 编码：</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节；list-max-ziplist-value</li>
<li>列表对象保存的元素的数量小于 512 个；list-max-ziplist-entries</li>
</ol>
<h2 id="列表命令的实现"><a href="#列表命令的实现" class="headerlink" title="列表命令的实现"></a>列表命令的实现</h2><h1 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h1><p>哈希对象的编码可以是 ziplist 或者 hashtable</p>
<p>ziplist 编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入都哈希对象时，程序会将先保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。</p>
<p>hashtable 编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li><p>字典的每个键都是一个字符串对象，对象中保存了键值对的键</p>
</li>
<li><p>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</p>
</li>
</ul>
<h2 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h2><p>当哈希对象可以同时满足以下两个条件时，列表对象使用 ziplist 编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；hash-max-ziplist-value</li>
<li>哈希对象保存的键值对数量小于 512 个；hash-max-ziplist-entries</li>
</ol>
<h1 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h1><p>集合对象的编码可以是 intset 或者 hashtable。</p>
<h2 id="编码的转换-1"><a href="#编码的转换-1" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>当集合对象可以同时满足以下两个条件时，对象使用 intset 编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数值。</li>
<li>集合对象保存的元素数量不超过512个。set-max-intset-entries</li>
</ol>
<h1 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h1><p>有序集合对象的编码可以是 ziplist 或者 skiplist。</p>
<p>ziplist 编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。</p>
<p>zset 结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的 Object 属性保存了元素的成员，而跳跃表节点的 score 属性则保存了元素的分值。</p>
<p>zset 结构中的 dict 字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，程序可以用 <em>O(1)</em> 复杂度查找给定成员的分值。</p>
<p>跳跃表和字典都会通过指针来共享相同元素的成员和分值，所以不会产生重复成员或者分值，不会浪费额外的内存。</p>
<h2 id="编码的转换-2"><a href="#编码的转换-2" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>当有序集合对象可以同时满足以下两个条件时，对象使用 ziplist 编码：</p>
<ol>
<li>有序集合保存的元素数量小于 128 个。zset-max-ziplist-entries</li>
<li>有序集合保存的所有元素成员的长度都小于 64 字节；zset-max-ziplist-value</li>
</ol>
<h1 id="类型检查和命令多态"><a href="#类型检查和命令多态" class="headerlink" title="类型检查和命令多态"></a>类型检查和命令多态</h1><p>Redis 中用于操作键的命令基本上可以分为两种类型：</p>
<ol>
<li>可以对任何类型的键执行：<em>DEL, EXPIRE, RENAME, TYPE, OBJECT</em> 等</li>
<li>只能对特定类型的键执行：<ul>
<li><em>SET, GET, APPEND, STRLEN</em> 等命令只能对字符串键执行；</li>
<li><em>HDEL, HSET, HGET, HLEN</em> 等命令只能对哈希键执行；</li>
<li><em>RPUSH, LPOP, LINSERT, LLEN</em> 等命令只能对列表键执行；</li>
<li><em>SADD, SPOP, SINTER, SCARD</em> 等命令只能对集合键执行；</li>
<li><em>ZADD, ZCARD, ZRANK, ZSCORE</em> 等命令只能对有序集合键执行；</li>
</ul>
</li>
</ol>
<h2 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h2><p>类型特定命令的所进行的类型检查是通过 redisObject 结构的 type 属性来实现的：</p>
<ol>
<li>在执行一个类型特定的命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是，服务器就对键执行指定的命令。</li>
<li>否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。</li>
</ol>
<h2 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h2><p>Redis 除了会根据值对象的类型来判断键是否能够执行指定的命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p>
<h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>通过引用计数器来判断是否回收对象。</p>
<h1 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h1><p>Redis 中，让多个键共享同一个值对象需要执行以下两个步骤：</p>
<ol>
<li>将数据库键的值指针指向一个现有的对象。</li>
<li>将被共享的值对象的引用计数器增一。</li>
</ol>
<p>Redis 只对包含整数值的字符串对象进行共享，因为别的对象共享需要花费大量的CPU时间去检查他们是否真的相同。</p>
<h1 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录了对象最后一次被命令程序访问的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>



<p>对象的空转时长 <em>OBJECT IDLETIME</em> 命令打印出来</p>
<p>如果服务器打开了 maxmemory 选项，并且服务器用于回收内存的算法为 volatile-lru 或者 allkeys-lru，那么当服务器占用的内存数超过了 maxmemory 选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>Redis 数据库中的每个键值对的键和值都是一个对象。</li>
<li>Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。</li>
<li>Redis 的对象系统带有引用计数实现的内存回收机制，当一个对象不再使用时，该对象所占用的内存就会被自动释放。</li>
<li>Redis 会共享值为 0 ~ 9999 的字符串对象。</li>
<li>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/24/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第一部分:数据结构与对象:第七章:压缩列表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-24 21:15:37" itemprop="dateCreated datePublished" datetime="2020-05-24T21:15:37+08:00">2020-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-26 09:21:32" itemprop="dateModified" datetime="2020-05-26T09:21:32+08:00">2020-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个列表键(哈希键)只包含少量列表项，并且每个列表项要么就是小数值，要么就是长度比较短的字符串，Redis 就会使用压缩列表来作为底层实现。</p>
<h2 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h2><ul>
<li>zlbytes ：记录整个压缩列表占用的字节数：在对压缩列表进行内存重分配，或者计算 zlend 的位置时使用。</li>
<li>zltail：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</li>
<li>zllen：记录了压缩列表包含的节点数量。2字节，如果长度超过65535需要遍历一遍。</li>
<li>entryX：压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</li>
<li>zlend：特殊值 0xFF ，用于标记压缩列表的末端。</li>
</ul>
<h2 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h2><p>节点可以保存一个字节数组或者一个整数值</p>
<ul>
<li>previous_entry_length：保存前一个节点的字节长度<ul>
<li>如果前一个节点的长度小于 254 字节，previous_entry_length 属性长度为 1 字节，前一个节点的长度就保存在这一个字节里面。</li>
<li>如果前一个节点的长度大于等于 254 字节，那么 previous_entry_length 属性的长度为 5 字节，第一个字节会被设置为 0xFE ，之后的四个字节保存前一节点的长度。</li>
<li>通过 previous_entry_length 可以实现压缩列表的反向遍历。</li>
</ul>
</li>
<li>encoding：记录了节点 content 属性所保存数据的类型和长度<ul>
<li>一字节、两字节或者五字节长，值的最高位为 00， 01 或者 10 的是字节数组编码：这种编码表示节点的 content 属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录。</li>
<li>一字节长，值的最高位以 11 开头的是整数编码：种编码表示节点的 content 属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录。</li>
</ul>
</li>
<li>content：负责保存节点的值，节点的值可以是一个字节数组或者整数，值的类型和长度由节点的 encoding 属性决定。</li>
</ul>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>因为 previous_entry_length 的长度不确定，在特殊情况下会导致连锁更新。</p>
<p>连锁更新在最坏的情况下需要对压缩列表执行 N 次空间重分配操作，而每次空间重分配的最坏复杂度为 <em>O(N)</em>, 所以连锁更新的最坏复杂度为 <em>O(N²)</em>. （最坏情况出现几率小）</p>
<h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li>
<li>压缩列表被用作列表键和哈希键的底层实现之一。</li>
<li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li>
<li>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率不高。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/24/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%AE%A1%E7%90%86/1%202%203%20%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%AE%A1%E7%90%86/1%202%203%20%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">软件过程与管理/1 2 3 软件过程与管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-24 19:46:38" itemprop="dateCreated datePublished" datetime="2020-05-24T19:46:38+08:00">2020-05-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>软件工程的三要素：过程、方法、工具</p>
<p>软件过程将技术和管理结合起来，使得软件能够被合理地、及时地开发出来。</p>
<p>通用框架活动：沟通、策划、建模、构建、部署</p>
<p>构建活动的过程模式属<strong>步骤模式</strong>类型</p>
<p><strong>惯例过程模型</strong>是包括活动、动作、任务、里程碑和工作产品的明确的集合，旨在开发高质量的软件。</p>
<p>惯例过程模型的<strong>优点</strong>：为活动提供稳定、控制和有组织性，以有序和项目的一致性为首要目标。为软件工程工作增加了大量有用的结构化设计，为项目团队提供了有效的路线图。</p>
<p>惯例过程模型的<strong>不足</strong>：使用过程中需要调整才能适应不同项目需要。缺乏灵活性、应对变更能力不强。</p>
<p><strong>瀑布模型</strong>从沟通开始，通过策划、建模、构建和部署的过程，最终提供完整的软件并提供持续的技术支持,又称为经典生命周期模型。</p>
<p>瀑布模型的<strong>特点</strong>：阶段间具有 顺序性和 依赖性；推迟程序的物理 实现；质量保证：− 每个阶段必须完成规定的文档− 每个阶段结束前完成<strong>文档</strong>审查；瀑布模型是一种严格线性的、按阶段顺序的、逐步细化的过程模型。</p>
<p>瀑布模型的<strong>优点</strong>：有利于人员的组织与管理；有利于软件开发方法和工具的研究；可以提高大型软件项目开发的质量和效率</p>
<p>瀑布模型的<strong>缺点</strong>：不适应需求经常发生变更的环境，难以解决需求不明确的问题；用户在过程终端才能看到产品，反馈时间长，风险大；易于陷入“阻塞状态”；；强调一次性交付完整系统，导致开发周期长；缺乏灵活性，可操作性差</p>
<p>瀑布模型的<strong>适用范围</strong>：需求明确、全面，开发过程中没有或很少变更的项目；开发人员熟悉项目产品的目标、环境、应用领域的低风险项目；开发过程很少或不需要用户参与的项目；用户使用环境稳定且能够容忍长开发周期的项目</p>
<p><strong>增量过程模型</strong>是一种以增量的形式生产软件产品的过程模型，适用于以下场景：初始的软件需求有明确的定义，但是，受时间或资源的限制，受时间或资源的限制，不宜单纯运用线性模型；迫切需要 迅速提供一套功能有限的产品，允许在后续版本中细化和扩充。</p>
<p><strong>增量模型</strong>以迭代的方式运用瀑布模型。每一个增量都提交一个可以操作的产品。</p>
<p>增量模型的<strong>特点</strong>：融合 瀑布模型的基本成分和 迭代的特征；以功能递增的方式进行软件开发；能较快地产生可操作的系统；在每一步递增中，均发布一个可操作的 增量版本，把用户/开发者的经验结合到不断求精的产品中。</p>
<p>增量模型<strong>优点</strong>：人员分配灵活，刚开始不用投入大量人力资源；规避技术风险；在短时间内提交核心产品，对用户起到镇静剂的作用，具有一定市场</p>
<p>增量模型<strong>缺点</strong>：并行开发构建，有可能遇到不能集成的风险，对软件体系结构要求高；容易退化为“边做边改”模型，导致对软件过程的控制失去整体性。</p>
<p>增量模型的<strong>适用范围</strong>：已有产品升级项目或新版本的开发项目；需求明确并对使用开始时间有严格要求的项目</p>
<p><strong>演化过程模型</strong>利用迭代的思想方法，使软件工程师 渐进地开发逐步完善的软件版本。演化过程模型主要适用于在项目开发初期项目需求不明确，把握不充分的项目。</p>
<p><strong>原型模型针</strong>对需求不明确的情况通过迅速构建可以运行的软件原型 ，以便理解和澄清问题，使开发人员与用户达成共识，最终在确定的需求基础上开发出满意的产品。原型模型是用户驱动的。</p>
<p>原型的分类：<strong>探索型原型</strong>：用于 需求分析阶段，目的是要澄清用户的需求，确定所期望的特性，并探索各<br>种方案的可行性。<strong>实验型原型</strong>：用于 设计阶段，考核实现方案是否合适。<strong>演化型原型</strong>：用于及早向用户提交一个原型系统，在得到用户的认可后不断扩充演变为最终的产品。</p>
<p>原型的使用策略：<strong>抛弃策略</strong>：原型仅用于开发过程的某个阶段，该阶段结束后，原型随之作废。<strong>附加策略</strong>：原型用于开发的全过程，由最基本的核心开始，逐步增加新的功能和新的需求，最后发展为用户满意的最终系统。</p>
<p>原型模型的<strong>优点</strong>：克服 瀑布模型的缺点，减少由于软件需求不明确带来的开发风险。<br>原型模型的<strong>缺点</strong>：容易引起用户误解。对用户参与程度要求高。缺少项目标准，用户可能不断提出新要求，原型<br>迭代的周期很难控制。额外的花费：研究结果表明构造一个原型可能需要10%额外花费。为了尽快实现原型，采用了 不合适的技术，运行效率可能会受影响。</p>
<p>原型模型的<strong>适用范围</strong>：适合于那些不能确切定义需求的中小型项目；用户未能详细定义输入、处理、输出；开发人员对算法效率、OS、人机交互的形式不确定。</p>
<p><strong>螺旋模型</strong>，综合了原型模型的迭代特征原型模型的迭代特征和 瀑布模型的系统性和可控制性的特点， 增加风险分析，是以风险为导向的生命期模型。采用循环方式逐步加深系统定义和实现的深度，同时降低风险。确定一系列里程碑，确保项目干系人都支持可行的和令人满意的解决方案。</p>
<p>螺旋模型<strong>特点</strong>：把软件开发过程组成为一个 逐步细化的螺旋周期序列，每经历一个周期，系统就得到进一步的细化和完善；紧密围绕开发中的风险问题，用 风险分析推动软件设计向深一层扩展、求精；强调 持续地判断、确定和修改用户任务目标，并按成本效益来分析候选的软件产品性质对任务目标的贡献；可结合采用 多种软件开发方法，但究竟结合哪一种方法仍由风险分析来决定。</p>
<p>螺旋模型的<strong>优势</strong>：设计上具有灵活性，可以在产品的各个阶段进行变更；以小的分段来构建大型系统，易于成本计算；客户参与各阶段的开发，保证项目不偏离正确方向和项目的可控性；引入风险分析，随着迭代的增加风险程度随之降低。</p>
<p>螺旋模型的<strong>不足</strong>：对风险评估技术和经验有较高要求，评估不当会造成重大损失；过多的迭代次数会延长交付时间，增加开发成本螺旋模型只适合于那些不能确切定义需求的大型软件项目的开发</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/24/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第一部分:数据结构与对象:第六章:整数集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-24 12:52:42" itemprop="dateCreated datePublished" datetime="2020-05-24T12:52:42+08:00">2020-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-26 09:11:00" itemprop="dateModified" datetime="2020-05-26T09:11:00+08:00">2020-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>整数集合( intset )是集合键的底层实现之一，当一个集合中只包含整数值元素，并且这个集合的元素数量不多时，Redis就会只用整数集合来作为集合键的底层实现。</p>
<h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint_32_t</span> enconding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint_32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>



<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>添加到整数集合中的新元素（<em>O(N)</em>）的类型比整数集合现有所有的元素的类型都要长时，整数集合就需要先进行升级。</p>
<p>升级的步骤：</p>
<ol>
<li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li>
<li>将底层数组现有的所有元素转换成与新元素相同的数据类型，并将类型转换后的元素放置到正确的位置上，放置的过程中，维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<h2 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h2><ul>
<li>提升灵活性：不用担心类型不匹配</li>
<li>节约内存：相对于直接用 int64_t 类型的数组作为整数集合的底层实现。</li>
</ul>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>不支持降级</p>
<h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>整数集合是集合键的底层实现之一。</li>
<li>整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，有需要时候，程序会根据新添加元素的类型，改变这个数组的类型。</li>
<li>升级操作为整数数组集合带来了操作上的灵活性，并且尽可能的节约了内存。</li>
<li>整数集合只支持升级操作，不支持降级操作。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/24/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%B7%B3%E8%B7%83%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%B7%B3%E8%B7%83%E8%A1%A8/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第一部分:数据结构与对象:第五章:跳跃表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-24 08:54:46 / 修改时间：12:52:44" itemprop="dateCreated datePublished" datetime="2020-05-24T08:54:46+08:00">2020-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><p>跳跃表是一个种有序数据结构，平均 <em>O(logN)</em> 复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<p>Redis 在有序集合键和集群节点中用作内部数据结构中使用跳跃表。</p>
<h2 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h2><h3 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplitNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backword</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<ul>
<li>level ：程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。每次创建一个新的跳跃表节点的时候，程序根据幂次定律(power law, 越大的数出现的概率越小) 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小，这个大小就是层的“高度”。</li>
<li>前进指针：level[i].forward 属性用于从表头向表尾方向访问节点。</li>
<li>跨度：level[i].span 用于记录两个节点之间的距离。</li>
<li>后退指针：用于从表尾向表头方向访问节点，每个节点之后一个后退指针。每次只能后退至前一个节点。</li>
<li>分值和成员：跳跃表中所有节点都按分值从小到大排序，成员对象指向一个 SDS.</li>
</ul>
<h3 id="跳跃表-1"><a href="#跳跃表-1" class="headerlink" title="跳跃表"></a>跳跃表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<ul>
<li>header: 指向跳跃表的表头节点</li>
<li>tail:</li>
<li>level：记录目前跳跃表内，层数最大的那个节点的层数(不包括表头节点)</li>
<li>length：记录跳跃表的长度，也是跳跃表目前包含节点的数量。</li>
</ul>
<p>扩展阅读：<a href="https://juejin.im/post/57fa935b0e3dd90057c50fbc" target="_blank" rel="noopener">Redis 为什么用跳表而不用平衡树？</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/21/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%97%E5%85%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/21/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%97%E5%85%B8/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第一部分:数据结构与对象:第四章:字典</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-21 12:43:56" itemprop="dateCreated datePublished" datetime="2020-05-21T12:43:56+08:00">2020-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-22 13:26:56" itemprop="dateModified" datetime="2020-05-22T13:26:56+08:00">2020-05-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<h3 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">// ht[1] 只会在对 ht[0] 哈希表进行 rehash 使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时, 值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> trehashidx; <span class="comment">// rehashing not in progress if rehashidx == -1</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<ul>
<li>type 属性和 privdata 属性是针对不同类型的键值对，为创建多态字典而设置的。</li>
<li>type 属性是一个指向 dictType 结构的指针，每个 dictType 结构保存了一簇用于操作特定类型键值对的函数，Redis 会为用途不同的字典设置不同类型特定函数。</li>
<li>privdata 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>



<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>当要将一个新键值对添加到字典里时，需要先根据键值对的键计算出哈希值和索引值，然后根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line">hash = dict -&gt; type -&gt; hashFunction(key);	// MurmurHash算法</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="comment"># 根据情况不同，ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line">index = hash &amp; dict -&gt; ht[x].sizemask;</span><br></pre></td></tr></table></figure>



<h2 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h2><p>链地址法</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>rehash 的步骤：</p>
<ol>
<li><p>为字典的 ht[1] 哈希表分配空间</p>
<ul>
<li>如果执行的是扩展操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2 的 n 次方。</li>
<li>如果执行的是收缩操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2 的 n 次方。</li>
</ul>
</li>
<li><p>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面</p>
</li>
<li><p>rehash 完成后，释放 ht[0], 将 ht[1] 设置为 ht[0], 并在 ht[1] 新建一个空白哈希表，为下一次 rehash 做准备</p>
</li>
</ol>
<h3 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h3><ol>
<li>服务器目前没有在执行 <em>BGSAVE</em> 命令或者 <em>BGREWRITEAOF</em> 命令，并且哈希表的负载因子大于等于1</li>
<li>服务器目前正在执行 <em>BGSAVE</em> 命令或者  <em>BGREWRITEAOF</em> 命令，并且哈希表的负载因子大于等于5</li>
</ol>
<p>因为在执行 <em>BGSAVE</em> 命令或者  <em>BGREWRITEAOF</em> 命令的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制(copy-on-write)技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能的避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。</p>
<p>哈希表的负载因子小于 0.1 时，会自动执行 收缩操作。</p>
<h2 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式  rehash"></a>渐进式  rehash</h2><p>哈希表渐进式 rehash 的步骤：</p>
<ol>
<li>为字典的 ht[1] 哈希表分配空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 rehashidx ，并将它的值设置为 0, 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行制定的操作以外，还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，当 rehash 工作完成之后，程序将 rehashidx 属性的值增一。</li>
<li>随着字典操作的不断执行，最终在某个时间点上，ht[0] 的所有键值对都会被 rehash 到 ht[1]，这时程序将 rehashidx 属性的值设置为 -1， 表示 rehash 操作完成。</li>
</ol>
<p>因为在渐进式 rehash 的过程中，字典会同时使用 ht[0] 和 ht[1] 两个哈希表，字典的 delete，find，update 等操作会在两个哈希表上查找，先在 ht[0] 中找，找不到再去 ht[1] 中找。</p>
<p>insert 操作，只会插入到 ht[1] 中。</p>
<h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>字典被广泛用于实现 Redis 的各种功能，其中包括数据库和哈希键</li>
<li>Redis 中的字典使用哈希表作为底层实现，每个字典中带有两个哈希表，一个平时使用，另一个仅在 rehash 时使用。</li>
<li>当字典被用作数据库的底层实现，或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值</li>
<li>哈希表使用链地址法解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。</li>
<li>在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面，并且这个 rehash 操作过程不是一次性地完成的，而是渐进式的完成的。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/21/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/21/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第一部分:数据结构与对象:第二章:简单动态字符串</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-21 11:27:25 / 修改时间：11:26:57" itemprop="dateCreated datePublished" datetime="2020-05-21T11:27:25+08:00">2020-05-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h1><h2 id="SDS-的定义"><a href="#SDS-的定义" class="headerlink" title="SDS 的定义"></a>SDS 的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">// 记录 buf 数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于 SDS 所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录 buf 数组中未使用的字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span>[] buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="SDS-与-C-字符串的区别"><a href="#SDS-与-C-字符串的区别" class="headerlink" title="SDS 与 C 字符串的区别"></a>SDS 与 C 字符串的区别</h2><h3 id="常数复杂度获取字符串的长度"><a href="#常数复杂度获取字符串的长度" class="headerlink" title="常数复杂度获取字符串的长度"></a>常数复杂度获取字符串的长度</h3><ul>
<li><p>C 字符串不记录自身的长度信息</p>
</li>
<li><p>SDS 在 len 属性中记录了 SDS 本身的长度。</p>
</li>
</ul>
<h3 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h3><p>​        <code>char *(char *dest, const char *src)</code></p>
<ul>
<li><p>因为 C 字符串不记录自身的长度，所以 strcat 假定用户在执行这个函数的时候，已经为 dest 分配了足够的内存。</p>
</li>
<li><p>SDS 的空间分配策略完全杜绝了发生缓冲区溢出的可能性。</p>
</li>
</ul>
<h3 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h3><ul>
<li>因为 C 字符串并不记录自身的长度，所以对于一个包含了 N  个字符的 C 字符串来说，这个 C 字符串的底层实现<strong>总是</strong>一个 N + 1 个字符长的数组。</li>
</ul>
<ul>
<li><p>SDS 通过未使用空间解除了字符串长度和底层数组长度之间的关联。free</p>
</li>
<li><p>通过未使用空间，SDS 实现了空间预分配和惰性空间释放两种优化策略。</p>
<ul>
<li><p><strong>空间预分配</strong></p>
<p>当 SDS 的 API 对一个 SDS 进行修改，并且需要对 SDS 进行空间扩展的时候，程序不仅会为 SDS 分配修改所必须要的空间，还会为 SDS 分配额外的未使用空间。</p>
<ol>
<li>对 SDS 修改后，SDS 的长度(len) 将小于 1 MB，那么程序就会分配 len 属性相同大小的未使用空间</li>
<li>大于 1MB，每次多分配 1MB 的未使用空间</li>
</ol>
<p>在扩展 SDS 空间之前， SDS API 会先检查未使用的空间是否足够。不够才会执行内存分配</p>
</li>
<li><p><strong>惰性空间释放</strong></p>
<p>用于优化字符串的缩短操作：当 SDS API 需要缩短 SDS 保存的字符串时，程序并不立即使用内存重分配来回收缩短多出来的字节，而是使用 free 属性将这些字节数量记录起来，并等待将来使用。</p>
</li>
</ul>
</li>
</ul>
<h3 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h3><ul>
<li>C 语言字符串的字符必须符合某种编码(ASCII, UTF-8)，并且除了字符串的末尾之外，字符串里面不能出现空字符，否则最先被程序读入的空字符将被误认为是字符串的结尾。所以 C 字符串只能保存文本数据，不能保存图片、音频、视频、压缩文件这样的二进制数据。</li>
</ul>
<h3 id="兼容部分-C-字符串函数"><a href="#兼容部分-C-字符串函数" class="headerlink" title="兼容部分 C 字符串函数"></a>兼容部分 C 字符串函数</h3><ul>
<li>SDS 可以重用 &lt;String.h&gt; 函数库</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th align="left">C 字符串</th>
<th align="center">SDS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取字符串长度的时间复杂度为 <em>O(N)</em></td>
<td align="center">获取字符串长度的时间复杂度为 <em>O(1)</em></td>
</tr>
<tr>
<td align="left">API 是不安全的，可能会造成缓冲区溢出</td>
<td align="center">API 是安全的，杜绝缓冲区溢出</td>
</tr>
<tr>
<td align="left">修改字符串长度 N 次必然会执行 N 次内存重分配</td>
<td align="center">修改字符串长度 N 次最多会执行 N 次内存重分配</td>
</tr>
<tr>
<td align="left">只能保存文本数据</td>
<td align="center">可以保存文本和二进制数据</td>
</tr>
<tr>
<td align="left">可以使用所有 &lt;string.h&gt; 库中的函数</td>
<td align="center">可以使用一部分&lt;string.h&gt; 库中的函数</td>
</tr>
</tbody></table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/21/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E4%B8%89%E7%AB%A0%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/21/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E4%B8%89%E7%AB%A0%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第一部分:数据结构与对象:第三章:链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-21 11:25:46 / 修改时间：12:43:47" itemprop="dateCreated datePublished" datetime="2020-05-21T11:25:46+08:00">2020-05-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表和链表节点的实现"><a href="#链表和链表节点的实现" class="headerlink" title="链表和链表节点的实现"></a>链表和链表节点的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值复制函数: 用于复制链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">	</span><br><span class="line">   	<span class="comment">// 节点值释放函数: 用于释放链表节点所保存的值</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点值对比函数: 用于链表节点所保存的值是否和另一个值相等</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>



<p>Redis 的链表实现的特性：</p>
<ul>
<li>双端：prev next 指针，获取某一个节点的前置和后驱时间复杂度为 <em>O(1)</em>.</li>
<li>无环：表头节点的 prev 指针和表尾节点的 next 指针为 null. </li>
<li>带头指针和尾指针</li>
<li>带链表长度计数器</li>
<li><strong>多态</strong>： 链表节点使用 void* 指针来保存节点值，并且可以通过 list 结构的 dup, free, match 三个属性为节点值设置类型特定函数，所以链表用户保存各种不同类型的值。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wayne"
      src="/images/808.jpg">
  <p class="site-author-name" itemprop="name">Wayne</p>
  <div class="site-description" itemprop="description">Keep Moving</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:winter98@foxmail.com" title="E-Mail → mailto:winter98@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Wayne_98" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Wayne_98" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wayne</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
