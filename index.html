<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wayne-98.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Keep Moving">
<meta property="og:type" content="website">
<meta property="og:title" content="Wayne">
<meta property="og:url" content="http://wayne-98.github.io/index.html">
<meta property="og:site_name" content="Wayne">
<meta property="og:description" content="Keep Moving">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wayne">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://wayne-98.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wayne</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Wayne" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wayne</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Love Yourz</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/30/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E4%BA%8B%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E4%BA%8B%E4%BB%B6/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第二部分:单机数据的实现:第十二章:事件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-30 17:34:36 / 修改时间：17:35:13" itemprop="dateCreated datePublished" datetime="2020-05-30T17:34:36+08:00">2020-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p>Redis 服务器是一个事件驱动程序。</p>
<ul>
<li>文件事件：Redis 服务器通过套接字与客户端(或者其他 Redis 服务器)进行连接，文件事件是服务器对套接字的抽象。服务器与客户端的通信会产生相应的文件事件，而服务器通过监听并处理这些事件来完成一系列网络通信操作。</li>
<li>时间事件：Redis 服务器中的一些操作(serverCron 函数)需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</li>
</ul>
<h2 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h2><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器（文件事件处理器）：</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答(accept)、读取(read)、写入(write)、关闭(close)等操作时，与操作相对应的文件事件就会产生，这时文件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<h3 id="文件事件处理器的构成"><a href="#文件事件处理器的构成" class="headerlink" title="文件事件处理器的构成"></a>文件事件处理器的构成</h3><p>文件处理器的构成：套接字、I/O 多路复用程序、文件事件分派器以及事件处理器。</p>
<ol>
<li>I/O 多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。</li>
<li>多个事件可能会并发地出现，I/O 多路复用程序会将所有产生的事件的套接字放到一个队列里，通过这个队列，以有序(sequentially)、同步(synchronously)、每次一个套接字的方式向文件事件分派器传送套接字。</li>
<li>文件事件分派器接收 I/O 多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。</li>
</ol>
<h3 id="I-O-多路复用程序的实现"><a href="#I-O-多路复用程序的实现" class="headerlink" title="I/O 多路复用程序的实现"></a>I/O 多路复用程序的实现</h3><p><code>select、epoll、evport、kqueue</code></p>
<h2 id="事件的类型"><a href="#事件的类型" class="headerlink" title="事件的类型"></a>事件的类型</h2><p>ae.h/AE_READABLE(优先级更高)</p>
<p>ae.h/AE_WRITABLE</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h3 id="文件事件的处理器"><a href="#文件事件的处理器" class="headerlink" title="文件事件的处理器"></a>文件事件的处理器</h3><ul>
<li>为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</li>
<li>为了接受客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</li>
<li>为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。</li>
<li>当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。</li>
</ul>
<ol>
<li>连接应答处理器</li>
</ol>
<p>当 Redis 服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的 AE_READABLE 事件关联起来。</p>
<ol start="2">
<li>命令请求处理器</li>
</ol>
<p>当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的 AE_READABLE 事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生 AE_READABLE 事件，引发命令请求处理器执行，并执行相应的套接字读入操作。 </p>
<p>在客户端连接服务器的整个过程中，服务器都会一直为客户端套接字的 AE_READABLE 事件关联命令请求处理器。</p>
<ol start="3">
<li>命令回复处理器</li>
</ol>
<p>当服务器由命令回复需要传送给客户端的时候，服务器会将客户端套接字的 AE_WRITEABLE 事件和命令回复处理器关联起来，当客户端准备好接收服务器传回的命令回复时，就会产生 AE_WRITEABLE 事件，引发命令回复处理器执行，并执行相应的套接字写入操作。</p>
<p>命令回复发送完毕之后，服务器就会解除命令回复处理器与客户端套接字的 AE_WRITEABLE 事件之间的关联。</p>
<hr>
<ul>
<li>一次完整的客户端与服务器连接事件示例</li>
</ul>
<ol>
<li>Redis 服务器正在运作，那个这个服务器的监听套接字的 AE_READABLE 事件应该处于监听状态之下，而该事件所对应的处理器为连接应答处理器。</li>
<li>有一个 Redis 客户端向服务器发起连接，那么监听套接字将产生 AE_READABLE 事件，触发连接应答处理器执行。处理器会对客户端的连接请求进行应答，然后创建客户端套接字，以及客户端状态，并将客户端套接字的 AE_READABLE 事件与命令请求处理器进行关联，使得客户端可以向主服务器发送命令请求。</li>
<li>假设客户端发送一个命令请求，那么客户端套接字将产生 AE_READABLE 事件，引发命令请求处理器执行，处理器读取客户端的命令内容，然后传给相关程序去执行。</li>
<li>执行命令产生相应的命令回复，为了将这些命令回复传送回客户端，服务器会将客户端套接字的 AE_WRITEABLE 事件与命令回复处理器进行关联。当客户端尝试读取命令回复的时候，客户端套接字将产生 AE_WRITEABLE 事件，触发命令回复处理器执行，当命令回复处理器将命令回复全部写入套接字之后，服务器就会解除客户端套接字的 AE_WRITEABLE 事件与命令回复处理器之间的关联。</li>
</ol>
<h2 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h2><ul>
<li>定时事件：让程序在指定的时间之后执行一次。</li>
<li>周期性事件：让一段程序每隔指定时间就执行一次。</li>
</ul>
<ul>
<li>一个时间事件主要由以下三个属性组成：<ul>
<li>id：服务器为时间事件创建的全局唯一 ID。</li>
<li>when：毫秒精度的 UNIX 时间戳，记录了时间事件的到达时间。</li>
<li>timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li>
</ul>
</li>
<li>一个时间事件时定时事件还是周期性事件取决于时间事件处理器的返回值：<ul>
<li>返回 ae.h/AE_NOMORE 则为定时事件：该事件在达到一次之后就会被删除，之后不再到达。</li>
<li>返回一个非 AE_NOMORE 的整数值，则为周期性事件。返回值就是这个周期。</li>
</ul>
</li>
</ul>
<p>目前版本的 Redis 只有周期性事件，没有使用定时事件。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<h3 id="时间事件应用实例：serverCron-函数"><a href="#时间事件应用实例：serverCron-函数" class="headerlink" title="时间事件应用实例：serverCron 函数"></a>时间事件应用实例：serverCron 函数</h3><p>持续运行的 Redis 服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由 redis.c/serverCron 函数负责执行</p>
<ul>
<li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li>
<li>清理数据库中的过期键值对。</li>
<li>关闭和清理连接失效的客户端。</li>
<li>尝试进行 AOF 或 RDB 持久化操作。</li>
<li>如果服务器是主服务器，那么对从服务器进行定期同步。</li>
<li>如果处理集群模式，对集群进行定期同步和连接测试。</li>
</ul>
<h2 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h2><p>待学习</p>
<h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>Redis 服务器是一个事件驱动程序，服务器处理的事件分为时间事件和文件事件两类。</li>
<li>文件处理器是基于 Reactor 模式实现的网络通信程序。</li>
<li>文件事件是对套接字操作的抽象：每次套接字变为可应答(acceptable)、可写入(writable)或者可读(readable)时，相应的文件事件就会产生。</li>
<li>文件事件分为 AE_READABLE 事件和 AE_WRITEABLE 事件两类。</li>
<li>时间事件分为定时事件和周期性事件：定时事件只在指定的时间到达一次，而周期性事件则每隔一段时间到达一次。</li>
<li>文件事件和时间事件之间是合作关系，服务器会轮流处理这两种事件，并且处理事件的过程中也不会进行抢占。</li>
<li>时间事件的实际处理时间通常会比设定的到达时间晚一些。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/30/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0AOF%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0AOF%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第二部分:单机数据的实现:第十一章:AOF持久化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-30 17:33:40 / 修改时间：17:34:25" itemprop="dateCreated datePublished" datetime="2020-05-30T17:33:40+08:00">2020-05-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h1><p>AOF 持久化是通过保存 Redis 服务器所执行的写命令来记录数据库状态的。</p>
<h2 id="AOF-持久化的实现"><a href="#AOF-持久化的实现" class="headerlink" title="AOF 持久化的实现"></a>AOF 持久化的实现</h2><p> AOF 持久化功能的实现可以分为命令追加(append)、文件写入、文件同步(sync)三个步骤。</p>
<h3 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h3><p>当 AOF 持久化功能打开时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//  AOF 缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; redisServer;</span><br></pre></td></tr></table></figure>

<h2 id="AOF-文件的写入与同步"><a href="#AOF-文件的写入与同步" class="headerlink" title="AOF 文件的写入与同步"></a>AOF 文件的写入与同步</h2><p>Redis 的服务器进程就是一个事件循环(loop)，这个循环中的文件事件负责接收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像 serverCron 函数这样需要定时运行的函数。</p>
<p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到 aof_buf 缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用 flushAppendOnlyFile 函数，考虑是否将缓冲区中的内容写入和保存到 AOF 文件中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eventLoop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        processFileEvents()</span><br><span class="line">        processTimeEvents()</span><br><span class="line">        fulshAppendOnlyFile()</span><br></pre></td></tr></table></figure>

<p>fulshAppendOnlyFile 函数的行为由服务器配置的 appendfsync 选项的值来决定</p>
<table>
<thead>
<tr>
<th>appendfsync 选项的值</th>
<th>fulshAppendOnlyFile 函数的行为</th>
</tr>
</thead>
<tbody><tr>
<td>always</td>
<td>将 aof_buf 缓冲区的所有内容写入并同步到 AOF 文件</td>
</tr>
<tr>
<td>everysec(default)</td>
<td>将 aof_buf 缓冲区的所有内容写入到 AOF 文件，间隔超过一秒才会对 AOF 文件进行同步，并且这个同步操作是由一个线程专门负责的。</td>
</tr>
<tr>
<td>no</td>
<td>将 aof_buf 缓冲区中的所有内容写入到 AOF 文件，并不对 AOF 文件进行同步，何时同步由操作系统来决定。</td>
</tr>
</tbody></table>
<ul>
<li>现代操作系统，当用户调用 write 函数，将一些数据写入到磁盘中时，操作系统通常会将写入的数据暂时保存在一个内存缓冲区中，等到缓冲区满了或者超过指定的时限之后，才真正的刷到磁盘中。提高了效率但是带来了数据的安全性问题。</li>
<li>系统提供了 fsync 和 fdatasync 两个同步函数，可以强制让操作系统立即将缓冲区中的数据写入到磁盘中，保证数据的安全性。</li>
</ul>
<h2 id="AOF-文件的载入与数据还原"><a href="#AOF-文件的载入与数据还原" class="headerlink" title="AOF 文件的载入与数据还原"></a>AOF 文件的载入与数据还原</h2><p>Redis 读取 AOF 文件并还原数据库状态的详细步骤：</p>
<ol>
<li>创建一个不带网络连接的伪客户端。</li>
<li>从 AOF 文件中分析并读取一条写命令。</li>
<li>使用伪客户端执行被读出的写命令，直到文件中所有的写命令都被处理完毕。</li>
</ol>
<h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><p>为了解决 AOF 文件体积膨胀的问题，Redis 提供了 AOF 文件重写(rewrite)功能。通过该功能，Redis 服务器可以创建一个新的 AOF 文件来替代现有的 AOF 文件，新旧两个 AOF 所保存的数据库状态相同，但新的 AOF 文件不会包含任何浪费空间的冗余命令。</p>
<h3 id="AOF-文件重写的实现"><a href="#AOF-文件重写的实现" class="headerlink" title="AOF 文件重写的实现"></a>AOF 文件重写的实现</h3><p>新的 AOF 文件是通过读取服务器当前的数据库状态来实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aof_rewrite</span><span class="params">(new_aof_file_name)</span>:</span></span><br><span class="line">    <span class="comment"># 创建新 AOF 文件</span></span><br><span class="line">    f = create_file(new_aof_file_name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历数据库</span></span><br><span class="line">    <span class="keyword">for</span> db <span class="keyword">in</span> redisServer.db:</span><br><span class="line">        <span class="comment"># 忽略空数据库</span></span><br><span class="line">        <span class="keyword">if</span> db.is_empty(): <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 写入 SELECT 命令，指定数据库号码</span></span><br><span class="line">        f.write_command(<span class="string">"SELECT"</span> + db.id)</span><br><span class="line">        <span class="comment"># 遍历数据库中的所有键</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> db:</span><br><span class="line">            <span class="comment"># 忽略已过期的键</span></span><br><span class="line">            <span class="keyword">if</span> key.is_expried(): <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 根据键的类型对键进行重写</span></span><br><span class="line">            <span class="keyword">if</span> key.type == String: rewrite_string(key)</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment"># 如果键带有过期时间，过期时间也需要重写</span></span><br><span class="line">            <span class="keyword">if</span> key.have_expire_time():</span><br><span class="line">                rewrite_expire_time(key)</span><br><span class="line">                </span><br><span class="line">	f.close()</span><br></pre></td></tr></table></figure>



<p>实际中，为了避免在执行命令时造成客户端输入缓冲区的溢出，重写程序在处理列表、哈希表、集合、有序集合这四种可能带有多个元素的键时，会先检查所包含的元素的数量，如果元素的数量超过了 redis.h/REDIS_REWRITE_ITEMS_PER_CMD (default 64)常量的值，那么重写程序将使用多条命令来记录键的值。</p>
<h3 id="AOF-后台重写-BGREWRITEAOF"><a href="#AOF-后台重写-BGREWRITEAOF" class="headerlink" title="AOF 后台重写(BGREWRITEAOF)"></a>AOF 后台重写(BGREWRITEAOF)</h3><ul>
<li>子进程进行 AOF 重写期间，服务器进程(父进程)可以继续处理命令请求。</li>
<li>子进程带有服务器进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li>
</ul>
<p>因为子进程在进行 AOF 重写期间，服务器还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，从而使得服务器当前的数据库状态和重写后的 AOF 文件所保存的数据库状态不一致。</p>
<p>为了解决这种数据不一致的问题，Redis 服务器设置了一个 AOF 重写缓冲区，缓冲区在服务器创建子进程之后开始使用，当 Redis 服务器执行完一个命令之后，它同时将这个写命令发送给 AOF 缓冲区和 AOF 重写缓冲区。</p>
<p>当子进程完成 AOF 重写工作之后，它会向父进程发送一个信号，父进程在接到该信号后，会调用一个信号函数，执行以下工作（执行这个函数时，服务器进程会被阻塞）：</p>
<ol>
<li>将 AOF 重写缓冲区中的所有内容写入到新的 AOF 文件中，这时新 AOF 文件所保存的数据库状态和服务器当前的数据库状态一致。</li>
<li>对新的 AOF 文件进行改名，原子地覆盖现有的 AOF 文件，完成新旧两个 AOF 文件的替换。</li>
</ol>
<h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>AOF 文件通过保存所有修改数据库的写命令请求来记录服务器的数据库状态。</li>
<li>AOF 文件中的所有命令都以 Redis 命令请求协议的格式保存。</li>
<li>命令请求会先保存到 AOF 缓冲区里面，之后再定期写入并同步到 AOF 文件。</li>
<li>appendfsync 选项的不同值对 AOF 持久化功能的安全性以及 Redis 服务器的性能有很大的影响。</li>
<li>服务器只要载入并重新执行保存在 AOF 文件中的命令，就可以还原数据库本来的状态。</li>
<li>AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</li>
<li>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有的 AOF 文件进行任何的读入、分析或者写入操作。</li>
<li>在执行 <em>BGREWRITEAOF</em> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建 AOF 文件的工作之后，服务器会将重写缓冲区的所有内容追加到新 AOF 文件的末尾，使得新旧两个 AOF 文件所保存的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件的重写操作。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/27/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%8D%81%E7%AB%A0RDB%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/27/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%8D%81%E7%AB%A0RDB%E6%8C%81%E4%B9%85%E5%8C%96/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第二部分:单机数据的实现:第十章:RDB持久化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-27 11:27:08" itemprop="dateCreated datePublished" datetime="2020-05-27T11:27:08+08:00">2020-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-28 15:53:21" itemprop="dateModified" datetime="2020-05-28T15:53:21+08:00">2020-05-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h1><p>RDB 持久化功能生成的 RDB 文件是一个经过压缩的二进制文件。</p>
<h2 id="RDB-文件的创建与载入"><a href="#RDB-文件的创建与载入" class="headerlink" title="RDB 文件的创建与载入"></a>RDB 文件的创建与载入</h2><ul>
<li><p><em>SAVE</em> 命令会阻塞服务器进程，直到 RDB 文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何请求。</p>
</li>
<li><p><em>BGSAVE</em> 命令会派生出一个子进程，然后由子进程负责创建 RDB 文件，服务器进程（父进程）继续处理请求。</p>
</li>
<li><p>RDB 文件的载入工作是在服务器启动时自动执行的。</p>
</li>
</ul>
<p>AOF 文件的更新频率通常比 RDB 文件的更新频率高，所以：</p>
<ul>
<li>如果服务器开启了 AOF 持久化功能，那么服务器会优先使用 AOF 文件来还原数据库状态。</li>
<li>之后在 AOF 持久化功能处于关闭状态时，服务器才会使用 RDB 文件来还原数据库状态。</li>
</ul>
<h3 id="SAVE-命令执行时的服务器状态"><a href="#SAVE-命令执行时的服务器状态" class="headerlink" title="SAVE 命令执行时的服务器状态"></a>SAVE 命令执行时的服务器状态</h3><h3 id="BGSAVE-命令执行时的服务器状态"><a href="#BGSAVE-命令执行时的服务器状态" class="headerlink" title="BGSAVE 命令执行时的服务器状态"></a>BGSAVE 命令执行时的服务器状态</h3><ul>
<li>BGSAVE 命令执行期间，客户端发送的 SAVE 命令会被服务器拒绝。</li>
<li>BGSAVE 命令执行期间，客户端发送的 BGSAVE 命令也会被服务器拒绝。</li>
</ul>
<ul>
<li>BGREWRITEAOF 和 BGSAVE 两个命令不能同时执行：<ul>
<li>如果 BGSAVE 命令正在执行，那么客户端发送的 BGREWRITEAOF 命令会被延迟到 BGSAVE 命令执行完毕之后执行。</li>
<li>如果 BGREWRITEAOF 命令正在执行，那么客户端发送的 BGSAVE 命令会被服务器拒绝。</li>
</ul>
</li>
</ul>
<p>BGREWRITEAOF 和 BGSAVE 两个命令的实际工作都由子进程执行，命令操作方面并不冲突，不能同时执行它们只是一个性能方面的考虑。</p>
<h3 id="RDB-文件载入时的服务器状态"><a href="#RDB-文件载入时的服务器状态" class="headerlink" title="RDB 文件载入时的服务器状态"></a>RDB 文件载入时的服务器状态</h3><p>阻塞，直到载入工作完成。</p>
<h2 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h2><p><code>save 60 10000</code> // 服务器在 60 秒之内，对数据库进行了至少 10000 次修改。</p>
<h3 id="设置保存条件"><a href="#设置保存条件" class="headerlink" title="设置保存条件"></a>设置保存条件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">default</span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line"></span><br><span class="line">save 300 10</span><br><span class="line"></span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录了保存条件的数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> &#123;</span></span><br><span class="line">    <span class="comment">// 秒数</span></span><br><span class="line">    <span class="keyword">time_t</span> seconds;</span><br><span class="line">    <span class="comment">// 修改数</span></span><br><span class="line">    <span class="keyword">int</span> changes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="dirty-计数器和-lastsave-属性"><a href="#dirty-计数器和-lastsave-属性" class="headerlink" title="dirty 计数器和 lastsave 属性"></a>dirty 计数器和 lastsave 属性</h3><ul>
<li><p>dirty 计数器记录距离上一次成功执行 SAVE 命令或者 BGSAVE 命令之后，服务器对数据库状态（服务器中所有的数据库）进行了多少次修改（包括写入，删除，更新等操作）</p>
</li>
<li><p>lastsave 属性是一个 UNIX 时间戳，记录了服务器上一次成功执行 SAVE 命令或者 BGSAVE 命令的时间。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">time_t</span> lastsave;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="检查保存条件是否满足"><a href="#检查保存条件是否满足" class="headerlink" title="检查保存条件是否满足"></a>检查保存条件是否满足</h3><p>Redis 的服务器周期性操作函数 serverCron 默认每隔 100 毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，其中一项工作就是检查 save 选项所设置的保存条件是否已经满足，如果满足，则执行 BGSAVE 命令。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serverCron</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="comment"># 遍历所有保存条件</span></span><br><span class="line">    <span class="keyword">for</span> saveparam <span class="keyword">in</span> server.saveparams:</span><br><span class="line">        </span><br><span class="line">        save_interval = unixtime_now() - server.lastsave</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> server.dirty &gt;= saveparam.changes <span class="keyword">and</span> save_interval &gt; saveparam.seconds:</span><br><span class="line">            BGSAVE()</span><br><span class="line">            </span><br><span class="line">	<span class="comment">#...</span></span><br></pre></td></tr></table></figure>



<h2 id="RDB-文件结构"><a href="#RDB-文件结构" class="headerlink" title="RDB 文件结构"></a>RDB 文件结构</h2><p><code>REDIS | db_version | databases | EOF | check_sum</code></p>
<ul>
<li>REDIS：长度 5 字节，保存“REDIS”这五个字符，可以让程序在载入文件的时候，快速检查所载入的文件是否为 RDB 文件。</li>
<li>db_version：长度 4 字节，字符串表示的整数，记录了 RDB 文件的版本号。“0006”</li>
<li>databases：包含着零个或者任意多个数据库，以及各个数据库中的键值对数据</li>
<li>EOF：长度 1 字节，标志着 RDB 文件正文内容的结束。</li>
<li>check_sum：长度 8 字节，</li>
</ul>
<h3 id="databases-部分"><a href="#databases-部分" class="headerlink" title="databases 部分"></a>databases 部分</h3><p><code>SELECTDB | db_number | key_value_pairs</code></p>
<ul>
<li>SELECTDB：长度 1 字节，标识着接下来要读入的将是一个数据库号码。</li>
<li>db_number：根据号码的不同，长度可以为 1 字节，2 字节，5 字节。读入 db_number 之后，服务器会调用 SELECT 命令，根据读入的数据库号码进行数据库切换，使得之后读入的键值对可以载入到正确的数据库中。</li>
<li>key_value_pairs：保存了数据库中所有的键值对，如果键值对带有过期时间，那么过期时间也会和键值对保存在一起。</li>
</ul>
<h3 id="key-value-pairs-部分"><a href="#key-value-pairs-部分" class="headerlink" title="key_value_pairs 部分"></a>key_value_pairs 部分</h3><p>不带过期时间的键值对在 RDB 文件中由 TYPE, key, value 三部分组成</p>
<p>TYPE 记录了 value 的类型，长度为 1 字节</p>
<p>带过期时间的键值对在 RDB 文件中由 EXPIRETIME_MS, ms, TYPE, key, value 组成。</p>
<p>EXPIRETIME_MS：常量的长度为 1 字节，标识着接下来要读入的将是一个以毫秒为单位的过期时间。</p>
<p>ms：8 字节长的带符号整数，记录着一个以毫秒为单位的 UNIX 时间戳，是键值对的过期时间。</p>
<h3 id="value-的编码"><a href="#value-的编码" class="headerlink" title="value 的编码"></a>value 的编码</h3><p>待学习</p>
<h2 id="分析-RDB-文件"><a href="#分析-RDB-文件" class="headerlink" title="分析 RDB 文件"></a>分析 RDB 文件</h2><p>待学习</p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>RDB 文件用于保存和还原 Redis 服务器所有数据库中的键值对数据。</li>
<li>SAVE 命令由服务器进程直接执行保存操作，所以该命令会阻塞服务器。</li>
<li>BGSAVE 命令由子进程执行保存操作，所以该命令不会阻塞服务器。</li>
<li>服务器状态中会保存所有用 save 选项设置的保存条件，当任意一个条件被满足时，服务器会自动执行 BGSAVE 命令。</li>
<li>RDB 文件是一个经过压缩的二进制文件，由多个部分组成。</li>
<li>对于不同类型的键值对，RDB 文件会使用不同的方式来保存它们。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/26/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B9%9D%E7%AB%A0%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/26/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B9%9D%E7%AB%A0%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第二部分:单机数据的实现:第九章:数据库</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-26 10:44:43" itemprop="dateCreated datePublished" datetime="2020-05-26T10:44:43+08:00">2020-05-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-27 11:27:01" itemprop="dateModified" datetime="2020-05-27T11:27:01+08:00">2020-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="服务器中的数据库"><a href="#服务器中的数据库" class="headerlink" title="服务器中的数据库"></a>服务器中的数据库</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 一个数组，保存着服务器中的所有数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 服务器的数据库数量</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;<span class="comment">// default 16</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="切换数据库"><a href="#切换数据库" class="headerlink" title="切换数据库"></a>切换数据库</h1><p>Redis 客户端的默认目标数据库为 0 号数据库，SELECT </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 记录客户端当前正在使用的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure>



<h1 id="数据库键空间"><a href="#数据库键空间" class="headerlink" title="数据库键空间"></a>数据库键空间</h1><p>Redis 是一个 KV 数据库服务器，服务器中的每个数据库都由一个 redis.h / redisDb 结构表示，其中 redisDb 结构的 dict 字典保存了数据库中的所有键值对，我们将这个字典称为键空间(key space).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 数据库键空间，保存着数据库中的所有键值对</span></span><br><span class="line">    dict *dict;</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>键空间和用户所见的数据库是直接对应的：</p>
<ul>
<li>键空间的键也就是数据库的键，每个键都是一个字符串对象。</li>
<li>键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种 Redis 对象。</li>
</ul>
<h2 id="添加新键"><a href="#添加新键" class="headerlink" title="添加新键"></a>添加新键</h2><p>添加一个新键值对到数据库，实际上就是将一个新键值对添加到键空间字典里面，其中键为字符串对象，而值则为任意一种类型的 Redis 对象。</p>
<h2 id="删除键"><a href="#删除键" class="headerlink" title="删除键"></a>删除键</h2><p>删除一个数据库中一个键，实际上就是在键空间里面删除键所对应的键值对对象。</p>
<h2 id="更新键"><a href="#更新键" class="headerlink" title="更新键"></a>更新键</h2><p>对一个数据库键进行更新，实际上就是对键空间里面键所对应的值对象进行更新，根据值对象的类型不同，更新的具体方法也会有所不同。</p>
<h2 id="对键取值"><a href="#对键取值" class="headerlink" title="对键取值"></a>对键取值</h2><p>对一个数据库键进行取值，实际上就是在键空间中取出键所对应的值的对象，根据值对象的类型不同，具体的取值方法也有所不同。</p>
<h2 id="其他键空间操作"><a href="#其他键空间操作" class="headerlink" title="其他键空间操作"></a>其他键空间操作</h2><p>还有很多针对数据库本身的 Redis 命令，也是通过对键空间进行处理来完成的。</p>
<ul>
<li><em>FLUSHDB</em>：通过删除键空间中的所有键值对来实现。</li>
<li><em>RANDOMKEY</em>：通过在键空间中随机返回一个键来实现的。</li>
<li><em>DBSIZE</em>：通过返回键空间中包含的键值对的数量来实现的。</li>
<li><em>EXISTS</em>, <em>RENAME</em>, <em>KEYS</em></li>
</ul>
<h2 id="读写键空间时的维护操作"><a href="#读写键空间时的维护操作" class="headerlink" title="读写键空间时的维护操作"></a>读写键空间时的维护操作</h2><p>当使用 Redis 命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作，还会执行一些额外的操作：</p>
<ul>
<li><p>读取一个键之后（读写操作都需要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数。<em>INFO stats</em> keyspace_hits keyspace_misses</p>
</li>
<li><p>读取一个键之后，服务器会更新键的 LRU 时间，这个值可以用于计算键的闲置时间，使用 OBJECT idletime 命令可以查看键的闲置时间。</p>
</li>
<li><p>如果服务器在读取一个键的时候发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。</p>
</li>
<li><p>如果有客户端使用 <em>WATCH</em> 命令监视了某个键，那么服务器在对被监视的键进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过了</p>
</li>
<li><p>服务器每次修改一个键之后，都会对脏键计数器的值增 1， 这个计数器会触发服务器的持久化以及复制操作。</p>
</li>
<li><p>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送响应的数据库通知。</p>
</li>
</ul>
<h1 id="设置键的生存时间或过期时间"><a href="#设置键的生存时间或过期时间" class="headerlink" title="设置键的生存时间或过期时间"></a>设置键的生存时间或过期时间</h1><p>通过 <em>EXPIRE</em> 命令或者 <em>PEXPIRE</em> 命令，客户端可以以秒或者毫秒的精度为数据库中的某个键设置生存时间，在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为 0 的键</p>
<p>通过 <em>EXPIREAT</em> 命令或者 <em>PEXPIREAT</em> 命令，以秒或者毫秒精度给数据库中的某个键设置过期时间（一个 UNIX 时间戳），当键的过期时间来临时，服务器就会自动从数据库中删除这个键。</p>
<p><em>TTL</em> 命令和 <em>PTTL</em> 命令接受一个带有生存时间或者过期时间的键，返回这个键的剩余生存时间。</p>
<h2 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h2><ul>
<li><p><code>EXPIRE &lt;key&gt; &lt;ttl&gt;</code> ：将键 key 的生存时间设置为 ttl 秒。</p>
</li>
<li><p><code>PEXPIRE &lt;key&gt; &lt;ttl&gt;</code>：将键 key 的生存时间设置为 ttl 毫秒。</p>
</li>
<li><p><code>EXPIREAT &lt;key&gt; &lt;timestamp&gt;</code>：将键 key 的过期时间设置为 timestamp 所指定的秒数时间戳。</p>
</li>
<li><p><code>PEXPIREAT &lt;key&gt; &lt;timestamp&gt;</code>：将键 key 的过期时间设置为 timestamp 所指定的毫秒数时间戳。</p>
</li>
</ul>
<p>最终，<em>EXPIRE, PEXPIRE, EXPIREAT</em> 三个命令都会转换成 <em>PEXPIREAT</em> 命令来执行。</p>
<h2 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h2><p>redisDb 结构的 expires 字典保存了数据库中所有键的过期时间，称之为过期字典。</p>
<ul>
<li>过期字典的键是一个指针，指向键空间中某个键对象。</li>
<li>过期字典的值是一个 long long 类型的整数，保存了键所指向的数据库键的过期时间（一个毫秒精度的 UNIX 时间戳）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 过期字典，保存着键的过期时间</span></span><br><span class="line">    dict *expires;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p>当客户端执行 <em>PEXPIREAT</em> 命令为一个数据库键设置过期时间时，服务器会在数据库的过期字典中关联给定的数据库键和过期时间。</p>
<h2 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h2><p><em>PERSIST</em>  命令可以移除一个键的过期时间</p>
<p><em>PERSIST</em>  命令在过期字典中查找给定的键，并解除键和值（过期时间）在过期字典中的关联。</p>
<h2 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h2><p><em>TTL, PTTL</em> 两个命令都是通过计算键的过期时间和当前时间之间的差来实现的。</p>
<h2 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h2><ol>
<li>检查给定键是否存在于过期字典：如果存在，那么取得键的过期时间。</li>
<li>检查当前 UNIX 时间戳是否大于键的过期时间：如果是的话，那么键已经过期；否则未过期</li>
</ol>
<h1 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h1><h2 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h2><ul>
<li><p>对内存是友好的：通过使用计时器，定时删除策略可以保证过期的键会尽可能快地被删除，并释放过期键所占用的内存。</p>
</li>
<li><p>对 CPU 时间是最不友好的：过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分 CPU 时间。</p>
</li>
<li><p>创建一个定时器需要用到 Redis 服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为 <em>O(N)</em>， 效率低</p>
</li>
<li><p>要让服务器创建大量的定时器，从而实现定时删除策略，现阶段不现实。</p>
</li>
</ul>
<h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><ul>
<li>对 CPU 时间是友好的：程序只会在取出键时才对键进行过期检查，可以保证删除过期键的操作只会在非做不可的情况下进行，并且删除的目标仅限于当前处理的键，这个策略不会再删除其他无关的过期建上花费任何 CPU 时间。</li>
<li>对内存不友好：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会被释放。</li>
</ul>
<h2 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h2><ul>
<li>定期删除策略每隔一段时间执行一次删除过期操作，并通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
<li>通过定期删除过期键，有效地减少了因为过期键而带来的内存浪费。</li>
<li>服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。</li>
</ul>
<h1 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h1><p>Redis 服务器实际使用的是惰性删除和定期删除两种策略。</p>
<h2 id="惰性删除策略的实现"><a href="#惰性删除策略的实现" class="headerlink" title="惰性删除策略的实现"></a>惰性删除策略的实现</h2><p>所有读写数据库的 Redis 命令在执行之前都会调用 expireIfNeeded 函数对输入键进行检查：</p>
<ul>
<li>如果输入键已经过期，那么 expireIfNeeded  函数键输入键从数据库中删除。</li>
<li>如果输入键未过期，那么 expireIfNeeded 不做动作。</li>
</ul>
<h2 id="定期删除策略的实现"><a href="#定期删除策略的实现" class="headerlink" title="定期删除策略的实现"></a>定期删除策略的实现</h2><p>每当 Redis 的服务器周期性操作 redis.c/serverCron 函数执行时，activeExpireCycle 函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的 expire 字典中随机检查一部分键的过期时间，并删除其中的过期键。</p>
<h1 id="AOF、RDB-和复制功能对过期键的处理"><a href="#AOF、RDB-和复制功能对过期键的处理" class="headerlink" title="AOF、RDB 和复制功能对过期键的处理"></a>AOF、RDB 和复制功能对过期键的处理</h1><h2 id="生成-RDB-文件"><a href="#生成-RDB-文件" class="headerlink" title="生成 RDB 文件"></a>生成 RDB 文件</h2><p>在执行 SAVE 命令或者 BGSAVE 命令创建一个新的 RDB 文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的 RDB 文件中。</p>
<h2 id="载入-RDB-文件"><a href="#载入-RDB-文件" class="headerlink" title="载入 RDB 文件"></a>载入 RDB 文件</h2><p>在启动 Redis 服务器时，如果服务器开启了 RDB 功能，那么服务器将对 RDB 文件进行载入：</p>
<ul>
<li>如果服务器以主服务器模式运行，那么在载入 RDB 文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入 RDB 文件的主服务器不会造成影响。</li>
<li>从服务器则会载入所有的键。不过，因为主服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入 RDB 文件的从服务器也不会造成影响。</li>
</ul>
<h2 id="AOF-文件写入"><a href="#AOF-文件写入" class="headerlink" title="AOF 文件写入"></a>AOF 文件写入</h2><p>当服务器以 AOF 持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么 AOF 文件不会因为这个过期键而产生任何影响。</p>
<p>当过期键被惰性删除或者定期删除后，程序会向 AOF 文件 append 一条 DEL 命令，来显示地记录改键已被删除。</p>
<blockquote>
<p>GET message</p>
<ul>
<li>如果 message 键已经过期，服务器将执行<ol>
<li>从数据库中删除 message 键。</li>
<li>追加一条 DEL message 命令到 AOF 文件。</li>
<li>向执行 GET 命令的客户端返回空回复。</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><p>执行 AOF 重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的 AOF 文件中。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>当服务器运行在复制模式之下时，从服务器的过期键删除动作由主服务器控制：</p>
<ul>
<li>从服务器在删除一个过期键之后，会显示地向所有从服务器发送一个 DEL 命令，告知从服务器删除这个过期键。</li>
<li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将其删除，而是继续像处理未过期的键一样来处理过期键。（会返回过期键的值）</li>
<li>从服务器只有在接到主服务器发来的 DEL 命令之后，才会删除过期键。</li>
</ul>
<p>通过由主服务器来控制从服务器统一地删除过期键，可以保证主从服务器的一致性。同时当一个过期键仍然存在于主服务器的数据库中，这个过期键在从服务器的复制品也会继续存在。</p>
<h1 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h1><p>通过让客户端订阅给定的频道或者模式，来获知数据库中的键的变化，以及数据库中命令的执行情况。</p>
<p>可以关注“某个键执行了什么命令”（键空间通知）或者关注“某个命令被什么键执行了”（键事件通知）</p>
<h2 id="发送通知"><a href="#发送通知" class="headerlink" title="发送通知"></a>发送通知</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">notify.c/notifyKeyspaceEvent 函数实现的：</span><br><span class="line"></span><br><span class="line"><span class="comment">// @param: type: 当前想要发送的通知的类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @param: event: 事件的名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @param: keys: 产生事件的键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @param: dbid: 产生事件的数据库号码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, rboj *key, <span class="keyword">int</span> dbid)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="发送通知的实现"><a href="#发送通知的实现" class="headerlink" title="发送通知的实现"></a>发送通知的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(type, event, key, dbid)</span>:</span></span><br><span class="line">    <span class="comment"># 如果给定的通知不是服务器允许的通知</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span>(server.notify_keyspace_events &amp; type):</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 发送键空间通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYSPACE:</span><br><span class="line">        <span class="comment"># 将通知发送给频道 __keyspace@&lt;dbid&gt;__:&lt;key&gt;</span></span><br><span class="line">        <span class="comment"># 内容为键所发生的事件 &lt;event&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">"_keyspace@&#123;dbid&#125;__:&#123;key&#125;"</span>.format(dbid=dbid, key=key)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, event)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 发送键事件通知</span></span><br><span class="line">    <span class="keyword">if</span> server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYEVENT:</span><br><span class="line">        <span class="comment"># 将通知发送给频道 __keyspace@&lt;dbid&gt;__:&lt;event&gt;</span></span><br><span class="line">        <span class="comment"># 内容为发生事件的键 &lt;key&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建频道名字</span></span><br><span class="line">        chan = <span class="string">"_keyevent@&#123;dbid&#125;__:&#123;key&#125;"</span>.format(dbid=dbid, key=key)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 发送通知</span></span><br><span class="line">        pubsubPublishMessage(chan, key)</span><br></pre></td></tr></table></figure>



<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>Redis 服务器的所有数据库都保存在 redisServer.db 数组中，而数据库的数量则由 redisServer.dbnum 属性保存。</li>
<li>客户端通过修改目标数据库指针，让它指向的 redisServer.db 数组中的不同元素来切换不同的数据库。</li>
<li>数据库主要由 dict 和 expires 两个字典构成，其中 dict 字典负责保存键值对，expires 字典则负责保存键的过期时间。</li>
<li>因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。</li>
<li>数据库的键总是一个字符串对象，值可以是任意一种 Redis 对象类型，包括 字符串对象、哈希对象、列表对象、集合对象、有序集合对象，分别对应 字符串键、哈希键、列表键、集合键、有序集合建。</li>
<li>expires 字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的 UNIX 的时间戳。</li>
<li>Redis 使用惰性删除和定期删除两种策略来删除过期键</li>
<li>执行 <em>SAVE</em> 命令或者 <em>BGSAVE</em> 命令所产生的新 RDB 文件不会包含已经过期的键。</li>
<li>执行 <em>BGREWRITEAOF</em> 命令所产生的重写 AOF 文件不会包含已经过期的键。</li>
<li>当一个过期键被删除之后，服务器会追加一条 <em>DEL</em> 命令到现有的 AOF 文件的末尾，显示删除过期键。</li>
<li>从服务器即使发现过期键也不会自作主张的删除它，而是等待主节点的 <em>DEL</em> 命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li>
<li>当 Redis 命令对数据库进行修改之后，服务器会根据配置向客户端发送数据库通知。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/25/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%AF%B9%E8%B1%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/25/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%AF%B9%E8%B1%A1/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第一部分:数据结构与对象:第八章:对象</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-25 09:33:18" itemprop="dateCreated datePublished" datetime="2020-05-25T09:33:18+08:00">2020-05-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-26 10:57:36" itemprop="dateModified" datetime="2020-05-26T10:57:36+08:00">2020-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Redis 没有直接使用数据结构来实现键值对数据库，而是基于这些数据结构创建了一个对象系统。这个系统包含了字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种。</p>
<ul>
<li>Redis 可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。</li>
<li>可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</li>
</ul>
<h1 id="对象的类型和编码"><a href="#对象的类型和编码" class="headerlink" title="对象的类型和编码"></a>对象的类型和编码</h1><p>Redis 中的每个对象都由一个 RedisObject 结构表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>



<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>Redis 数据库保存的键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象的其中一种。</p>
<h2 id="编码和底层实现"><a href="#编码和底层实现" class="headerlink" title="编码和底层实现"></a>编码和底层实现</h2><p>通过 encoding 属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了 Redis 的灵活性和效率，因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。</p>
<ul>
<li>列表对象包含的元素比较少时，Redis 使用压缩列表作为列表对象的底层实现：<ul>
<li>相对于双端链表，压缩列表更节约内存，并且元素数量较少的时候，在内存中以连续块方式保存的压缩列表比起双端链表可以更快的被载入到缓存中；</li>
<li>随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层的实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面。</li>
</ul>
</li>
</ul>
<h1 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h1><p>字符串对象的编码可以是 int, raw 或者 embstr</p>
<ul>
<li>如果一个字符串保存的是整数值，并且这个整数值可以用 long 类型来表示，那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面(将 void* 转换成 long)，并将字符串对象的编码设置为 int.</li>
<li>如果一个字符串保存的是一个字符串值，并且这个字符串值的长度大于 32 字节，那么字符串对象将使用一个 SDS 来保存这个字符串值，并将对象的编码设置为 raw.</li>
<li>如果一个字符串保存的是一个字符串值，并且这个字符串值的长度小于等于 32 字节，那么字符串对象将使用一个 embstr 编码的方式来保存这个字符串值。<ul>
<li>embstr 编码是专门用于保存短字符串的一种优化编码方式，这种编码和 raw 编码一样，都使用 RedisObject 结构和 sdshdr 结构来表示字符串对象，但 raw 编码会调用两次内存分配来分别创建 redisObject 结构和 sdshdr 结构，而 embstr 编码则通过调用一次内存分配函数来分配一块空间，空间中依次包含 redisObject 和 sdshdr 两个结构。</li>
<li>embstr 编码的字符串对象来保存短字符串值的好处：<ol>
<li>embstr 编码将创建字符串对象所需的内存分配次数从 raw 的两次降低为 1 次。</li>
<li>释放 embstr 编码的字符串对象只需要调用一次内存释放函数，而释放 raw 编码的字符串对象需要调用两次内存释放函数。</li>
<li>因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="编码的转换"><a href="#编码的转换" class="headerlink" title="编码的转换"></a>编码的转换</h2><ul>
<li>embstr 编码的字符串对象是只读的</li>
<li>对 int, embstr 编码的字符串修改之后，对象的编码会变为 raw</li>
</ul>
<h2 id="字符串命令的实现"><a href="#字符串命令的实现" class="headerlink" title="字符串命令的实现"></a>字符串命令的实现</h2><p>编码转换到合适的类型然后操作</p>
<h1 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h1><p>列表对象的编码可以是 ziplist 或者 linkedlist.</p>
<h2 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h2><p>当列表对象可以同时满足以下两个条件时，列表对象使用 ziplist 编码：</p>
<ol>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节；list-max-ziplist-value</li>
<li>列表对象保存的元素的数量小于 512 个；list-max-ziplist-entries</li>
</ol>
<h2 id="列表命令的实现"><a href="#列表命令的实现" class="headerlink" title="列表命令的实现"></a>列表命令的实现</h2><h1 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h1><p>哈希对象的编码可以是 ziplist 或者 hashtable</p>
<p>ziplist 编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入都哈希对象时，程序会将先保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。</p>
<p>hashtable 编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：</p>
<ul>
<li><p>字典的每个键都是一个字符串对象，对象中保存了键值对的键</p>
</li>
<li><p>字典的每个值都是一个字符串对象，对象中保存了键值对的值。</p>
</li>
</ul>
<h2 id="编码转换-1"><a href="#编码转换-1" class="headerlink" title="编码转换"></a>编码转换</h2><p>当哈希对象可以同时满足以下两个条件时，列表对象使用 ziplist 编码：</p>
<ol>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；hash-max-ziplist-value</li>
<li>哈希对象保存的键值对数量小于 512 个；hash-max-ziplist-entries</li>
</ol>
<h1 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h1><p>集合对象的编码可以是 intset 或者 hashtable。</p>
<h2 id="编码的转换-1"><a href="#编码的转换-1" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>当集合对象可以同时满足以下两个条件时，对象使用 intset 编码：</p>
<ol>
<li>集合对象保存的所有元素都是整数值。</li>
<li>集合对象保存的元素数量不超过512个。set-max-intset-entries</li>
</ol>
<h1 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h1><p>有序集合对象的编码可以是 ziplist 或者 skiplist。</p>
<p>ziplist 编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放置在靠近表尾的方向。</p>
<p>zset 结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的 Object 属性保存了元素的成员，而跳跃表节点的 score 属性则保存了元素的分值。</p>
<p>zset 结构中的 dict 字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：字典的键保存了元素的成员，而字典的值则保存了元素的分值。通过这个字典，程序可以用 <em>O(1)</em> 复杂度查找给定成员的分值。</p>
<p>跳跃表和字典都会通过指针来共享相同元素的成员和分值，所以不会产生重复成员或者分值，不会浪费额外的内存。</p>
<h2 id="编码的转换-2"><a href="#编码的转换-2" class="headerlink" title="编码的转换"></a>编码的转换</h2><p>当有序集合对象可以同时满足以下两个条件时，对象使用 ziplist 编码：</p>
<ol>
<li>有序集合保存的元素数量小于 128 个。zset-max-ziplist-entries</li>
<li>有序集合保存的所有元素成员的长度都小于 64 字节；zset-max-ziplist-value</li>
</ol>
<h1 id="类型检查和命令多态"><a href="#类型检查和命令多态" class="headerlink" title="类型检查和命令多态"></a>类型检查和命令多态</h1><p>Redis 中用于操作键的命令基本上可以分为两种类型：</p>
<ol>
<li>可以对任何类型的键执行：<em>DEL, EXPIRE, RENAME, TYPE, OBJECT</em> 等</li>
<li>只能对特定类型的键执行：<ul>
<li><em>SET, GET, APPEND, STRLEN</em> 等命令只能对字符串键执行；</li>
<li><em>HDEL, HSET, HGET, HLEN</em> 等命令只能对哈希键执行；</li>
<li><em>RPUSH, LPOP, LINSERT, LLEN</em> 等命令只能对列表键执行；</li>
<li><em>SADD, SPOP, SINTER, SCARD</em> 等命令只能对集合键执行；</li>
<li><em>ZADD, ZCARD, ZRANK, ZSCORE</em> 等命令只能对有序集合键执行；</li>
</ul>
</li>
</ol>
<h2 id="类型检查的实现"><a href="#类型检查的实现" class="headerlink" title="类型检查的实现"></a>类型检查的实现</h2><p>类型特定命令的所进行的类型检查是通过 redisObject 结构的 type 属性来实现的：</p>
<ol>
<li>在执行一个类型特定的命令之前，服务器会先检查输入数据库键的值对象是否为执行命令所需的类型，如果是，服务器就对键执行指定的命令。</li>
<li>否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。</li>
</ol>
<h2 id="多态命令的实现"><a href="#多态命令的实现" class="headerlink" title="多态命令的实现"></a>多态命令的实现</h2><p>Redis 除了会根据值对象的类型来判断键是否能够执行指定的命令之外，还会根据值对象的编码方式，选择正确的命令实现代码来执行命令。</p>
<h1 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>通过引用计数器来判断是否回收对象。</p>
<h1 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h1><p>Redis 中，让多个键共享同一个值对象需要执行以下两个步骤：</p>
<ol>
<li>将数据库键的值指针指向一个现有的对象。</li>
<li>将被共享的值对象的引用计数器增一。</li>
</ol>
<p>Redis 只对包含整数值的字符串对象进行共享，因为别的对象共享需要花费大量的CPU时间去检查他们是否真的相同。</p>
<h1 id="对象的空转时长"><a href="#对象的空转时长" class="headerlink" title="对象的空转时长"></a>对象的空转时长</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录了对象最后一次被命令程序访问的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:<span class="number">22</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>



<p>对象的空转时长 <em>OBJECT IDLETIME</em> 命令打印出来</p>
<p>如果服务器打开了 maxmemory 选项，并且服务器用于回收内存的算法为 volatile-lru 或者 allkeys-lru，那么当服务器占用的内存数超过了 maxmemory 选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。</p>
<h1 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h1><ul>
<li>Redis 数据库中的每个键值对的键和值都是一个对象。</li>
<li>Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。</li>
<li>Redis 的对象系统带有引用计数实现的内存回收机制，当一个对象不再使用时，该对象所占用的内存就会被自动释放。</li>
<li>Redis 会共享值为 0 ~ 9999 的字符串对象。</li>
<li>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/24/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第一部分:数据结构与对象:第七章:压缩列表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-24 21:15:37" itemprop="dateCreated datePublished" datetime="2020-05-24T21:15:37+08:00">2020-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-26 09:21:32" itemprop="dateModified" datetime="2020-05-26T09:21:32+08:00">2020-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表(ziplist)是列表键和哈希键的底层实现之一。当一个列表键(哈希键)只包含少量列表项，并且每个列表项要么就是小数值，要么就是长度比较短的字符串，Redis 就会使用压缩列表来作为底层实现。</p>
<h2 id="压缩列表的构成"><a href="#压缩列表的构成" class="headerlink" title="压缩列表的构成"></a>压缩列表的构成</h2><ul>
<li>zlbytes ：记录整个压缩列表占用的字节数：在对压缩列表进行内存重分配，或者计算 zlend 的位置时使用。</li>
<li>zltail：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节：通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。</li>
<li>zllen：记录了压缩列表包含的节点数量。2字节，如果长度超过65535需要遍历一遍。</li>
<li>entryX：压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</li>
<li>zlend：特殊值 0xFF ，用于标记压缩列表的末端。</li>
</ul>
<h2 id="压缩列表节点的构成"><a href="#压缩列表节点的构成" class="headerlink" title="压缩列表节点的构成"></a>压缩列表节点的构成</h2><p>节点可以保存一个字节数组或者一个整数值</p>
<ul>
<li>previous_entry_length：保存前一个节点的字节长度<ul>
<li>如果前一个节点的长度小于 254 字节，previous_entry_length 属性长度为 1 字节，前一个节点的长度就保存在这一个字节里面。</li>
<li>如果前一个节点的长度大于等于 254 字节，那么 previous_entry_length 属性的长度为 5 字节，第一个字节会被设置为 0xFE ，之后的四个字节保存前一节点的长度。</li>
<li>通过 previous_entry_length 可以实现压缩列表的反向遍历。</li>
</ul>
</li>
<li>encoding：记录了节点 content 属性所保存数据的类型和长度<ul>
<li>一字节、两字节或者五字节长，值的最高位为 00， 01 或者 10 的是字节数组编码：这种编码表示节点的 content 属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录。</li>
<li>一字节长，值的最高位以 11 开头的是整数编码：种编码表示节点的 content 属性保存着整数值，整数值的类型和长度由编码除去最高两位之后的其他位记录。</li>
</ul>
</li>
<li>content：负责保存节点的值，节点的值可以是一个字节数组或者整数，值的类型和长度由节点的 encoding 属性决定。</li>
</ul>
<h2 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h2><p>因为 previous_entry_length 的长度不确定，在特殊情况下会导致连锁更新。</p>
<p>连锁更新在最坏的情况下需要对压缩列表执行 N 次空间重分配操作，而每次空间重分配的最坏复杂度为 <em>O(N)</em>, 所以连锁更新的最坏复杂度为 <em>O(N²)</em>. （最坏情况出现几率小）</p>
<h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>压缩列表是一种为节约内存而开发的顺序型数据结构。</li>
<li>压缩列表被用作列表键和哈希键的底层实现之一。</li>
<li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li>
<li>添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作，但这种操作出现的几率不高。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/24/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%AE%A1%E7%90%86/1%202%203%20%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%AE%A1%E7%90%86/1%202%203%20%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%E4%B8%8E%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">软件过程与管理/1 2 3 软件过程与管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-24 19:46:38" itemprop="dateCreated datePublished" datetime="2020-05-24T19:46:38+08:00">2020-05-24</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>软件工程的三要素：过程、方法、工具</p>
<p>软件过程将技术和管理结合起来，使得软件能够被合理地、及时地开发出来。</p>
<p>通用框架活动：沟通、策划、建模、构建、部署</p>
<p>构建活动的过程模式属<strong>步骤模式</strong>类型</p>
<p><strong>惯例过程模型</strong>是包括活动、动作、任务、里程碑和工作产品的明确的集合，旨在开发高质量的软件。</p>
<p>惯例过程模型的<strong>优点</strong>：为活动提供稳定、控制和有组织性，以有序和项目的一致性为首要目标。为软件工程工作增加了大量有用的结构化设计，为项目团队提供了有效的路线图。</p>
<p>惯例过程模型的<strong>不足</strong>：使用过程中需要调整才能适应不同项目需要。缺乏灵活性、应对变更能力不强。</p>
<p><strong>瀑布模型</strong>从沟通开始，通过策划、建模、构建和部署的过程，最终提供完整的软件并提供持续的技术支持,又称为经典生命周期模型。</p>
<p>瀑布模型的<strong>特点</strong>：阶段间具有 顺序性和 依赖性；推迟程序的物理 实现；质量保证：− 每个阶段必须完成规定的文档− 每个阶段结束前完成<strong>文档</strong>审查；瀑布模型是一种严格线性的、按阶段顺序的、逐步细化的过程模型。</p>
<p>瀑布模型的<strong>优点</strong>：有利于人员的组织与管理；有利于软件开发方法和工具的研究；可以提高大型软件项目开发的质量和效率</p>
<p>瀑布模型的<strong>缺点</strong>：不适应需求经常发生变更的环境，难以解决需求不明确的问题；用户在过程终端才能看到产品，反馈时间长，风险大；易于陷入“阻塞状态”；；强调一次性交付完整系统，导致开发周期长；缺乏灵活性，可操作性差</p>
<p>瀑布模型的<strong>适用范围</strong>：需求明确、全面，开发过程中没有或很少变更的项目；开发人员熟悉项目产品的目标、环境、应用领域的低风险项目；开发过程很少或不需要用户参与的项目；用户使用环境稳定且能够容忍长开发周期的项目</p>
<p><strong>增量过程模型</strong>是一种以增量的形式生产软件产品的过程模型，适用于以下场景：初始的软件需求有明确的定义，但是，受时间或资源的限制，受时间或资源的限制，不宜单纯运用线性模型；迫切需要 迅速提供一套功能有限的产品，允许在后续版本中细化和扩充。</p>
<p><strong>增量模型</strong>以迭代的方式运用瀑布模型。每一个增量都提交一个可以操作的产品。</p>
<p>增量模型的<strong>特点</strong>：融合 瀑布模型的基本成分和 迭代的特征；以功能递增的方式进行软件开发；能较快地产生可操作的系统；在每一步递增中，均发布一个可操作的 增量版本，把用户/开发者的经验结合到不断求精的产品中。</p>
<p>增量模型<strong>优点</strong>：人员分配灵活，刚开始不用投入大量人力资源；规避技术风险；在短时间内提交核心产品，对用户起到镇静剂的作用，具有一定市场</p>
<p>增量模型<strong>缺点</strong>：并行开发构建，有可能遇到不能集成的风险，对软件体系结构要求高；容易退化为“边做边改”模型，导致对软件过程的控制失去整体性。</p>
<p>增量模型的<strong>适用范围</strong>：已有产品升级项目或新版本的开发项目；需求明确并对使用开始时间有严格要求的项目</p>
<p><strong>演化过程模型</strong>利用迭代的思想方法，使软件工程师 渐进地开发逐步完善的软件版本。演化过程模型主要适用于在项目开发初期项目需求不明确，把握不充分的项目。</p>
<p><strong>原型模型针</strong>对需求不明确的情况通过迅速构建可以运行的软件原型 ，以便理解和澄清问题，使开发人员与用户达成共识，最终在确定的需求基础上开发出满意的产品。原型模型是用户驱动的。</p>
<p>原型的分类：<strong>探索型原型</strong>：用于 需求分析阶段，目的是要澄清用户的需求，确定所期望的特性，并探索各<br>种方案的可行性。<strong>实验型原型</strong>：用于 设计阶段，考核实现方案是否合适。<strong>演化型原型</strong>：用于及早向用户提交一个原型系统，在得到用户的认可后不断扩充演变为最终的产品。</p>
<p>原型的使用策略：<strong>抛弃策略</strong>：原型仅用于开发过程的某个阶段，该阶段结束后，原型随之作废。<strong>附加策略</strong>：原型用于开发的全过程，由最基本的核心开始，逐步增加新的功能和新的需求，最后发展为用户满意的最终系统。</p>
<p>原型模型的<strong>优点</strong>：克服 瀑布模型的缺点，减少由于软件需求不明确带来的开发风险。<br>原型模型的<strong>缺点</strong>：容易引起用户误解。对用户参与程度要求高。缺少项目标准，用户可能不断提出新要求，原型<br>迭代的周期很难控制。额外的花费：研究结果表明构造一个原型可能需要10%额外花费。为了尽快实现原型，采用了 不合适的技术，运行效率可能会受影响。</p>
<p>原型模型的<strong>适用范围</strong>：适合于那些不能确切定义需求的中小型项目；用户未能详细定义输入、处理、输出；开发人员对算法效率、OS、人机交互的形式不确定。</p>
<p><strong>螺旋模型</strong>，综合了原型模型的迭代特征原型模型的迭代特征和 瀑布模型的系统性和可控制性的特点， 增加风险分析，是以风险为导向的生命期模型。采用循环方式逐步加深系统定义和实现的深度，同时降低风险。确定一系列里程碑，确保项目干系人都支持可行的和令人满意的解决方案。</p>
<p>螺旋模型<strong>特点</strong>：把软件开发过程组成为一个 逐步细化的螺旋周期序列，每经历一个周期，系统就得到进一步的细化和完善；紧密围绕开发中的风险问题，用 风险分析推动软件设计向深一层扩展、求精；强调 持续地判断、确定和修改用户任务目标，并按成本效益来分析候选的软件产品性质对任务目标的贡献；可结合采用 多种软件开发方法，但究竟结合哪一种方法仍由风险分析来决定。</p>
<p>螺旋模型的<strong>优势</strong>：设计上具有灵活性，可以在产品的各个阶段进行变更；以小的分段来构建大型系统，易于成本计算；客户参与各阶段的开发，保证项目不偏离正确方向和项目的可控性；引入风险分析，随着迭代的增加风险程度随之降低。</p>
<p>螺旋模型的<strong>不足</strong>：对风险评估技术和经验有较高要求，评估不当会造成重大损失；过多的迭代次数会延长交付时间，增加开发成本螺旋模型只适合于那些不能确切定义需求的大型软件项目的开发</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/24/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第一部分:数据结构与对象:第六章:整数集合</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-24 12:52:42" itemprop="dateCreated datePublished" datetime="2020-05-24T12:52:42+08:00">2020-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-26 09:11:00" itemprop="dateModified" datetime="2020-05-26T09:11:00+08:00">2020-05-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h1><p>整数集合( intset )是集合键的底层实现之一，当一个集合中只包含整数值元素，并且这个集合的元素数量不多时，Redis就会只用整数集合来作为集合键的底层实现。</p>
<h2 id="整数集合的实现"><a href="#整数集合的实现" class="headerlink" title="整数集合的实现"></a>整数集合的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint_32_t</span> enconding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint_32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>



<h2 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h2><p>添加到整数集合中的新元素（<em>O(N)</em>）的类型比整数集合现有所有的元素的类型都要长时，整数集合就需要先进行升级。</p>
<p>升级的步骤：</p>
<ol>
<li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。</li>
<li>将底层数组现有的所有元素转换成与新元素相同的数据类型，并将类型转换后的元素放置到正确的位置上，放置的过程中，维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<h2 id="升级的好处"><a href="#升级的好处" class="headerlink" title="升级的好处"></a>升级的好处</h2><ul>
<li>提升灵活性：不用担心类型不匹配</li>
<li>节约内存：相对于直接用 int64_t 类型的数组作为整数集合的底层实现。</li>
</ul>
<h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>不支持降级</p>
<h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>整数集合是集合键的底层实现之一。</li>
<li>整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素，有需要时候，程序会根据新添加元素的类型，改变这个数组的类型。</li>
<li>升级操作为整数数组集合带来了操作上的灵活性，并且尽可能的节约了内存。</li>
<li>整数集合只支持升级操作，不支持降级操作。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/24/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%B7%B3%E8%B7%83%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/24/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%B7%B3%E8%B7%83%E8%A1%A8/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第一部分:数据结构与对象:第五章:跳跃表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-24 08:54:46 / 修改时间：12:52:44" itemprop="dateCreated datePublished" datetime="2020-05-24T08:54:46+08:00">2020-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h1><p>跳跃表是一个种有序数据结构，平均 <em>O(logN)</em> 复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<p>Redis 在有序集合键和集群节点中用作内部数据结构中使用跳跃表。</p>
<h2 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h2><h3 id="跳跃表节点"><a href="#跳跃表节点" class="headerlink" title="跳跃表节点"></a>跳跃表节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplitNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backword</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<ul>
<li>level ：程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。每次创建一个新的跳跃表节点的时候，程序根据幂次定律(power law, 越大的数出现的概率越小) 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小，这个大小就是层的“高度”。</li>
<li>前进指针：level[i].forward 属性用于从表头向表尾方向访问节点。</li>
<li>跨度：level[i].span 用于记录两个节点之间的距离。</li>
<li>后退指针：用于从表尾向表头方向访问节点，每个节点之后一个后退指针。每次只能后退至前一个节点。</li>
<li>分值和成员：跳跃表中所有节点都按分值从小到大排序，成员对象指向一个 SDS.</li>
</ul>
<h3 id="跳跃表-1"><a href="#跳跃表-1" class="headerlink" title="跳跃表"></a>跳跃表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<ul>
<li>header: 指向跳跃表的表头节点</li>
<li>tail:</li>
<li>level：记录目前跳跃表内，层数最大的那个节点的层数(不包括表头节点)</li>
<li>length：记录跳跃表的长度，也是跳跃表目前包含节点的数量。</li>
</ul>
<p>扩展阅读：<a href="https://juejin.im/post/57fa935b0e3dd90057c50fbc" target="_blank" rel="noopener">Redis 为什么用跳表而不用平衡树？</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/21/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%97%E5%85%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="Keep Moving">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/21/Redis/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%97%E5%85%B8/" class="post-title-link" itemprop="url">Redis设计与实现读书笔记:第一部分:数据结构与对象:第四章:字典</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-21 12:43:56" itemprop="dateCreated datePublished" datetime="2020-05-21T12:43:56+08:00">2020-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-05-22 13:26:56" itemprop="dateModified" datetime="2020-05-22T13:26:56+08:00">2020-05-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Redis设计与实现读书笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size - 1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<h3 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<h3 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">// ht[1] 只会在对 ht[0] 哈希表进行 rehash 使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    <span class="comment">// 当 rehash 不在进行时, 值为 -1</span></span><br><span class="line">    <span class="keyword">int</span> trehashidx; <span class="comment">// rehashing not in progress if rehashidx == -1</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<ul>
<li>type 属性和 privdata 属性是针对不同类型的键值对，为创建多态字典而设置的。</li>
<li>type 属性是一个指向 dictType 结构的指针，每个 dictType 结构保存了一簇用于操作特定类型键值对的函数，Redis 会为用途不同的字典设置不同类型特定函数。</li>
<li>privdata 属性则保存了需要传给那些类型特定函数的可选参数。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>



<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>当要将一个新键值对添加到字典里时，需要先根据键值对的键计算出哈希值和索引值，然后根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用字典设置的哈希函数，计算键 key 的哈希值</span></span><br><span class="line">hash = dict -&gt; type -&gt; hashFunction(key);	// MurmurHash算法</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用哈希表的 sizemask 属性和哈希值，计算出索引值</span></span><br><span class="line"><span class="comment"># 根据情况不同，ht[x] 可以是 ht[0] 或者 ht[1]</span></span><br><span class="line">index = hash &amp; dict -&gt; ht[x].sizemask;</span><br></pre></td></tr></table></figure>



<h2 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h2><p>链地址法</p>
<h2 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h2><p>rehash 的步骤：</p>
<ol>
<li><p>为字典的 ht[1] 哈希表分配空间</p>
<ul>
<li>如果执行的是扩展操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2 的 n 次方。</li>
<li>如果执行的是收缩操作，那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2 的 n 次方。</li>
</ul>
</li>
<li><p>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面</p>
</li>
<li><p>rehash 完成后，释放 ht[0], 将 ht[1] 设置为 ht[0], 并在 ht[1] 新建一个空白哈希表，为下一次 rehash 做准备</p>
</li>
</ol>
<h3 id="哈希表的扩展与收缩"><a href="#哈希表的扩展与收缩" class="headerlink" title="哈希表的扩展与收缩"></a>哈希表的扩展与收缩</h3><ol>
<li>服务器目前没有在执行 <em>BGSAVE</em> 命令或者 <em>BGREWRITEAOF</em> 命令，并且哈希表的负载因子大于等于1</li>
<li>服务器目前正在执行 <em>BGSAVE</em> 命令或者  <em>BGREWRITEAOF</em> 命令，并且哈希表的负载因子大于等于5</li>
</ol>
<p>因为在执行 <em>BGSAVE</em> 命令或者  <em>BGREWRITEAOF</em> 命令的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制(copy-on-write)技术来优化子进程的使用效率，所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能的避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写入操作，最大限度地节约内存。</p>
<p>哈希表的负载因子小于 0.1 时，会自动执行 收缩操作。</p>
<h2 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式  rehash"></a>渐进式  rehash</h2><p>哈希表渐进式 rehash 的步骤：</p>
<ol>
<li>为字典的 ht[1] 哈希表分配空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 rehashidx ，并将它的值设置为 0, 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行制定的操作以外，还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，当 rehash 工作完成之后，程序将 rehashidx 属性的值增一。</li>
<li>随着字典操作的不断执行，最终在某个时间点上，ht[0] 的所有键值对都会被 rehash 到 ht[1]，这时程序将 rehashidx 属性的值设置为 -1， 表示 rehash 操作完成。</li>
</ol>
<p>因为在渐进式 rehash 的过程中，字典会同时使用 ht[0] 和 ht[1] 两个哈希表，字典的 delete，find，update 等操作会在两个哈希表上查找，先在 ht[0] 中找，找不到再去 ht[1] 中找。</p>
<p>insert 操作，只会插入到 ht[1] 中。</p>
<h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><ul>
<li>字典被广泛用于实现 Redis 的各种功能，其中包括数据库和哈希键</li>
<li>Redis 中的字典使用哈希表作为底层实现，每个字典中带有两个哈希表，一个平时使用，另一个仅在 rehash 时使用。</li>
<li>当字典被用作数据库的底层实现，或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值</li>
<li>哈希表使用链地址法解决键冲突，被分配到同一个索引上的多个键值对会连接成一个单向链表。</li>
<li>在对哈希表进行扩展或者收缩操作时，程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面，并且这个 rehash 操作过程不是一次性地完成的，而是渐进式的完成的。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wayne"
      src="/images/808.jpg">
  <p class="site-author-name" itemprop="name">Wayne</p>
  <div class="site-description" itemprop="description">Keep Moving</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">57</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:winter98@foxmail.com" title="E-Mail → mailto:winter98@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/Wayne_98" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;Wayne_98" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wayne</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
