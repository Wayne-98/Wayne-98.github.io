<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wayne-98.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="记录成长">
<meta property="og:type" content="website">
<meta property="og:title" content="Wayne">
<meta property="og:url" content="http://wayne-98.github.io/index.html">
<meta property="og:site_name" content="Wayne">
<meta property="og:description" content="记录成长">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Wayne">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://wayne-98.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Wayne</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Wayne</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/5.5%20~%205.12%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="记录成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/5.5%20~%205.12%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" class="post-title-link" itemprop="url">5.5 ~ 5.12 学习计划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 22:18:16 / 修改时间：22:18:51" itemprop="dateCreated datePublished" datetime="2020-05-10T22:18:16+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" itemprop="url" rel="index"><span itemprop="name">学习记录</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="5-5-5-12-学习计划"><a href="#5-5-5-12-学习计划" class="headerlink" title="5.5 ~ 5.12 学习计划"></a>5.5 ~ 5.12 学习计划</h2><ul>
<li>每天写 LeetCode，复习 200 英语单词</li>
<li>JVM 复习一遍笔记</li>
<li>Java 并发 复习一遍笔记</li>
<li>高性能MySQL 再看一遍 5 6 章节</li>
<li>美团文章 JVM 调优</li>
<li>计算机网络 IP 数据链路 多播 数据控制层</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/%E9%9D%A2%E8%AF%95/%E9%9C%80%E8%A6%81%E6%8F%90%E5%8D%87%E7%9A%84%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="记录成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/%E9%9D%A2%E8%AF%95/%E9%9C%80%E8%A6%81%E6%8F%90%E5%8D%87%E7%9A%84%E7%82%B9/" class="post-title-link" itemprop="url">需要提升的点</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:15:52" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Collections.sort() 原理：归并</p>
<p>图的一些算法，需要复习一下</p>
<p>JVM 调优 参数</p>
<p>设计模式： 单例模式（懒汉饿汉） 工厂方法模式  观察者模式   责任链模式</p>
<p>红黑树</p>
<p>ThreadLocal</p>
<p><strong>B 树和 B+树的区别</strong>：</p>
<ul>
<li>B 树，每个节点都存储 key 和 data，所有节点组成这棵树，并且叶子节点指针为 nul，叶子结点不包含任何关键字信息。</li>
<li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而 B 树的非终节点也包含需要查找的有效信息)</li>
</ul>
<p><strong>为什么说 B+比 B 树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<ul>
<li>B+的磁盘读写代价更低。B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。</li>
<li>B+-tree 的查询效率更加稳定<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Scoket/socket%20IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="记录成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Scoket/socket%20IO/" class="post-title-link" itemprop="url">Socket I/O</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:15:22" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/I-O/" itemprop="url" rel="index"><span itemprop="name">I/O</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>One basic concept of Linux (actually Unix) is the rule that everything in Unix/Linux is a file. Each process has a table of file descriptors that point to files, sockets, devices and other operating system objects.<br>    linux系统中，一切皆文件。，每一个进程都有一个FD表，指向了与该进程有关的文件，套接字，设备或者其他操作系统对象。<br>Typical system that works with many IO sources has an initializaion phase and then enter some kind of standby mode – wait for any client to send request and response it<br>典型系统中有许多IO资源具有初始化阶段，然后进入某种待机模式——等待任意一个客户端发送请求并对其进行响应。<br>Simple solution is to create a thread (or process) for each client , block on read until a request is sent and write a response. This is working ok with a small amount of clients but if we want to scale it to hundred of clients, creating a thread for each client is a bad idea<br>简单的解决方案是为每一个客户，创建一个线程，客户请求的时候进行响应，其他时候处于阻塞状态。</p>
<hr>
<p>sfd = socket();    // socket 系统调用 得到一个文件描述符代表这个socket</p>
<p>bind(sfd…)    // 绑定到一个端口号上</p>
<p>listen(sfd)     // 开启监听状态</p>
<p>accept(sfd)     // 接收客户端的连接 (阻塞) </p>
<p>read recvfrom </p>
<p>调用recv 的时候，操作系统会把该进程阻塞。当网络数据到达网卡的时候，网卡会把数据放到内存，然后中断通知CPU，CPU 执行中断程序，把网络数据写入到对应的socket的接受缓冲区中(端口号)，在唤醒阻塞的进程来读数据。</p>
<ul>
<li>如何如何同时监视多个socket的数据？</li>
</ul>
<p>每次有一个 client 新的连接，该线程就 clone 一个新的线程来执行。</p>
<hr>
<h1 id="IO-Multiplexing"><a href="#IO-Multiplexing" class="headerlink" title="IO Multiplexing"></a>IO Multiplexing</h1><p>The solution is to use a kernel mechanism for polling over a set of file descriptors. There are 3 options you can use in Linux:<br>IO的多路复用解决方案是利于操作系统的内核机制来轮询一组文件描述符。</p>
<p>Multiplexing 指的其实是在单个线程通过记录跟踪每一个Sock(I/O流)的状态来同时管理多个I/O流. </p>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<p>All the above methods serve the same idea, create a set of file descriptors , tell the kernel what would you like to do with each file descriptor (read, write, ..) and use one thread to block on one function call until at least one file descriptor requested operation available</p>
<p>服务端需要管理多个客户端连接，而recv只能监视单个socket，这种矛盾下，人们开始寻找监视多个socket的方法。</p>
<ol>
<li><p><strong>select</strong> : 假如能够预先传入一个socket列表，<strong>如果列表中的socket都没有数据，挂起进程，直到有一个socket收到数据，唤醒进程</strong>。</p>
<ul>
<li>用法：先准备一个数组（下面代码中的fds），让fds存放着所有需要监视的socket。然后调用select，如果fds中的所有socket都没有数据，select会阻塞，直到有一个socket接收到数据，select返回，唤醒进程。用户可以遍历fds，通过FD_ISSET判断具体哪个socket收到数据，然后做出处理。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">bind(s, ...)</span><br><span class="line"><span class="built_in">listen</span>(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fds[] =  存放需要监听的socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = select(..., fds, ...)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; fds.count; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fds[i], ...))&#123;</span><br><span class="line">            <span class="comment">//fds[i]的数据处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>* **select的流程**：select的实现思路很直接。假如程序同时监视如下图的sock1、sock2和sock3三个socket，那么在调用select之后，操作系统把进程A分别加入这三个socket的等待队列中。</code></pre><p><img src="" alt=""></p>
</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/63179839" target="_blank" rel="noopener">如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （1）</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Operating%20System/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="记录成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Operating%20System/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" class="post-title-link" itemprop="url">简单操作系统概念</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:14:52" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Operating-System/" itemprop="url" rel="index"><span itemprop="name">Operating System</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1. 操作系统概述"></a>1. 操作系统概述</h1><ul>
<li>操作系统的特征</li>
</ul>
<ol>
<li><p><strong>并发</strong>：并发是指两个或多个事件在同一时间间隔内发生。</p>
</li>
<li><p><strong>共享</strong>：即资源共享，是指系统中的资源可供内存中多个并发执行的程序共同使用。</p>
</li>
<li><p>虚拟：是指把一个物理上的实体虚拟成多个逻辑上的对应物。</p>
<ul>
<li>虚拟技术：时分复用技术，空分复用技术</li>
</ul>
</li>
<li><p>异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是操作系统的异步性。</p>
</li>
</ol>
<ul>
<li><strong>内核</strong>（核心态）</li>
</ul>
<ol>
<li>时钟管理：提供系统时间、实现进程切换</li>
<li>中断机制：提高 CPU 的利用率</li>
<li>原语</li>
<li>系统控制的数据结构及处理</li>
</ol>
<ul>
<li><strong>中断</strong>：当中断或者异常发生的时候， 运行用户态的 CPU 会立即进入核心态，通过硬件实现的</li>
<li><strong>系统调用</strong>：是用户在程序中调用操作系统提供的一些子功能。系统中的各种共享资源都是由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（存储分配、进行 I/O 传输、管理文件），都必须通过系统调用的方式向操作系统提出服务请求，并由操作系统代为完成。</li>
</ul>
<h1 id="2-1-进程管理"><a href="#2-1-进程管理" class="headerlink" title="2.1 进程管理"></a>2.1 进程管理</h1><p>进程映像：程序段、相关数据段和 PCB (静态的)</p>
<p>进程：进程是进程映像的运行过程，是系统进行资源分配和调度的一个独立单位。（描述<strong>动态</strong>）</p>
<p>进程状态：创建 就绪 运行 阻塞(等待) 结束</p>
<p>进程之间的通信：</p>
<ol>
<li><p>共享存储</p>
<ol start="2">
<li>消息传递</li>
<li>管道通信</li>
</ol>
</li>
</ol>
<p>线程与进程的区别：调度、拥有资源、并发性、系统开销、地址空间和其他资源、通信方面</p>
<p>线程的实现方式：</p>
<pre><code>1. 用户级线程：将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模型中，用户级线程对操作系统不可见。
* 优点：线程管理是在用户级空间进行的，因而效率比较高
* 缺点：当一个线程在使用内核服务的时候被阻塞，那么整个进程就会被阻塞；多个线程不能并行的运行在多处理机上。
2. 内核级线程：将每个用户级线程映射到一个内核级线程
* 优点：当一个线程被阻塞的时候，另一个线程继续执行，并发能力强
* 缺点：每创建一个用户级线程都需要创建一个内核级线程与之对应，创建线程的开销比较大，会影响到用户程序的性能。</code></pre><p><img src="https://github.com/Wayne-98/image/blob/master/Operating%20System/Process.png?raw=true" alt=""></p>
<h1 id="2-2-处理机调度"><a href="#2-2-处理机调度" class="headerlink" title="2.2 处理机调度"></a>2.2 处理机调度</h1><ul>
<li>调度的层次（三级调度）</li>
</ul>
<ol>
<li>作业调度：内存与辅存之间的调度，每个作业只调入和调出一次。</li>
<li>中级调度(内存调度)：引入是为了提高内存的利用率和系统的吞吐量。将暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起态。</li>
<li>进程调度：按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</li>
</ol>
<p>作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</p>
<ul>
<li>调度的时机、切换与过程</li>
</ul>
<p>不能进程进程调度与切换的几种情况：</p>
<ol>
<li><p>处理中断的过程中</p>
<ol start="2">
<li>进程在操作系统内核临界区中</li>
<li>其他需要完全屏蔽中断的原子操作过程中</li>
</ol>
</li>
</ol>
<p>应当进行进程调度与切换的情况有：</p>
<ol>
<li><p>发生引起调度条件，并且当前进程无法继续执行下去，可以马上进行调度与切换。(非剥夺调度)</p>
<ol start="2">
<li>当中断处理结束或自陷处理结束后，返回被中断进程的用户态执行现场前。若置上请求调度标志，即可马上进行进程的调度与切换(剥夺式调度)</li>
</ol>
</li>
</ol>
<ul>
<li>调度的基本准则</li>
</ul>
<ol>
<li>CPU 利用率 2. 系统吞吐量 3. 周转时间 4. 等待时间 5. 响应时间</li>
</ol>
<ul>
<li>典型的调度算法</li>
</ul>
<ol>
<li>先来先服务 </li>
<li>短作业优先 </li>
<li>优先级调度 </li>
<li>高响应比优先调度 （响应比 = （等待时间 + 要求服务时间） / 要求服务时间）</li>
<li>时间片轮转调度</li>
<li>多级反馈队列调度 </li>
</ol>
<p><img src="https://github.com/Wayne-98/image/blob/master/Operating%20System/%E8%B0%83%E5%BA%A6.png?raw=true" alt=""></p>
<h2 id="2-3-进程同步"><a href="#2-3-进程同步" class="headerlink" title="2.3 进程同步"></a>2.3 进程同步</h2><ul>
<li>同步和互斥</li>
</ul>
<ol>
<li><p>同步：直接制约关系，指为完成某个任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递消息所产生的制约关系。进程间的直接制约关系，源于它们之间的合作。</p>
</li>
<li><p>互斥：简介制约关系，当一个进程进入临界区使用资源的时候，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许去访问此临界资源。</p>
</li>
</ol>
<ul>
<li>生产者消费者、读者写者、哲学家进餐</li>
</ul>
<p><img src="https://github.com/Wayne-98/image/blob/master/Operating%20System/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5.png?raw=true" alt=""></p>
<h2 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4 死锁"></a>2.4 死锁</h2><ul>
<li><p>死锁：多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将无法向前推进。</p>
</li>
<li><p>死锁产生的必要条件：</p>
<ol>
<li>互斥</li>
<li>不可剥夺</li>
<li>请求和保持</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。</li>
</ol>
</li>
<li><p>死锁的处理策略：</p>
<ol>
<li><p>预防死锁：破坏 4 个条件其中之一。</p>
</li>
<li><p>避免死锁：银行家</p>
</li>
<li><p>死锁的检测以及解除</p>
</li>
</ol>
</li>
<li><p>死锁预防</p>
<ol>
<li>破坏互斥：不可行</li>
<li>破坏不可剥夺：不可行</li>
<li>破坏请求和保持：一次分配所有资源，浪费资源，申请不到所有资源可能会出现“饥饿”现象</li>
<li>破坏循环等待：给资源编序号，按序申请。</li>
</ol>
</li>
<li><p>死锁避免：</p>
<ol>
<li>系统安全状态：系统能够按照某种进程推进顺序，为每个进程分配其所需资源，使每个进程多可以顺利的完成。</li>
<li>银行家算法：<ul>
<li>可用资源矢量</li>
<li>最大需求矩阵</li>
<li>分配矩阵</li>
<li>需求矩阵</li>
</ul>
</li>
</ol>
</li>
<li><p>死锁的检测与解除</p>
<ol>
<li>资源分配图</li>
</ol>
<p><img src="https://github.com/Wayne-98/image/blob/master/Operating%20System/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png?raw=true" alt=""></p>
<ol start="2">
<li>死锁定理：S 为死锁的条件是当且仅当 S 状态的资源分配图是不可完全简化的，该条件为死锁定理</li>
<li>死锁解除：<ol>
<li>资源剥夺法：挂起某些死锁进程，抢占它的资源</li>
<li>资源撤销法：按照进程的优先级和撤销进程的代价的高低，强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源</li>
<li>进程回退法：让一个或多个进程回退到足以回避死锁的地步，进程自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li>
</ol>
</li>
</ol>
<p><img src="https://github.com/Wayne-98/image/blob/master/Operating%20System/%E6%AD%BB%E9%94%81.png?raw=true" alt=""></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%EF%BC%9A%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="记录成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%EF%BC%9A%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">深入理解Java虚拟机第四部分：程序编译与代码优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:13:59" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前端编译与优化"><a href="#前端编译与优化" class="headerlink" title="前端编译与优化"></a>前端编译与优化</h1><p>Java中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说关系更加密切。</p>
<h2 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h2><h3 id="解析与填充符号表过程"><a href="#解析与填充符号表过程" class="headerlink" title="解析与填充符号表过程"></a>解析与填充符号表过程</h3><ol>
<li>词法，语法分析</li>
</ol>
<ul>
<li><p>词法分析是将源代码的字符流转变为标记(Token)集合，单个字符是程序编写过程的最小元素，而标记则是编译过程中的最小元素</p>
</li>
<li><p>语法分析是根据Token序列构造抽象语法树的过程</p>
<p>抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构    </p>
</li>
<li><p>经过这个步骤之后，编译器就基本不会再対源码文件进行操作了，后续的操作都基于抽象语法树    </p>
</li>
</ul>
<ol start="2">
<li>填充符号表</li>
</ol>
<p>符号表是由一组符号地址和符号信息构成的表格，符号表中所登记的信息在编译的不同阶段都要用到。</p>
<p>在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码。</p>
<p>在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。</p>
<h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><h2 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h2><p>语法树能够表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。</p>
<ul>
<li>标注检查步骤检查的内容包括诸如变量使用前是否被声明、变量与赋值之间的数据类型是否匹配；标注检查中还有一个重要的动作称为常量折叠。</li>
<li>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值，方法的每条路径是否都有返回值，是否所有的受查异常都被正确处理了等问题</li>
<li>解语法糖：语法糖指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用</li>
<li>字节码生成阶段不仅仅是把前面各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作</li>
</ul>
<h2 id="Java语法糖的味道"><a href="#Java语法糖的味道" class="headerlink" title="Java语法糖的味道"></a>Java语法糖的味道</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型的本质是参数化类型（Parameterized Type）或者参数化多态（Parametric Polymorphism）的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。泛型让程序员能够针对泛化的数据类型编写相同的算法，这极大地增强了编程语言的类型系统及抽象能力。</p>
<p>C#里面的泛型无论在程序源码中、编译后的 Intermediate Language 中，或是运行期的CLR中，都是切实存在的，List<int>与List<String>就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为<strong>真实泛型</strong>。</p>
<p>Java语言中的泛型则不一样，它只在程序源码中存在，编译后的字节码文件中，就已经替换为原始类型了，并且在相应的地方插入了强制类型转换。因此对于运行期的Java语言来说，ArrayList<Integer>与ArrayList<String>就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为<strong>类型擦除</strong>，基于这种方法实现的泛型称为伪泛型</p>
<p>擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。</p>
<h3 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h3><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>Java语言中条件编译的实现，也是Java语言的一颗语法糖，根据布尔常量值的真假，编译器将会把分支中不成立的代码块消除掉</p>
<h1 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h1><h2 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h2><p>Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为”热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地平台的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器JIT</p>
<h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><ul>
<li><p>热点代码：被多次调用的方法以及被多次执行的循环体（编译器都是编译整个方法）</p>
</li>
<li><p>热点探测判定方式：</p>
</li>
</ul>
<ol>
<li>基于采样的热点探测：虚拟机周期性地检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那个这个方法就是“热点方法”。<ul>
<li>优点是实现简单、高效，还可以很容易的获取方法调用关系。</li>
<li>缺点是不够精确，且容易受到线程阻塞或别的外界因素的印象而扰乱热点探测。</li>
</ul>
</li>
<li>基于计数器的热点探测：虚拟机为每个方法建立计数器，统计方法的执行次数，执行次数超过一定的阈值就认为它是热点方法<ul>
<li>实现麻烦，需要为每个方法建立并维护计数器，并且不能直接获取到方法的调用关系。</li>
<li>统计结果精确严谨。</li>
<li>默认方法调用计数器统计的并不是方法被调用的次数，而是一个相对的执行频率。当超过一定的时间限度，如果方法的调用次数仍不足以让它提交给JIT，那个这个方法的调用计数器就被减少一半，这个过程称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期。</li>
<li>回边计数器，它的作用是统计一个方法中循环体代码执行的次数，建立回边计数器的目的就是为了出发OSR编译</li>
</ul>
</li>
</ol>
<h2 id="Java与C-C-的编译器对比"><a href="#Java与C-C-的编译器对比" class="headerlink" title="Java与C/C++的编译器对比"></a>Java与C/C++的编译器对比</h2><p>即时编译器运行占用的是用户程序的运行时间，所以不可以随便引入大规模的优化技术；静态编译的时间成本不是主要关注点。</p>
<p>Java语言是动态的类型安全语言，意味着虚拟机来确保程序不会违反语言语义或访问非结构化内存。动态检查会消耗不少的运行时间。</p>
<p>虚方法的频率远大于C/C++语言，方法接收者进行多态选择的频率高于C/C++语言。即时编译器的一些优化难度较高，例如方法内联。</p>
<p>Java语言是可动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，这使得很多全局优化难以进行，因为编译器无法看到程序的全貌，许多全局优化都只能以激进优化的方式来完成，便以其不得不时刻注意并随着类型的变化而在运行时撤销或者重新进行一些优化。</p>
<p>C/C++垃圾回收不存在无用对象筛选的过程，效率较高</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E8%B5%B0%E8%BF%9B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="记录成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E8%B5%B0%E8%BF%9B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">深入理解Java虚拟机第二部分：走进内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:13:28" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><ul>
<li><strong>程序计数器</strong></li>
</ul>
<ol>
<li>定义：是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</li>
<li>作用：为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</li>
<li>如果线程执行Java方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native方法，则为空。</li>
<li>异常：程序计数器区域是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</li>
</ol>
<ul>
<li><strong>Java虚拟机栈</strong></li>
</ul>
<ol>
<li>定义：虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口信息。每个方法从调用直至运行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</li>
<li>Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。</li>
<li>异常：Java 虚拟机规范中对 Java 虚拟机栈规定了两种异常情况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverFlowError 异常; 如果虚拟机栈可以动态扩展，扩展时如果无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</li>
</ol>
<ul>
<li><strong>本地方法栈</strong><br>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</li>
<li><strong>Java堆</strong></li>
</ul>
<ol>
<li>一般来说，Java 堆是 Java 虚拟机所管理的内存中最大的一块，Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。<br>Java Heap 是垃圾收集器管理的主要区域，因此也别称为 GC 堆(Garbage Collected Heap)，收集器基本都采用分代收集算法。</li>
<li>异常：Java 堆可以处于物理上不连续的空间，只要逻辑上是连续的即可。既可以是固定大小，也可以是可扩展的，主流虚拟机都是按照可扩展来实现。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</li>
</ol>
<ul>
<li><strong>方法区</strong><br>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常<ul>
<li>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</li>
<li>运行时常量池相对于 Class 文件常量池的另外一个重要特性是具备动态性。<br>当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常</li>
</ul>
</li>
<li><strong>直接内存</strong><br>直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的区域。但是这部分内存也被频繁地使用，而且也可能会导致 OutOfMemoryError 异常出现。<br>JDK1.4 新加入了 NIO ，引入了一种基于通道与缓冲区的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。因为避免了在 Java 堆和 Native 堆中来回复制数据，有些场景可以显著提升性能。</li>
</ul>
<hr>
<h2 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h2><ul>
<li><strong>对象的创建</strong></li>
</ul>
<ol>
<li>虚拟机遇到一条 new 指令的时候，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li>
<li>类加载通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。<ul>
<li>指针碰撞：如果堆中内存是绝对规整的，分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</li>
<li>空闲列表：如果不规整则需要维护一个“空闲列表”，记录上哪些内存块是可用的。</li>
<li>并发情况下分配内存：<ol>
<li>采用 CAS 配上失败重试的方式保证更新操作的原子性。</li>
<li>分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。</li>
</ol>
</li>
</ul>
</li>
<li>对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象 GC 的分代年龄等信息。这些信息保存在对象头之中。</li>
<li>从 JVM 视角来看，一个新的对象产生了，但从 Java 程序来看，对象创建才刚刚开始–<init>方法还没有执行</li>
</ol>
<ul>
<li><strong>对象的内存布局</strong></li>
</ul>
<ol>
<li>对象头Header<ul>
<li>存储对象自身的运行时数据<ol>
<li>Hashcode</li>
<li>GC 分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ol>
</li>
<li>类型指针，即对象指向它的类的指针（并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身）。</li>
<li>如果对象是一个数组，对象头中还需要有一块用于记录数组长度的数据。</li>
</ul>
</li>
<li>实例数据<br>存储真正的有效信息，包括从父类继承的</li>
<li>对齐填充<br>并不是必然存在的，占位符，因为 HotSpot VM 的自动内存管理系统要求对象起始地址必须是<strong>8</strong>字节的整数倍</li>
</ol>
<ul>
<li><strong>对象的访问定位</strong><ol>
<li>句柄：Java 堆中会划分一块内存作为句柄池，reference 中存储的是对象的句柄地址，句柄中包含了对象的实例数据与类型数据各自的具体地址信息。<ul>
<li>优点：对象被移动(垃圾收集时移动对象时很普遍的行为)时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</li>
<li>缺点：访问对象需要两次寻址，速度慢。</li>
</ul>
</li>
<li>直接指针：Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址。（ HotSpot 使用的是直接指针的方法）</li>
</ol>
</li>
</ul>
<hr>
<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h2><ul>
<li><strong>引用计数法</strong><br>给对象添加一个引用计数器，有一个地方引用时，计数器值加一，引用失效的时候就减一。任何时刻计数器为0的对象就是不可能再被使用的<ul>
<li>优点：实现简单，判断效率高</li>
<li>缺点：Java虚拟机没有采用，是因为它很难解决对象之间相互循环引用的问题</li>
</ul>
</li>
<li><strong>可达性分析算法</strong><br>通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到 GC Roots 没有任何的引用链相连时，则证明此对象是不可用的<ul>
<li>可作为 GC Roots 的对象[全局性的引用(常量和静态属性)执行上下文(栈帧中的本地变量表)]<ol>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的<br>参数、局部变量、临时变量等。</li>
<li>方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量。</li>
<li>方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>
<li>本地方法栈中 JNI (一般来说的 Native 方法)引用的对象</li>
</ol>
</li>
</ul>
</li>
<li><strong>再谈引用</strong><ol>
<li>强引用：在程序代码中普遍存在的，类似 Object obj = new Object(); 只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用：用来描述一些还有用但是非必需的对象。在系统将要发生内存溢出异常之前，将会把软引用列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li>
<li>弱引用：也是描述非必需对象的，比软引用更弱一些。下一次垃圾回收就会回收掉只被弱引用关联的对象。</li>
<li>虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知.</li>
</ol>
</li>
<li><strong>生存还是死亡</strong><br>可达性分析算法中不可达的对象需要经过两次标记过程：<ol>
<li>第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法，当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则视为“没有必要执行”。</li>
<li>判定为有必要执行 finalize() 方法，会将这个对象放入一个叫做 F-Queue 的队列，并在稍后自动创建一个低优先级的 Finalizer 线程去执行，如果对象在 finalize() 方法中拯救自己，就会被移除“即将回收”集合，否则回收。</li>
</ol>
</li>
<li><strong>回收方法区</strong><ol>
<li>废弃常量</li>
<li>无用的类<ul>
<li>该类所有的实例已经被回收,也就是 Java 堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器已经被回收。(很难判断)</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><ul>
<li><strong>标记-删除算法</strong><br>缺点：<ol>
<li>执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li>
<li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ol>
</li>
<li><strong>标记-复制算法</strong><ol>
<li>使用一半的内存空间，每次将存活的对象复制到空的另一半然后清空。</li>
<li>新生代中的对象 98% 很快消亡，所以没必要浪费一半的空间。把内存空间分成一个 Eden(80%) 和两个 survivor(10%) ,每次使用 Eden 和 一个survivor 空间，剩下一个 survivor 用来复制</li>
<li>没有办法保证每次回收都有不多于10%的对象存活，当 survivor 空间不够用时，需要依赖其他内存(老年代)进行分配担保。</li>
</ol>
</li>
<li><strong>标记-整理算法</strong><br>针对老年代复制算法的效率变低。采用“标记-整理”算法，标记之后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后清理掉边界以外的内存。<br>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，需要“Stop The World” </li>
</ul>
<hr>
<h2 id="HotSpot-的算法细节实现"><a href="#HotSpot-的算法细节实现" class="headerlink" title="HotSpot 的算法细节实现"></a>HotSpot 的算法细节实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><ol>
<li>GC 停顿<br>在进行可达性分析的时候，必须在一个能确保一致性的快照中进行。“一致性”指的是在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况。</li>
<li>准确式 GC<br>执行系统停顿下来后并不需要一个不漏地检查完所有的执行上下文和全局变量的引用位置。<br>HotSpot 采用 OopMap 的数据结构来记录对象引用的位置。在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。在 OopMap 的协助下，HotSpot 可以快速且准确的完成 GC 。</li>
</ol>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><ol>
<li>引用变化非常频繁，如果为每一条指令都生成对应的 OopMap ，GC 的空间成本太高。</li>
<li>HotSpot 只是在特定的位置记录了这些信息，叫做 “SafePoint”，SafePoint 的选取不能太少也不能太多。选定是以“是否具有让程序长时间执行的特征”为标准选定的。</li>
<li>如何在 GC 发生时让所有的线程停下来<ul>
<li>抢先式中断：首先把所有线程全部中断，然后发现有线程不在安全点上，则恢复线程让它跑到安全点上，几乎没有虚拟机采用这个方式来响应 GC 事件。</li>
<li>主动式中断：设置一个标志，各个线程主动的去轮询这个标志，发现中断标志为真的时候就自己中断挂起</li>
</ul>
</li>
</ol>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>程序执行的时候可以根据安全点进行中断，但是没有获得CPU的程序就需要安全区域来解决，安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。</p>
<h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。<br>卡表最简单的形式可以只是一个字节数组。</p>
<p><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">从实际案例聊聊Java应用的GC优化</a><br>老年代中引用新生代，解决的方案是使用卡表，而不是每次 Minor GC 的时候扫描老年代。<br>新生代引用老年代，解决方案是老年代回收前，先对新生代进行一次 Minor GC 。</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>在 HotSpot 虚拟机里是通过写屏障（Write Barrier）技术<strong>维护卡表状态</strong>的。<br>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的 AOP 切面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值后的则叫作写后屏障（Post-Write Barrier）</p>
<h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><h4 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h4><ul>
<li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
<li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li>
<li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</li>
</ul>
<ul>
<li><p>因为用户线程与收集器是并发工作。收集器在对象图上标记颜色，同时用户线程在修改引用关系——即修改对象图的结构，这样可能出现两种后果：</p>
<pre><code>1. 把原本消亡的对象错误标记为存活，产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。</code></pre><ol start="2">
<li>把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误。</li>
</ol>
</li>
<li><p>导致“对象消失”的问题的两个条件：</p>
<pre><code>1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用；</code></pre><ol start="2">
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ol>
</li>
<li><p>两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。<br>（CMS 采用增量更新，G1 采用原始快照）  </p>
<ol>
<li>增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</li>
<li>原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><ol>
<li><strong>Serial 收集器</strong></li>
</ol>
<ul>
<li>单线程，并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它收集垃圾时，必须暂停其他所有的工作线程。</li>
<li>新生代采用复制算法，老年代采用标记整理算法，是虚拟机运行在 Client 模式下的默认新生代收集器</li>
</ul>
<ol start="2">
<li><strong>ParNew 收集器</strong></li>
</ol>
<ul>
<li>Serial 收集器的多线程版本</li>
<li>目前只有它与 CMS 收集器配合工作，CMS 作为老年代的收集器，ParNew 作为新生代的收集器。</li>
</ul>
<ol start="3">
<li><strong>Parallel Scavenge</strong></li>
</ol>
<ul>
<li>采用复制算法，并行的多线程新生代收集器，其关注点和其他收集器不同，CMS 收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge关注点是达到一个可控制的吞吐量。</li>
<li>停顿时间短适合与用户交互，高吞度量则可以高效率地利用 CPU 时间，适合在后台运算。</li>
</ul>
<ol start="4">
<li><strong>Serial Old 收集器</strong></li>
</ol>
<ul>
<li>单线程标记整理算法，主要意义在于给 Client 模式下的虚拟机使用</li>
<li>JDK1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用</li>
<li>作为 CMS 收集器的后备预案，并发收集发生Concurrent Mode Failure时使用</li>
</ul>
<ol start="5">
<li><strong>Parallel Old收集器</strong></li>
</ol>
<ul>
<li>多线程标记整理算法, JDK1.6 之后开始提供</li>
<li>搭配 Parallel Scavenge 在注重吞吐量和 CPU 资源敏感的工作场合</li>
</ul>
<ol start="6">
<li><strong>CMS（Concurrent Mark Sweep）收集器</strong></li>
</ol>
<ul>
<li>运行流程<ol>
<li>初始标记：仅仅标记 GC Roots 能直接关联到的对象，速度很快，需要Stop The World</li>
<li>并发标记：进行 GC Roots Tracing，相对耗时，但是是和用户线程并发运行</li>
<li>重新标记<ul>
<li>修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记稍慢，远比并发标记的时间短。</li>
<li>这个阶段是以新生代中对象为根来判断对象是否存活的</li>
<li>新生代对象持有老年代中对象的引用，这种情况称为“跨代引用”。因它的存在，Remark阶段必须扫描整个堆来判断对象是否存活</li>
<li>新生代的部分对象已经不可达，但仍然需要扫描的原因：新生代 GC 和老年代的 GC 是各自分开独立进行的，只有 Minor GC 时才会使用根搜索算法，标记新生代对象是否可达，也就是说虽然一些对象已经不可达，但在 Minor GC 发生前不会被标记为不可达，CMS 也无法辨认哪些对象存活，只能全堆扫描（新生代+老年代）。</li>
<li>新生代中对象的特点是“朝生夕灭”，这样如果 Remark 前执行一次 Minor GC，大部分对象就会被回收。CMS 就采用了这样的方式，在 Remark 前增加了一个可中断的并发预清理（CMS-concurrent-abortable-preclean），该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。如果此阶段执行时等到了 Minor GC，那么上述灰色对象将被回收，Remark 阶段需要扫描的对象就少了。除此之外 CMS 为了避免这个阶段没有等到 Minor GC 而陷入无限等待，提供了参数CMSMaxAbortablePrecleanTime，默认为5s，含义是如果可中断的预清理执行超过5s，不管发没发生 Minor GC 都会中止此阶段，进入Remark。</li>
<li>JVM 是如何避免 Minor GC 时扫描全堆的？卡表的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。卡表被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后 Minor GC 时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。</li>
<li>什么时候可能会触发 STW 的 FullGC 呢？<ol>
<li>Perm空间不足；</li>
<li>CMS GC 时出现 promotionfailed 和 concurrentmodefailure（concurrentmodefailure发生的原因一般是 CMS 正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止 CMS ，直接进行 SerialOld GC）；</li>
<li>统计得到的 YoungGC 晋升到老年代的平均大小大于老年代的剩余空间</li>
<li>主动触发 Full GC（执行jmap-histo:live [pid]）来避免碎片问题。</li>
</ol>
</li>
</ul>
</li>
<li>并发清除：可以和用户线程并发运行</li>
</ol>
</li>
<li>CMS 的缺点<ol>
<li>CMS 收集器对 CPU 资源非常敏感</li>
<li>CMS 收集器无法处理浮动垃圾，可能出现 Concurrent Mode Failure 而导致另一次Full GC 的发生<ul>
<li>浮动垃圾：CMS 在并发清除阶段，此刻并发运行的用户线程产生的垃圾只能下一次 GC 的时候回收</li>
<li>也是因为在垃圾收集阶段用户线程在需要运行，所以需要预留一部分空间提供并发收集时的程序运作使用</li>
<li>预留的内存无法满足程序需求就会出现 CMF ，此刻需要临时启用 Serial Old 重新进行老年代的垃圾收集</li>
</ul>
</li>
<li>标记清除算法容易产生空间碎片导致大对象没有足够的空间分配，不得不提前触发一次 Full GC。</li>
</ol>
</li>
</ul>
<ol start="7">
<li><strong>G1收集器</strong></li>
</ol>
<ul>
<li><strong>Mixed GC</strong><br>G1 可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是 G1 收集器的 Mixed GC 模式。</li>
<li><strong>Region</strong><br>G1把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。</li>
<li><strong>Why Garbage First ？</strong></li>
</ul>
<ol>
<li>G1 收集器之所以能建立可预测的停顿时间模型，是因为它将 Region 作为单次回收的最小单元，即每次收集到的内存空间都是 Region 大小的整数倍，这样可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。</li>
<li>更具体的处理思路是让 G1 收集器去跟踪各个 Region 里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。</li>
</ol>
<ul>
<li><strong>Region里面存在的跨Region引用对象如何解决？</strong><br>使用记忆集避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集（哈希表），这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。</li>
<li><strong>并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</strong><ol>
<li>解决的是用户线程改变对象引用关系时，必须保证其不能打破原本的对象图结构，导致标记结果出现错误。解决方案是原始快照。</li>
<li>垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，G1 为每一个 Region 设计了两个名为 TAMS（Top at Mark Start）的指针，把 Region 中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1 收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。</li>
</ol>
</li>
<li><strong>G1收集器的运作过程</strong></li>
</ul>
<ol>
<li>初始标记<br>仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC 的时候同步完成的，所以 G1 收集器在这个阶段实际并没有额外的停顿。</li>
<li>并发标记<br>从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li>
<li>最终标记<br>对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li>
<li>筛选回收<br>负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ol>
<ul>
<li><strong>G1的美中不足</strong><br>在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。</li>
</ul>
<hr>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ul>
<li><strong>对象优先在Eden分配</strong><br>1Eden2Survivor，其中1Eden1Survivor用来分配，剩下的一个Survivor用来GC的时候复制。同时老年代区域为新生代区域担保。<br>当Eden区没有足够的空间进行分配，虚拟机会进行一次Minor GC</li>
<li><strong>大对象直接进入老年代</strong></li>
</ul>
<p>-XX:PretenureSizeThreshold,令大于这个设置值的对象直接在老年代分配<br>目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。</p>
<ul>
<li><strong>长期存活的对象将进入老年代</strong><br>虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象的年龄设为1，对象在Survivor区中每“熬过”一次Minor GC，年龄就增加一岁。–XX:MaxTenuringThreshold</li>
<li><strong>动态对象年龄判定</strong><br>并不是永远地要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象的大小超过Survivor空间的一半，那么年龄大于等于该年龄的对象就可以直接进入老年代</li>
<li><strong>空间分配担保</strong></li>
</ul>
<ol>
<li><p>发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么 Minor GC 是绝对安全的。</p>
</li>
<li><p>HandlePromotionFailure 设置值是否允许担保失败：</p>
<ul>
<li>如果允许，会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次 Minor GC，尽管这个 GC 是有风险的。</li>
<li>出现担保失败，就只好在失败后进行一次 Full GC</li>
<li>如果小于，或者 HandlePromotionFailure 设置不允许冒险，则进行一次 Full GC</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="记录成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">深入理解Java虚拟机第三部分：虚拟机执行子系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:13:45" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h2 id="无关系的基石"><a href="#无关系的基石" class="headerlink" title="无关系的基石"></a>无关系的基石</h2><p>实现语言无关性的基石是<strong>虚拟机</strong>和<strong>字节码存储格式</strong>。 Java 虚拟机不与任何包括 Java 在内的语言绑定，它只与“ Class 文件”这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集和符号表以及若干其他辅助信息。</p>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>Class文件是一组以8字节为基础单位的<strong>二进制流</strong>。// 包括但不限于磁盘文件、网络、数据库、内存或者动态产生等。</p>
<p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：</p>
<ul>
<li>无符号数：基本的数据类型，1,2,4,8个字节，可以用来描述数字、索引引用、数量值或者UTF-8编码构成字符串值。</li>
<li>表：表是由多个无符号数或者其他表作为数据项构成的复合结构，习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。</li>
</ul>
<h3 id="魔数和Class文件的版本"><a href="#魔数和Class文件的版本" class="headerlink" title="魔数和Class文件的版本"></a>魔数和Class文件的版本</h3><p>Class 文件的头四个字节称为 Magic Number，它的唯一的作用就是确定这个文件是否是一个能被虚拟机接收的Class 文件(类似于文件后缀的作用)。0xCAFEBABY</p>
<p>紧接着魔数的4个字节存储的是 Class 文件的版本号，前两个字节是次版本，后两个是主版本。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>主次版本号之后的是常量池入口，可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，也是 Class 文件中第一个出现的表类型数据项目。</p>
<p>常量池主要存放两大类常量：<strong>字面量</strong> (Literal) 和<strong>符号引用</strong> (Symbolic References)</p>
<ul>
<li><p>字面量接近于Java语言层面的常量概念，如文本字符串、声明为 final 的常量值。</p>
</li>
<li><p>符号引用则属于编译原理方面的概念：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
<p>常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不同，这个容量计数是从1而不是0开始的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。</p>
<p>常量池中每一项常量都是一个表，截止 JDK13 常量表中分别有17种不同类型的常量，他们的表结构起始的第一位是个 u1 类型的标志位，代表着当前常量属于哪种常量类型。</p>
<p>例如  u1 类型的标志位中为7，可知这个常量属于 CONSTANT_Class_info 类型，此类型的常量代表一个类或者接口的符号引用。他的结构为一个 u1 类型的 tag 和一个 u2 类型的 name_index。tag是标志位，它用于区分常量类型；name_index 是常量池的索引值，它指向常量池中一个 CONSTANT_Utf8_info 类型常量，此常量代表了这个类（或者接口）的全限定名。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等</p>
<h3 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h3><p>类索引和父类索引都是一个u2类型的数据，接口索引集合是一组u2类型的数据，Class文件中由这三项数据来确定该类型的继承关系。</p>
<p>u2类型的数据指向一个CONSTANT_Class_info的类描述符常量，通过常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表（field_info）用于描述接口或者类中声明的变量，包括类级变量以及实例变量，但是不包括方法内部声明的局部变量。</p>
<p>字段表结构：依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。</p>
<p>字段可以包括的修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。</p>
<p>而字段叫做什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p>
<ul>
<li>全限定名，“org/fenixsoft/clazz/TestClass”</li>
<li>简单名称(name_index)则就是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。</li>
<li>方法和字段的描述符：作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</li>
</ul>
<p>字段表所包含的固定数据项目到 descriptor_index 为止就全部结束了，不过在 descriptor_index 之后跟随着一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。(ConstantValue)</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>结构和字段表几乎完全一致。</p>
<p>方法里的 Java 代码，经过 Javac 编译器编译成字节码指令之后，存放在方法属性表集合中一个名为 “Code” 的属性里面。</p>
<p>父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><h2 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h2><h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><ul>
<li>类从被加载到虚拟机内存直到卸载出内存的<strong>生命周期</strong></li>
</ul>
<ol>
<li>加载</li>
<li>连接<ol>
<li>验证</li>
<li>准备</li>
<li>解析：解析阶段不一定会按照顺序，为了支持 Java 语言的运行时绑定</li>
</ol>
</li>
<li>使用</li>
<li>卸载</li>
</ol>
<ul>
<li>有且只有六种情况必须立即对类进行“初始化”</li>
</ul>
<ol>
<li><p>遇到new、getstatic、putstatic或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。</p>
<ol>
<li>使用 new 关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ol>
</li>
<li><p>使用 java.lang.reflect 包的方法进行反射调用时，如果类型没有进行过初始化，则需要先触发其初始化。</p>
</li>
<li><p>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。</p>
</li>
<li><p>当使用JDK 7新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>
</li>
<li><p>当一个接口中定义了JDK 8新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p>
</li>
</ol>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。文件格式验证之后，字节流会进入内存的方法区中，所有之后的验证都是基于方法区的存储结构进行的。</p>
<ol>
<li><p><strong>文件格式验证</strong></p>
<ul>
<li>是否以魔数 0xCAFEBABE 开头。</li>
<li>主、次版本号是否在当前 Java 虚拟机接受范围之内。</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF-8 编码的数据。</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>
</ul>
</li>
<li><p><strong>元数据验证：对字节码描述的信息进行语义分析，保证符合 Java 语义规范</strong></p>
<ul>
<li>这个类是否有父类（除了 java.lang.Object 之外，所有的类都应当有父类）。</li>
<li>这个类的父类是否继承了不允许被继承的类（被 final 修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 final 字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li>
</ul>
</li>
<li><p><strong>字节码验证：目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</strong></p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按 long 类型来加载入本地变量表中”这样的情况。</li>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li>
</ul>
</li>
<li><p><strong>符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段-解析阶段发生，可以看做是对类自身以外的信息(常量池中的各种符号引用)进行匹配校验</strong></p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当<br>前类访问。</li>
</ul>
</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段</strong>。从概念上讲，这些变量所使用的内存都应当在<strong>方法区</strong>中进行分配，但必须注意到方法区本身是一个<strong>逻辑</strong>上的区域。在JDK 7及之前，HotSpot 使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 8及之后，类变量则会随着 Class 对象一起存放在 Java 堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。</p>
<ul>
<li>这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。初始值“通常情况”下是数据类型的零值，如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。final</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。</li>
<li>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。</li>
</ul>
<p>虚拟机可以根据需要选择在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段就是执行类构造器<clinit>()方法的过程。<clinit>()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。</p>
<p><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”，是在 Java 虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul>
<li><p>从 Java 虚拟机角度，只存在两种不同的类加载器：</p>
<ol>
<li>启动类加载器，由C++语言实现，是虚拟机自身的一部分</li>
<li>其他所有的类加载器，由 Java 语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader</li>
</ol>
</li>
<li><p>Java开发人员的角度：</p>
<ol>
<li>启动类加载器：负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且被虚拟机识别的类库加载到虚拟机内存中。</li>
<li>扩展类加载器：负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有的类，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（系统类加载器）：负责加载用户类路径上所指定的类库，开发者可以直接使用应用程序类加载器。应用程序中如果没有自定义过自己的类加载器，一般情况下这个就是程序中的默认类加载器。</li>
</ol>
</li>
</ul>
<p>不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>
<p><strong>双亲委派模型的工作过程</strong>：</p>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p>
<p><strong>双亲委派模型的优点</strong>：</p>
<p>使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是 Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>
<hr>
<h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择或者两者兼备，但是从外观上看所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>Java 虚拟机以方法作为最基本的执行单元，栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。</p>
<ul>
<li><p>每一个栈帧都包括了局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息。</p>
</li>
<li><p>栈帧中需要多大的局部变量表，多深的操作数栈在编译程序代码之后就已经完全确定了，并且写入方法表的Code属性之中。</p>
</li>
<li><p>对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧。 </p>
</li>
</ul>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。</p>
<p>局部变量表的容量以变量槽(VariableSlot, Slot)为最小单位，虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的 Slot 数量。(在 Java 程序被编译为 Class 文件时，就在方法的 Code 属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量)</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>做算术运算是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的</p>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p>
<p>Class 文件的常量池中存有大量的符号引用，<strong>字节码中的方法调用指令</strong>就以常量池里指向方法的<strong>符号引用</strong>作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为<strong>静态解析</strong>。<br>另外一部分将在每一次运行期间都转化为直接引用，这部分就称为<strong>动态连接</strong>。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>正常完成出口：一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。</p>
<p>异常完成出口：方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p>
<p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：</p>
<ol>
<li><p>恢复上层方法的局部变量表和操作数栈</p>
</li>
<li><p>把返回值压入调用者栈帧的操作数栈中</p>
</li>
<li><p>调整PC计数器的值以指向方法调用指令后面的一条指令</p>
</li>
</ol>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是<strong>确定被调用的版本</strong>，暂时还不涉及方法内部的具体运行过程。</p>
<p>Class 文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址(直接引用),这个特性给 Java 带来了更强大的动态扩展能力。</p>
<h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用的目标方法在 Class 文件里面都是一个常量池中的<strong>符号引用</strong>，在类加载的<strong>解析</strong>阶段，会将其中的一<strong>部分符号引用转化为直接引用</strong>。</p>
<p>这种解析能够成立的前提是：该方法“<strong>编译期可知，运行期不可变</strong>”，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。</p>
<p>在Java虚拟机支持以下5条方法调用字节码指令，分别是：</p>
<ol>
<li>invokestatic。用于调用静态方法。</li>
<li>invokespecial。用于调用实例构造器<init>()方法、私有方法和父类中的方法。</li>
<li>invokevirtual。用于调用所有的虚方法。</li>
<li>invokeinterface。用于调用接口方法，会在运行时再确定一个实现该接口的对象。</li>
<li>invokedynamic。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。</li>
</ol>
<p>只要能被<strong>invokestatic</strong>和<strong>invokespecial</strong>指令调用的方法，都可以在<strong>解析阶段中确定唯一的调用版本</strong>，Java语言里符合这个条件的方法共有<strong>静态方法</strong>、<strong>私有方法</strong>、<strong>实例构造器</strong>、<strong>父类</strong>方法4种，再加上被<strong>final</strong>修饰的方法（尽管它使用invokevirtual指令调用），<strong>这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用</strong>。这些方法统称为“非虚方法”（Non-Virtual Method），与之相反，其他方法就被称为“虚方法”（Virtual Method）。</p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><ul>
<li><strong>静态分派</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方法静态分派演示</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello,guy!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello,gentleman!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello,lady!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Human man = <span class="keyword">new</span> Man();</span><br><span class="line">		Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">		StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">		sr.sayHello(man);	<span class="comment">//hello,guy!</span></span><br><span class="line">		sr.sayHello(woman);	<span class="comment">//hello,guy!</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，<strong>变量本身的静态类型不会被改变</strong>，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line">Human human = (<span class="keyword">new</span> Random()).nextBoolean() ? <span class="keyword">new</span> Man() : <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">sr.sayHello((Man) human)</span><br><span class="line">sr.sayHello((Woman) human)</span><br><span class="line"><span class="comment">//human的静态类型是Human，也可以在使用时（如sayHello()方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的，两次sayHello()方法的调用，在编译期完全可以明确转型的是Man还是Woman。</span></span><br></pre></td></tr></table></figure>

<p>编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的。由于静态类型在编译期可知，所以在编译阶段，Javac 编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了 sayHello(Human) 作为调用目标，并把这个方法的符号引用写到 main() 方法里的两条 invokevirtual 指令的参数中。</p>
<p>所有<strong>依赖静态类型来决定方法执行版本的分派动作，都称为静态分派</strong>。静态分派的最典型应用表现就是<strong>方法重载</strong>。静态分派发生在编译阶段。</p>
<ul>
<li><strong>动态分派</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方法动态分派演示</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"man say hello"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"woman say hello"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Human man = <span class="keyword">new</span> Man();</span><br><span class="line">		Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();<span class="comment">//man say hello</span></span><br><span class="line">		woman.sayHello();<span class="comment">//woman say hello</span></span><br><span class="line">		man = <span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();<span class="comment">//woman say hello</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invokevirtual 指令的运行时解析过程：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回 java.lang.IllegalAccessError 异常。</li>
<li>否则，按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。</li>
</ol>
<p>正是因为 invokevirtual 指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的 invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会<strong>根据方法接收者的实际类型来选择方法版本</strong>，这个过程就是Java语言中方法<strong>重写</strong>的本质。我们把这种在<strong>运行期根据实际类型确定方法执行版本的分派过程称为动态分派</strong>。</p>
<h3 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h3><p>动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的方法元数据中搜索合适的目标方法，因此，Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地去反复搜索类型元数据。面对这种情况，一种基础而且常见的优化手段是为类型在方法区中建立一个虚方法表（Virtual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表——Interface Method Table，简称itable），使用虚方法表索引来代替元数据查找以提高性能。虚方法表中存放着各个方法的实际入口地址。</p>
<h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p>Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。</p>
<h3 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h3><p>基于栈的指令集主要优点是可移植，程序不直接依赖这些硬件寄存器，避免受到硬件的约束。</p>
<p>栈架构指令集的主要缺点是理论上执行速度相对来说会稍慢一些，不过这里的执行速度是要局限在解释执行的状态下，如果经过即时编译器输出成物理机上的汇编指令流，那就与虚拟机采用哪种指令集架构没有什么关系了。</p>
<p>在解释执行时，<strong>栈架构</strong>指令集的代码虽然紧凑，但是完成相同功能所需的<strong>指令数量</strong>一般会比寄存器架构来得更多，因为出栈、入栈操作本身就产生了相当大量的指令。<strong>更重要的是栈实现在内存中</strong>，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取<strong>栈顶缓存</strong>的优化方法，把最常用的操作映射到寄存器中避免直接内存访问，但这也只是优化措施而不是解决本质问题的方法。因此由于<strong>指令数量和内存访问的原因</strong>，导致了栈架构指令集的执行速度会相对慢上一点。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Java%20%E5%AE%B9%E5%99%A8/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="记录成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Java%20%E5%AE%B9%E5%99%A8/HashMap/" class="post-title-link" itemprop="url">HashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:13:04" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">Java 容器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>java.util.Map 的实现类主要有四个常用的：HashMap、Hashtable、LinkedHashMap和TreeMap</p>
<p>(1) HashMap：<strong>遍历顺序不确定</strong>， HashMap最多只<strong>允许一条记录的</strong>键为null。HashMap非线程安全。</p>
<p>(2) Hashtable：<strong>线程安全的</strong>(sync)，Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<p>(3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的<strong>插入顺序</strong>，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
<p>(4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是<strong>按键值的升序排序</strong>，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
<p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p>
<h2 id="存储结构字段"><a href="#存储结构字段" class="headerlink" title="存储结构字段"></a>存储结构字段</h2><ol>
<li>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用<strong>开放地址法</strong>和<strong>链地址法</strong>等来解决问题，Java中HashMap采用了链地址法。</li>
</ol>
<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在<strong>空间成本和时间成本</strong>之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是<strong>好的Hash算法和扩容机制</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">int</span> modCount;  <span class="comment">//记录HashMap内部结构发生变化的次数</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<p>Node[] table的初始化长度length(默认值是<strong>16</strong>)，Load factor为负载因子(默认值是<strong>0.75</strong>)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的<strong>两倍</strong>。<strong>默认的负载因子0.75是对空间和时间效率的一个平衡选择</strong>，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果<strong>内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值</strong>；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<p>哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数。<strong>当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</strong></p>
<p>负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。</p>
<h2 id="功能实现-方法"><a href="#功能实现-方法" class="headerlink" title="功能实现-方法"></a>功能实现-方法</h2><h3 id="1-确定哈希桶数组索引位置"><a href="#1-确定哈希桶数组索引位置" class="headerlink" title="1. 确定哈希桶数组索引位置"></a>1. 确定哈希桶数组索引位置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p>
<p><img src="https://github.com/Wayne-98/image/blob/master/Java%20%E5%AE%B9%E5%99%A8/hash.png?raw=true" alt=""></p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (<strong>h &gt;&gt;&gt; 16</strong>)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到<strong>高低Bit都参与到Hash的</strong>计算中，同时不会有太大的开销。</p>
<h2 id="2-分析HashMap的put方法"><a href="#2-分析HashMap的put方法" class="headerlink" title="2. 分析HashMap的put方法"></a>2. 分析HashMap的put方法</h2><p><img src="https://github.com/Wayne-98/image/blob/master/Java%20%E5%AE%B9%E5%99%A8/put.png?raw=true" alt=""></p>
<h2 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a>3. 扩容机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line"> <span class="number">2</span>     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line"> <span class="number">4</span>     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line"> <span class="number">5</span>         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line"> <span class="number">6</span>         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">7</span>     &#125;</span><br><span class="line"> <span class="number">8</span>  </span><br><span class="line"> <span class="number">9</span>     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line"><span class="number">10</span>     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line"><span class="number">11</span>     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line"><span class="number">12</span>     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line"> <span class="number">5</span>         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line"> <span class="number">6</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">7</span>             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line"> <span class="number">8</span>             <span class="keyword">do</span> &#123;</span><br><span class="line"> <span class="number">9</span>                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line"><span class="number">10</span>                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line"><span class="number">11</span>                 e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line"><span class="number">12</span>                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line"><span class="number">13</span>                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line"><span class="number">14</span>             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line"><span class="number">15</span>         &#125;</span><br><span class="line"><span class="number">16</span>     &#125;</span><br><span class="line"><span class="number">17</span> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/Wayne-98/image/blob/master/Java%20%E5%AE%B9%E5%99%A8/transfer.png?raw=true" alt=""></p>
<p>我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="https://github.com/Wayne-98/image/blob/master/Java%20%E5%AE%B9%E5%99%A8/reHash.png?raw=true" alt=""></p>
<p><img src="https://github.com/Wayne-98/image/blob/master/Java%20%E5%AE%B9%E5%99%A8/OldCap.png?raw=true" alt=""></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p>
<h3 id="HashMap-线程不安全"><a href="#HashMap-线程不安全" class="headerlink" title="HashMap 线程不安全"></a>HashMap 线程不安全</h3><p>并发的多线程使用场景中使用HashMap可能造成死循环。主要是多线程同时put时，如果同时触发了rehash操作，会导致HashMap中的链表中出现循环节点，进而使得后面get的时候，会死循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">"C"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread1"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">"B"</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread2"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">"A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>





<p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">主要参考与美团的文章：Java 8系列之重新认识HashMap</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Java%20%E5%AE%B9%E5%99%A8/ConcurrentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="记录成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Java%20%E5%AE%B9%E5%99%A8/ConcurrentHashMap/" class="post-title-link" itemprop="url">ConcurrentHashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:12:53" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-%E5%AE%B9%E5%99%A8/" itemprop="url" rel="index"><span itemprop="name">Java 容器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树,相对而言，总结如下思考</p>
<ol>
<li><p>JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）</p>
</li>
<li><p>JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了</p>
</li>
<li><p>JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档</p>
</li>
<li><p>JDK1.8为什么使用内置锁synchronized来代替重入锁ReentrantLock，我觉得有以下几点 </p>
<ul>
<li><p>因为粒度降低了，在相对而言的低粒度加锁方式，synchronized并不比ReentrantLock差，在粗粒度加锁中ReentrantLock可能通过Condition来控制各个低粒度的边界，更加的灵活，而在低粒度中，Condition的优势就没有了</p>
</li>
<li><p>JVM的开发团队从来都没有放弃synchronized，而且基于JVM的synchronized优化空间更大，使用内嵌的关键字比使用API更加自然</p>
</li>
<li><p>在大量的数据操作下，对于JVM的内存压力，基于API的ReentrantLock会开销更多的内存，虽然不是瓶颈，但是也是一个选择依据</p>
</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wayne-98.github.io/2020/05/10/Java%20Concurrent/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9AJava%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/808.jpg">
      <meta itemprop="name" content="Wayne">
      <meta itemprop="description" content="记录成长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wayne">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/10/Java%20Concurrent/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9AJava%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Java并发编程的艺术 第二章：Java并发机制的底层实现原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-10 21:39:10 / 修改时间：22:12:01" itemprop="dateCreated datePublished" datetime="2020-05-10T21:39:10+08:00">2020-05-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Concurrent/" itemprop="url" rel="index"><span itemprop="name">Java Concurrent</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Java并发编程的艺术-第二章"><a href="#Java并发编程的艺术-第二章" class="headerlink" title="Java并发编程的艺术 第二章"></a>Java并发编程的艺术 第二章</h1><p>Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在CPU上执行，Java中所使用的并发机制依赖于<strong>JVM的实现</strong>和<strong>CPU的指令</strong>。</p>
<h2 id="volatile的应用"><a href="#volatile的应用" class="headerlink" title="volatile的应用"></a>volatile的应用</h2><h3 id="volatile的定义以及实现原理"><a href="#volatile的定义以及实现原理" class="headerlink" title="volatile的定义以及实现原理"></a>volatile的定义以及实现原理</h3><ul>
<li><strong>有什么作用？</strong><br>Java线程内存模型确保所有线程看到这个变量的值是一致的。</li>
<li><strong>volatile是如何来保证可见性的呢？</strong><ol>
<li>将当前处理器缓存行的数据写回到系统内存。<br>（Lock前缀指令会引起处理器缓存回写到内存。）</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。<br>（一个处理器的缓存回写到内存会导致其他处理器的缓存无效。）</li>
</ol>
</li>
<li><strong>缓存一致性协议</strong><br>每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是不是过期了，这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。</li>
</ul>
<hr>
<h2 id="synchronized的实现原理与应用"><a href="#synchronized的实现原理与应用" class="headerlink" title="synchronized的实现原理与应用"></a>synchronized的实现原理与应用</h2><ul>
<li><p><strong>实现的基础</strong><br>Java中的每一个对象都可以作为锁。</p>
<ol>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的Class对象。</li>
<li>对于同步方法块，锁是Synchronized括号里配置的对象。</li>
</ol>
</li>
</ul>
<p>当一个线程访问同步代码块时，必须得到锁，退出或抛出异常时必须释放锁。</p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><ul>
<li><p><strong>synchronized用的锁是存在Java对象头里的</strong></p>
<ol>
<li>Mark Word<br>存储对象的 HashCode、分代年龄和锁标记位</li>
<li>Class Metadata Address<br>存储到对象类型的指针</li>
<li>Array Length<br>如果是数组对象，则需要记录数组的长度</li>
</ol>
<hr>
</li>
<li><p><strong>Mark Word的存储格式</strong><br>在32位系统上mark word长度为32bit，64位系统上长度为64bit。<br>为了能在有限的空间里存储下更多的数据，其存储格式是不固定的，在32位系统上各状态的格式如下：<br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/MarkWord.png?raw=true" alt=""><br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/MarkWord1.png?raw=true" alt=""></p>
</li>
</ul>
<ol>
<li>当对象状态为偏向锁（biasable）时，mark word 存储的是偏向的线程 ID；</li>
<li>当状态为轻量级锁（lightweight locked）时，mark word存储的是指向线程栈中Lock Record的指针；</li>
<li>当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</li>
</ol>
<hr>
<ul>
<li><strong>Synchonized在JVM里的实现原理</strong><br><code>javap -v 查看class文件对应的JVM字节码信息.</code><br>对于synchronized关键字而言，javac在编译时，会生成对应的monitorenter和monitorexit指令分别对应synchronized同步块的进入和退出<ul>
<li><strong>synchronized 修饰一个同步块的时候</strong><br>一个monitorenter指令和两个monitorexit指令。<ul>
<li>原因是：为了保证抛异常的情况下也能释放锁，所以javac为同步代码块添加了一个隐式的try-finally，在finally中会调用monitorexit命令释放锁。<ul>
<li><strong>synchronized 修饰一个方法的时候</strong><br>javac为其生成了一个ACC_SYNCHRONIZED关键字，在JVM进行方法调用时，发现调用的方法被ACC_SYNCHRONIZED修饰，则会先尝试获得锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="锁的升级与对比"><a href="#锁的升级与对比" class="headerlink" title="锁的升级与对比"></a>锁的升级与对比</h3><ul>
<li><p><strong>锁的状态</strong></p>
<p>  无锁状态–&gt;偏向锁状态–&gt;轻量级锁状态–&gt;重量级锁状态<br>  锁可以升级但是不可以降级（为了提高锁获得和锁释放的效率）</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>重量级锁</strong><br>重量级锁是我们常说的传统意义上的锁，其利用操作系统底层的同步机制去实现Java中的线程同步。<br>重量级锁的状态下，对象的mark word为指向一个堆中monitor对象的指针。<br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/Monitor.png?raw=true" alt=""></p>
</li>
<li><p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p>
</li>
<li><p>Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中；</p>
</li>
<li><p>Wait Set：哪些调用wait方法被阻塞的线程被放置在这里；</p>
</li>
<li><p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被称为OnDeck；</p>
</li>
<li><p>Owner：当前已经获取到所资源的线程被称为Owner；</p>
</li>
<li><p>!Owner：当前释放锁的线程。</p>
</li>
</ul>
<hr>
<ul>
<li><p>线程获取重量级锁的过程</p>
<ul>
<li>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到Contention List的队列尾部，然后暂停当前线程；</li>
<li>当持有锁的线程释放锁前，会将Contention List中的所有元素移动到Entry List中去，并唤醒Entry List的队首线程。</li>
<li>如果一个线程在同步块中调用了Object#wait方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁；</li>
<li>当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</li>
</ul>
<hr>
</li>
<li><p><strong>轻量级锁</strong></p>
<ul>
<li><strong>为什么引入轻量级锁？</strong><br>  在 Java 程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此 JVM 引入了轻量级锁的概念。</li>
</ul>
</li>
</ul>
<p>线程在执行同步块之前，JVM 会先在当前的线程的栈帧中创建一个 Lock Record，其包括一个用于存储对象头中的  mark word（官方称之为 Displaced Mark Word）以及一个指向对象的指针。下图右边的部分就是一个 Lock Record 。<br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/LockRecord.png?raw=true" alt=""></p>
<ul>
<li><strong>加锁过程</strong><br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/Locking.png?raw=true" alt=""><br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/Locking1.png?raw=true" alt=""></li>
</ul>
<ol>
<li>在线程栈中创建一个Lock Record，将其obj（即上图的Object reference）字段指向锁对象。</li>
<li>直接通过CAS指令将Lock Record的地址存储在对象头的mark word中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。如果失败，进入到步骤3。</li>
<li>如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分（Displaced Mark Word）为null，起到了一个重入计数器的作用。然后结束。</li>
<li>走到这一步说明发生了竞争，需要膨胀为重量级锁。</li>
</ol>
<ul>
<li><strong>解锁过程</strong> </li>
</ul>
<ol>
<li>遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record。</li>
<li>如果Lock Record的Displaced Mark Word为null，代表这是一次重入，将obj设置为null后continue。</li>
<li>如果Lock Record的Displaced Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为Displaced Mark Word。如果成功，则continue，否则膨胀为重量级锁。</li>
</ol>
<hr>
<ul>
<li><strong>偏向锁</strong><ul>
<li><strong>为什么引入偏向锁？</strong><br>偏向锁是在针对轻量级锁在没有竞争的情况下作出的优化,降低无竞争情况下获取锁的开销。</li>
<li><strong>对象创建</strong><br>  当JVM启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式，那新创建对象的mark word将是可偏向状态，此时mark word中的thread id为0，表示未偏向任何线程，也叫做匿名偏向(anonymously biased)。</li>
<li><strong>加锁过程</strong><ol>
<li>当该对象第一次被线程获得锁的时候，发现是匿名偏向状态，则会用CAS指令，将mark word中的thread id由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，将偏向锁撤销，升级为轻量级锁。</li>
<li>当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程，在通过一些额外的检查后，会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基本可以忽略。</li>
<li>当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到撤销偏向锁的逻辑里，一般来说，会在safepoint中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的mark word改为无锁状态（unlocked），之后再升级为轻量级锁。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p>
<hr>
<ul>
<li><strong>偏向锁的撤销</strong></li>
</ul>
<p>当有其他线程尝试获得锁时，是根据遍历偏向线程的lock record来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条lock record的obj字段设置为null。需要注意的是，偏向锁的解锁步骤中并不会修改对象头中的thread id。   </p>
<p>偏向锁默认不是立即就启动的，在程序启动后，通常有几秒的延迟，可以通过命令<br>-XX:BiasedLockingStartupDelay=0来关闭延迟</p>
<hr>
<ul>
<li><strong>批量重偏向与撤销</strong><ul>
<li><strong>为什么要引入批量重偏向与撤销？</strong><br>从上文偏向锁的加锁解锁过程中可以看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safepoint时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。总之，偏向锁的撤销是有一定成本的，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。</li>
<li><strong>存在两种情况会导致偏向锁降低性能</strong></li>
</ul>
<ol>
<li>一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</li>
<li>存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</li>
</ol>
</li>
</ul>
<p>批量重偏向（bulk rebias）机制是为了解决第一种场景。批量撤销（bulk revoke）则是为了解决第二种场景。</p>
<ul>
<li><strong>做法</strong><ol>
<li>以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。 </li>
<li>每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的mark word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其mark word的Thread Id 改成当前线程Id。 </li>
<li>当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><strong>End</strong><br>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。当条件不满足时，锁会按偏向锁-&gt;轻量级锁-&gt;重量级锁 的顺序升级。JVM种的锁也是能降级的，只不过条件很苛刻，暂不讨论。</li>
</ul>
<hr>
<h2 id="原子操作的实现原理"><a href="#原子操作的实现原理" class="headerlink" title="原子操作的实现原理"></a>原子操作的实现原理</h2><ul>
<li><strong>处理器实现原子操作</strong></li>
</ul>
<ol>
<li>通过总线锁保证原子性。总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</li>
<li>通过缓存锁定来保证原子性。缓存一致性协议</li>
</ol>
<ul>
<li><strong>Java实现原子操作</strong></li>
</ul>
<ol>
<li>循环CAS实现原子操作<br>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<ol start="2">
<li>CAS实现原子操作的三大问题</li>
</ol>
<ul>
<li><strong>ABA问题</strong><br>如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A</li>
<li><strong>循环时间长开销大</strong><br>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。<ul>
<li>pause指令有两个作用：<ol>
<li>它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li>
<li>它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。</li>
</ol>
</li>
</ul>
</li>
<li><strong>只能保证一个共享变量的原子操作</strong><ol>
<li>用锁机制。</li>
<li>把多个共享变量合并成一个共享变量来操作。</li>
</ol>
</li>
</ul>
<hr>
<ol start="3">
<li>使用锁机制实现原子操作<br>除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wayne"
      src="/images/808.jpg">
  <p class="site-author-name" itemprop="name">Wayne</p>
  <div class="site-description" itemprop="description">记录成长</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">39</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:winter98@foxmail.com" title="E-Mail → mailto:winter98@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wayne</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
