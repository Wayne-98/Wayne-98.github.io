<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Head First Desig Pattern</title>
    <url>/2020/05/10/Design%20Pattern/Head%20First%20Design%20Pattern/</url>
    <content><![CDATA[<h1 id="设计模式入门"><a href="#设计模式入门" class="headerlink" title="设计模式入门"></a>设计模式入门</h1><p><strong>设计原则</strong>：</p>
<ol>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>多用组合，少用继承。</li>
<li>为了交互对象之间的松耦合而努力。</li>
<li>类应该对扩展开放，对修改关闭。</li>
<li>要依赖抽象，不要依赖具体实现类。（依赖倒置原则）</li>
</ol>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a><a href="https://github.com/Wayne-98/Note/tree/master/Design%20Pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/Duck" target="_blank" rel="noopener">策略模式</a></h2><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a><a href="https://github.com/Wayne-98/Note/tree/master/Design%20Pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/Weather" target="_blank" rel="noopener">观察者模式</a></h2><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有的依赖者都会收到通知并自动更新。</p>
<p>当两个对象之间松耦合，它们依然可以交互，但是不太清楚彼此的细节。</p>
<p>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。</p>
<h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a><a href="https://github.com/Wayne-98/Note/tree/master/Design%20Pattern/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/Beverage" target="_blank" rel="noopener">装饰者模式</a></h2><p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>
<p>装饰者和被装饰对象都有相同的超类型。</p>
<p>可以用一个或多个装饰者包装一个对象</p>
<p>既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象(被包装的)的场合，可以用装饰过的对象替代它。</p>
<p>装饰者可以在所委托被装饰者的行为之前 与/或 之后，加上自己的行为，以达到特定的目的。</p>
<p>对象可以在任何时候被装饰，所以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a><a href="https://github.com/Wayne-98/Note/tree/master/Design%20Pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/Pizza" target="_blank" rel="noopener">工厂模式</a></h2><p>所有<strong>工厂模式</strong>都用来封装对象的创建。工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</p>
<p>抽象的<strong>创建者类</strong>：</p>
<ol>
<li><p>定义了<strong>一个抽象的工厂方法</strong>，所有的子类必须实现此方法制造产品。</p>
<ol start="2">
<li>通常会包含<strong>依赖于抽象产品的代码</strong>，而这些抽象产品由子类制造。创建者不需要真的知道在制造哪种具体产品。</li>
</ol>
</li>
</ol>
<p><strong>工厂方法模式</strong>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。</p>
<p><strong>抽象工厂模式</strong>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式确保一个类只有一个实例，并提供一个全局访问点。</p>
<p>全局变量 VS 单例模式</p>
<ol>
<li>急切实例化 VS 延迟实例化</li>
<li>全局变量可以提供全局访问，但是不能确保只有一个实例。</li>
</ol>
]]></content>
      <categories>
        <category>Desig Pattern</category>
      </categories>
      <tags>
        <tag>Desig Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/2020/05/10/Internet/HTTP/</url>
    <content><![CDATA[<ul>
<li><p><strong>无状态协议</strong><br>HTTP服务器并不保存关于客户的任何信息，所以我们说 HTTP 是一个无状态协议（stateless protocol）</p>
</li>
<li><p><strong>怎么实现有状态呢？</strong><br>Cookie 和 Session 保存会话状态，用 Session 来唯一标识用户，用 Cookie 当作用户通行证。</p>
<p>session 有如用户信息档案表, 里面包含了用户的认证信息和登录状态等信息. 而 cookie 就是用户通行证。</p>
</li>
</ul>
<ol>
<li><p><strong>cookie</strong>(客户端)</p>
<ul>
<li>cookie 的4个技术组件：</li>
</ul>
<ol>
<li>在 HTTP 响应报文中的一个 cookie 首部行</li>
<li>在 HTTP 请求报文中的一个 cookie 首部行</li>
<li>在用户端系统中保留有一个 cookie 文件，并由用户的浏览器进行管理</li>
<li>位于 Web 站点的一个后端数据库<br><img src="https://github.com/Wayne-98/image/blob/master/Internet/Cookie.png?raw=true" alt=""></li>
</ol>
</li>
</ol>
<ol start="2">
<li><strong>session</strong>(服务端)</li>
</ol>
<p>Session 是服务器在和客户端建立连接时添加客户端连接标志，最终会在服务器软件（Apache、Tomcat、JBoss）转化为一个临时 Cookie 发送给给客户端，当客户端第一请求时服务器会检查是否携带了这个Session（临时 Cookie ），如果没有则会添加 Session，如果有就拿出这个 Session 来做相关操作</p>
<ul>
<li>session 安全性的保证<ul>
<li>HttpOnly 属性<br>Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。</li>
<li>HTTPS传输</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>token</strong></li>
</ol>
<p>token 也称作令牌，由 uid + time + sign[+固定参数]</p>
<p><strong>token认证流程</strong></p>
<ul>
<li>token 的认证流程与 cookie 很相似，用户登录成功后服务器返回 Token 给客户端。</li>
<li>客户端收到数据后保存在客户端</li>
<li>再次访问服务器，将 token 放入 headers 中</li>
<li>服务器端采用 filter 过滤器校验。校验成功则返回请求数据，校验失败则返回错误码。</li>
</ul>
<p><strong>区别和联系</strong><br>session 存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号 sessionId，通常存放于 cookie 中。服务器收到 cookie 后解析出 sessionId ，再去 session 列表中查找，才能找到相应 session ，依赖cookie。cookie 类似一个令牌，装有 sessionId ，存储在客户端，浏览器通常会自动添加。token 也类似一个令牌，无状态，用户信息都被加密到 token 中，服务器收到 token 后解密就可知道是哪个用户。需要开发者手动添加。</p>
<hr>
<ul>
<li><strong>非持续性</strong>连接和<strong>持续性</strong>连接<br>每个请求/响应对是经一个单独的TCP连接发送，还是所有的请求及响应经相同的TCP连接发送呢？<br>前者是非持续性连接，后者是持续性连接。（HTTP在其默认方式下使用持续性连接）<ul>
<li>非持续连接的缺点<ol>
<li>每个连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量，浪费资源</li>
<li>每个对象经受2倍的RTT(Round-Trip Time，往返时间),一个RTT用于创建TCP,一个RTT用于请求和接收一个对象。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><strong>HTTP报文格式</strong></li>
<li>HTTP请求报文<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;somedir&#x2F;page.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.someschool.edu</span><br><span class="line">Connection: close</span><br><span class="line">User-agent: Mozilla&#x2F;5.0     &#x2F;&#x2F;浏览器类型</span><br><span class="line">Accept-language: fr</span><br></pre></td></tr></table></figure>
HTTP请求报文的第一行叫做请求行（request line），其后继的行叫做首部行（header line）</li>
</ul>
<ol>
<li><strong>请求行</strong></li>
</ol>
<ul>
<li>方法字段：方法字段可以取不同的值：<ol>
<li>GET：实体体为空</li>
<li>POST：实体体中包含的就是用户在表单字段中的输入值。</li>
</ol>
<ul>
<li>当用户向搜索引擎提供搜索关键词时，使用post报文时，用户仍可以向服务器请求一个Web界面，但Web界面的特定内容依赖于用户在表单字段中输入的内容。  </li>
<li>GET方法也可以提交表单，在所请求的URL中包括输入的数据。<br><code>www.somesite.com/animalsearch?monkey&amp;bananas</code></li>
</ul>
<ol start="3">
<li>HEAD：HEAD方法类似与GET方法。当服务器收到一个使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并不返回对象。应用程序开发者常用HEAD方法进行调试跟踪，用于确认 URL 的有效性以及资源更新的日期时间等。</li>
<li>PUT：它允许用户上传对象到指定的Web服务器上指定的路径。由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</li>
<li>PATCH：修改资源，PATCH 允许部分修改。</li>
<li>DELETE：允许用户或者应用程序删除Web服务器上的对象。并且同样不带验证机制。</li>
<li>OPTIONS：查询指定的 URL 能够支持的方法。</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道</li>
</ol>
</li>
<li>URL字段：URL字段带有请求对象的标识</li>
<li>HTTP版本字段</li>
</ul>
<ol start="2">
<li><strong>首部行</strong><br> Host：指明了对象所在的主机。（为什么已经有一条TCP连接存在了，还需要这个字段呢，因为Web代理高速缓存需要该首部行提供的信息）<br> Connection：close首部行，该浏览器告诉服务器不要麻烦地使用持续连接，它要求服务器在发送完被请求的对象后就关闭这条连接。</li>
</ol>
<ul>
<li>HTTP响应报文<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line">Date: Tue, 18 Aug 2015 15:44:04 GMT</span><br><span class="line">Server: Apache&#x2F;2.2.3 (CentOS)</span><br><span class="line">Last-Modified: Tue, 18 Aug 2015 15:11:04 GMT</span><br><span class="line">Content-Length: 6821</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line"></span><br><span class="line">(data data data data ....)</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>初始状态行(status line)<br> 协议版本字段，状态码和相应状态信息<ul>
<li>200 OK ：请求成功，信息在返回的响应报文中</li>
<li>301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL</li>
<li>400 Bad Request：一个通用差错代码，指示该请求不能被服务器理解</li>
<li>404 Not Found：被请求的文档不在服务器上</li>
<li>505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本。</li>
</ul>
</li>
<li>6个首部行(header line)<ul>
<li>Connection: close：首部行告诉客户，发送完报文后关闭该TCP连接</li>
<li>Date：首部行指示服务器产生并发送该响应报文的日期和时间。（不是指这个对象创建或者最后修改的时间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间）</li>
<li>Server</li>
<li>Last-Modified：指示了这个对象创建或者最后修改的时间。(对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要)</li>
<li>Length：指示了被发送对象中的字节数</li>
<li>Content-Type：</li>
</ul>
</li>
<li>实体体(entity body)</li>
</ol>
<hr>
<ul>
<li>Web缓存<br>Web缓存器(Web cache)也叫代理服务器(proxy server)，它是能够代表初始Web服务器来满足HTTP请求的网络实体。<ul>
<li>可以配置用户的浏览器，使得用户所有的HTTP请求首先指向Web缓存器。</li>
</ul>
</li>
</ul>
<ol>
<li>浏览器建立一个到web缓存器的TCP连接，并向web缓存器发送一个请求报文；</li>
<li>web缓存器检查本地是否存储了该对象的拷贝：如果有，向初始服务器发送一个条件GET请求报文（if-modified-since标记），检查本地拷贝是否是最新的：服务器会返回一个响应报文，如果是最新的，响应报文中不会包含请求对象(304 Not Modified)；如果不是最新的，响应报文中会包含请求对象，web缓存器更新其本地存储及相应的if-modified-since标记。如果没有，向初始服务器发送一个请求报文，收到请求后，更新本地存储。发送响应报文给客户端浏览器。</li>
</ol>
<p>GET /fruit/kiwi.gif HTTP/1.1<br>Host: <a href="http://www.exotiquecuisine.com" target="_blank" rel="noopener">www.exotiquecuisine.com</a></p>
<p>HTTP/1.1 200 Ok<br>Date: Sat, 3 Oct 2015 15:39:29<br>Server: Apache/1.3.0 (Unix)<br>Last-Modified: Wed, 9 Sep 2015 09:23:24<br>Content-Type: image/gif<br>(data data data data … ) </p>
<p>GET /fruit/kiwi.gif HTTP/1.1<br>Host: <a href="http://www.exotiquecuisine.com" target="_blank" rel="noopener">www.exotiquecuisine.com</a><br>If-modified-since：Wed, 9 Sep 2015 09:23:24</p>
<p>HTTP/1.1 304 Not Modified<br>Date: Sat, 10 Oct 2015 15:39:29<br>Server: Apache/1.3.0 (Unix)<br>(empty entity body)</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>可靠传输原理</title>
    <url>/2020/05/10/Internet/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="可靠传输原理"><a href="#可靠传输原理" class="headerlink" title="可靠传输原理"></a>可靠传输原理</h2><h3 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h3><ul>
<li>增加序号范围</li>
<li>协议的发送方和接收方两端需要缓存分组。(发送方最低限度应当能缓冲那些已经发送但是没有被确认的分组，接收方需要缓存那些已正确接收的分组)</li>
</ul>
<h3 id="回退N步-GBN-滑动窗口协议"><a href="#回退N步-GBN-滑动窗口协议" class="headerlink" title="回退N步(GBN)滑动窗口协议"></a>回退N步(GBN)滑动窗口协议</h3><ul>
<li>GBN 发送方需要响应的三种类型的事件：<ol>
<li>上层的调用: 发送方需要检查发送窗口是否已满，既是否有 N 个已发送但未被确认的分组。</li>
<li>收到一个 ACK: GBN 协议中，对序号为N的分组的确认采取<strong>累积确认</strong>的方式，表明接收方已正确接收到序号为 N 的以前且包括 N 在内的所有的分组</li>
<li>超时事件: 如果出现超时，发送方重传所有已发送但还未被确认过的分组。(只采用了一个定时器，在 base 处)</li>
</ol>
</li>
<li>GBN 接收方：<br>如果一个序号为 N 的分组被正确接收，并且按序(既上一次交付给上层的数据是序号为 N - 1 的分组),则接收方为分组 N 发送一个 ACK ，并将该分组中的数据部分交付给上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送 ACK 。<br>(接收方不需要缓存任何失序分组。因为发送方会重传所有已发送但还未被确认过的分组)</li>
</ul>
<h3 id="选择重传-SR"><a href="#选择重传-SR" class="headerlink" title="选择重传(SR)"></a>选择重传(SR)</h3><p>当窗口长度和时延带宽积都很大的时候，在流水线中会有很多分组更是如此。单个分组的差错就能够引起 GBN 重传大量分组，很多分组根本没必要重传。<br>选择重传协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。</p>
<ul>
<li>SR 发送方的事件和动作：</li>
</ul>
<ol>
<li>从上层收到数据：发送方需要检查发送窗口是否已满，既是否有N个已发送但未被确认的分组。</li>
<li>收到 ACK : 如果收到 ACK ，倘若该分组序号在窗口内，则 SR 发送方将那个被确认的分组标记为已接受。如果该分组的序号等于 send_base ，则窗口基序号向前移动到具有最小序号的未确认分组处。</li>
<li>超时事件：每个分组都必须拥有其自己的逻辑定时器。</li>
</ol>
<ul>
<li>SR接收方的事件和动作：</li>
</ul>
<ol>
<li>序号在 [ rcv_base, rcv_base + N - 1 ] 内的分组被正确接受。在此情况下，收到的分组落在接收方的窗口内，一个选择 ACK 被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果该分组的序号等于接受窗口的基序号，则该分组以及以前缓存的序号连续的分组交付给上层。然后接受窗口按向前移动分组的编号向上交付这些分组。</li>
<li>序号在 [ rcv_base - N, rcv_base - 1 ] 内的分组被正确接收到。在此情况下，必须产生一个 ACK ，即使该分组是接收方以前已确认过的分组。</li>
<li>其他情况，忽略该分组。</li>
</ol>
<ul>
<li>窗口长度必须小于等于序号空间大小的一半</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS</title>
    <url>/2020/05/10/Internet/DNS/</url>
    <content><![CDATA[<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名系统(Domain Name System)能进行<strong>主机名到IP地址转换</strong>的目录服务。</p>
<ul>
<li>DNS：</li>
</ul>
<ol>
<li><strong>一个由分层的 DNS 服务器实现的分布式数据库</strong></li>
<li><strong>一个使得主机能够查询分布式数据的应用层协议</strong></li>
</ol>
<p>DNS 协议运行在 UDP 之上，使用53端口号。</p>
<blockquote>
<p>DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：</p>
<p>如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。<br>区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。</p>
</blockquote>
<ol>
<li>主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>。        </li>
</ol>
<p>所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p>
<ol start="2">
<li><p>本地域名服务器向根域名服务器的查询的<strong>迭代查询</strong><br> 迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。</p>
<p> 搜索浏览器DNS缓存 –&gt; 操作系统DNS缓存 –&gt; 向本地DNS服务器发起DNS请求</p>
</li>
</ol>
<p>本地DNS服务器 –&gt; 根DNS服务器 –&gt; 根DNS服务器向本地DNS服务器响应：你去找哪个哪个顶级域DNS服务器 –&gt; 顶级域DNS服务器：你去找哪个哪个权威DNS服务器</p>
<ul>
<li>除了进行主机名到IP地址的转换之外，DNS还提供了一些重要的服务：</li>
</ul>
<ol>
<li>主机别名 2. 邮件服务器别名 3. 负载分配</li>
</ol>
<h1 id="DNS工作机理"><a href="#DNS工作机理" class="headerlink" title="DNS工作机理"></a>DNS工作机理</h1><ul>
<li>分布式、层次数据库<br>大致来说，有三种类型的 DNS 服务器：<ol>
<li>根 DNS 服务器</li>
<li>顶级域(Top-Level Domain, TLD)DNS服务器(com. org. net. edu. fr. ca. jp)</li>
<li>权威 DNS 服务器。</li>
</ol>
</li>
</ul>
<p><strong>本地DNS服务器</strong>并不属于该服务器的层级结构，但它对DNS层次结构是至关重要的。每个ISP都有一台本地DNS服务器。</p>
<ul>
<li>DNS 缓存<br>在一个请求链中，当某 DNS 服务器接受一个 DNS 回答时，它能将映射换存在本地存储器中。</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>自顶向下方法：网络层-控制平面</title>
    <url>/2020/05/12/Internet/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><ul>
<li>集中式路由选择算法：拥有关于连通性和链路开销的全部完整信息。<ul>
<li>链路状态(Link State, LS)算法：具有全局状态信息的算法</li>
</ul>
</li>
<li>分散式路由选择算法：没有关于连通性和链路开销的全部完整信息，每个节点仅有与其直接相连链路的开销知识即可开始工作。路由器通过迭代计算过程以及与相邻节点的信息交换，一个节点逐渐计算出达到某目的地的节点或者一组节点的最低开销路径。<ul>
<li>距离向量(Distance-Vector, DV)算法：分散式路由选择算法。（每个节点维护到网络中所有其他节点的开销估计的向量）</li>
</ul>
</li>
</ul>
<h3 id="因特网中自制系统内部的路由选择：OSPF"><a href="#因特网中自制系统内部的路由选择：OSPF" class="headerlink" title="因特网中自制系统内部的路由选择：OSPF"></a>因特网中自制系统内部的路由选择：OSPF</h3><ul>
<li><p>自制系统(Autonomous System, AS)：通常在一个 ISP 中的路由器以及互联它们的链路构成一个 AS，每个 AS 由一组通常处在相同管理下的路由器组成。</p>
</li>
<li><p>OSPF （Open Shortest Path Frist）：链路状态协议，使用洪泛链路状态信息和 Dijkstra 最低开销路径算法。每当一条链路的状态发生改变时，路由器就会广播链路状态信息。如未发生变化，也需要周期性的广播链路状态。</p>
<ul>
<li>优点<ol>
<li>安全：仅有受信任的路由器能参与一个 AS 内部的 OSPF 协议。</li>
<li>多条相同开销的路径：当存在多条相等开销的路径时，无须仅选择单一的路径来承载所有的流量</li>
<li>对单播和多播路由选择的综合支持：MOSPF </li>
<li>支持在单个 AS 中的层次结构：可以层次化的配置多个区域，每个区域都运行自己的 OSPF 链路状态路由选择算法。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="ISP-之间的路由选择：BGP"><a href="#ISP-之间的路由选择：BGP" class="headerlink" title="ISP 之间的路由选择：BGP"></a>ISP 之间的路由选择：BGP</h2><p>自治系统间路由选择协议：在因特网中，所有的 AS 运行相同的 AS 间路由选择协议，称为<strong>边界网关协议</strong>(Broder Gateway Protocal, BGP)。</p>
<ul>
<li><p>BGP 的作用：作为一种 AS 间的路由选择协议，BGP 为每台路由器提供了一种完成以下任务的手段：</p>
<ol>
<li>从邻居 AS 获得前缀的可达性信息。</li>
<li>确定到该前缀的“最好的”路由。</li>
</ol>
</li>
<li><p>通告 BGP 路由信息：</p>
<ul>
<li>网关路由器</li>
<li>内部路由器</li>
<li>在 BGP 中，每对路由器通过使用 179 端口的半永久 TCP 连接交换路由选择信息</li>
<li>跨越两个 AS 的 BGP 连接称为外部 BGP 连接</li>
<li>在相同 AS 中的两个路由器之间的 BGP 会话称为内部 BGP 连接。</li>
</ul>
</li>
<li><p>确定最好的路由：</p>
<ul>
<li>路由器通过 BGP 连接通告前缀的时候，它在前缀中包括一些 BGP 属性。前缀及其属性称为<strong>路由</strong>。</li>
<li>两个较为重要的属性是 AS-PATH 和 NEXT-HOP。</li>
</ul>
<blockquote>
<p>路由器 2a 的最左侧接口的 IP 地址：AS2, AS3; x</p>
<p>路由器 3d 的最左侧接口的 IP 地址：AS3; x</p>
</blockquote>
</li>
<li><p>热土豆路由选择</p>
</li>
</ul>
<p>在路由器转发表中增加 AS 外部目的地的步骤：</p>
<pre><code>1. 从 AS 间协议学到经过多个网关可达子网 x
 2. 使用来自 AS 内部协议的路由选择信息，以决定到达每个网关的最低开销路径的开销
 3. 热土豆路由选择：选择具有最小最低开销的网关
 4. 从转发表确定通往最低开销网关的接口 I 。在转发表中加入表项 (x, I)</code></pre><p>热土豆路由选择依据的思想是：尽可能快地将分组送出其 AS，而不担心其 AS 外部到目的地的余下部分的开销。</p>
<ul>
<li>路由器选择算法</li>
</ul>
<p>对于任何给定的目的地前缀，进入 BGP 的路由选择算法的输入是到某前缀的所有路由的集合，该前缀是已被路由器学习和接受的。</p>
<p>如果相同的前缀有两条或多条路由，则顺序地调用下列消除规则知道余下一条路由：</p>
<ol>
<li><p>路由器被指派一个<strong>本地偏好</strong>值作为其属性之一。具有最高本地偏好值的路由将被选择。</p>
</li>
<li><p>从余下的路由中，选择具有最短 AS-PATH 的路由。（如果该规则是路由选择的唯一规则，则 BGP 将使用距离向量算法决定路径，其中距离测度使用 <strong>AS 跳的跳数</strong>而不是路由器跳的跳数。）</p>
</li>
<li><p>从余下的路由中（所有都具有相同的最高本地偏好值和相同的 AS-PATH 长度），使用热土豆路由选择，即选择具有最靠近 NEXT-HOP 路由器的路由。</p>
</li>
</ol>
<p>BGP 不再是一种自私的算法，即它先查找具有短 AS 路径的路由。</p>
<ul>
<li>IP 任播(待学习)</li>
</ul>
<h2 id="SDN-控制平面-（待学习）"><a href="#SDN-控制平面-（待学习）" class="headerlink" title="SDN 控制平面 （待学习）"></a>SDN 控制平面 （待学习）</h2>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/2020/05/10/Internet/TCP/</url>
    <content><![CDATA[<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p><strong>TCP连接的组成</strong><br>    一台主机上的缓存、变量和与进程连接的套接字 ，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。</p>
<ul>
<li><strong>最大报文段长度</strong><br>TCP可以从缓存中取出并放入报文段中的数据数量受限于最大报文段长度(Maximum Segment Size)。MSS通常根据最初确定的由本地发送主机发送的最大链路层帧长度（Maximum Transmission Unit, MTU）来设置。</li>
</ul>
<hr>
<h2 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h2><ul>
<li>16比特的<strong>源端口号</strong>和<strong>目的端口号</strong></li>
<li>16比特的<strong>校验和</strong>字段</li>
<li>32比特的<strong>序号</strong>字段和<strong>确认号</strong>字段</li>
<li>16比特的<strong>接收窗口</strong>字段</li>
<li>4比特<strong>首部长度</strong>字段</li>
<li>可选与变长的<strong>选项</strong>字段</li>
<li>6比特的<strong>标志</strong>字段，ACK，RST，SYN，FIN</li>
</ul>
<ol>
<li><p><strong>序号和确认号</strong></p>
<p>TCP把数据看成一个无结构的、有序的字节流。序号是建立在传送的字节流上，而不是建立在传送的报文段的序列之上。<strong>一个报文段的序号</strong>因此是该报文段首字节的字节流编号。<br>确认号：A填充进报文段的确认号是主机A期望从主机B收到的下一个字节的序号。</p>
<p>TCP只确认该流中至第一个丢失字节为止的字节，所以TCP被称为提供<strong>累计确认</strong>。</p>
<p>接收方保留失序的字节，并等待缺少的字节以填补该间隔。</p>
</li>
<li><p><strong>往返时间的估计与超时</strong></p>
</li>
</ol>
<p>EstimatedRTT = (1-a)EstimatedRTT + a * SampleRTT<br>            （a一般取0.125）SampleRTT的均值</p>
<p>DevRTT = (1-b) * DevRTT + b * | SampleRTT - EstimatedRTT|<br>            （b一般取0.25）</p>
<p>TimeoutInterval = EstimatedRTT +　４ * DevRTT<br>    （要求将超时间隔设为EstimatedRTT加上一定余量，当波动较大的时候，这个余量应该大一点）</p>
<h2 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h2><p><strong>TCP发送方有3个与发送和重传有关的主要事件：</strong><br>       1. 从上层应用程序接收数据，将数据封装在一个报文段中，并把该报文段交给IP<br>       2. 当报文段被传给IP时，TCP就启动该定时器。（将定时器想象为与最早的未被确认的报文段相关联的）<br>       3. 来自接收方的确认报文段(ACK)。TCP将ACK的值y与它的变量SendBase进行比较(SendBase是最早未被确认的字节的序号，因此SendBase-1是指接收方已正确按序接收到的数据的最后一个字节的序号)。<br>           TCP采用累计确认，所以y确认了编号在y之前的所有字节都已经收到。</p>
<p><strong>TCP接收方产生ACK：</strong></p>
<ol>
<li>具有所期望序号的按序报文段到达。所有在期望序号以及以前的数据都已经被确认。<ul>
<li>延迟的ACK。对另一个按序报文段的到达最多等待500ms。如果下一个按序报文段在这个时间间隔内没有到达，则发送一个ACK</li>
</ul>
</li>
<li>具有所期望序号的按序报文段到达。另一个按序报文段等待ACK传输。<ul>
<li>立即发送单个累积ACK，以确认两个按序报文段</li>
</ul>
</li>
<li>比期望序号大的失序报文段到达。检测出间隔 <ul>
<li>立即发送冗余ACK，指示下一个期待字节的序号</li>
</ul>
</li>
<li>能部分或者完全填充接收数据间隔的报文段到达<ul>
<li>倘若该报文段起始于间隔的低端，则立即发送ACK</li>
</ul>
</li>
</ol>
<ul>
<li><strong>超时间隔加倍</strong><br>TCP重传时都会将下一次的时间间隔设为先前值的两倍，而不是用从EstimateRTT和DevRTT推算出的值。提供了一个形式受限的拥塞控制</li>
<li><strong>快速重传</strong></li>
</ul>
<p>超时触发重传存在的问题之一是超时周期可能相对较长，增加了端到端时延。幸运的是，发送方通常可在超时事件发生之前通过注意所谓冗余 ACK 来较好的检测到丢包情况。</p>
<p>一旦收到3个冗余ACK，TCP 就执行快速重传，即在该报文段的定时器过期之前重传丢失的报文段。</p>
<ul>
<li><strong>是回退N步还是选择重传</strong></li>
</ul>
<p>TCP确认是累积的，正确接收但失序的报文段是不会被接收方逐个确认的。</p>
<p>TCP发送方仅需维持已发送过但未被确认的字节的最小序号(SendBase)和下一个要发送的字节的序号(NextSeqNum)</p>
<p>选择确认允许TCP接收方有选择的确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段。</p>
<p>TCP的差错恢复机制也是最好被分类为GBN协议与SR协议的混合体。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p><strong>流量控制</strong>用以消除发送方使接收方缓存溢出的可能性。TCP通过让发送方维护一个称为<strong>接受窗口</strong>的变量来提供流量控制。</p>
<p>TCP发送方也可能因为IP网络的拥塞而被遏制，这种形式的发送方的控制被称为<strong>拥塞控制</strong>。</p>
<p>LastByteSent - LastByteAcked &lt;= rwnd<br>rwnd = RcvBuffer - [LastByteRcvd - LastByteRead]</p>
<p>LastByteSent - LastByteAcked &lt;= rwnd<br>主机A发送到连接中但未被确认的数据量小于等于主机B的缓存允许接收的数据量。</p>
<h2 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h2><ul>
<li><strong>三次握手</strong> <ol>
<li>发送SYN(Synchronize Sequence Numbers)报文段(报文段的首部中的SYN标志位被置为1，此外客户会随机选择一个初始序号，放在序号字段中)。</li>
<li>服务器提取出TCP SYN报文段，向该客户发送允许连接报文段。SYNACK报文段：这个报文段首部包含3个重要信息：SYN置为1，确认号字段被置为client_isn +１，服务器自己的初始序号。</li>
<li>收到SYNACK报文段后，客户也要给该连接分配缓存和变量。 发送报文段，此TCP报文段的首部的确认字段的序号为server_isn + 1，SYN被置为0，可以携带客户到服务器的数据。服务器收到客户端的确认后，连接建立。</li>
</ol>
</li>
<li><strong>三次握手的原因</strong> </li>
</ul>
<p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<ul>
<li><strong>四次挥手</strong><ol>
<li>客户应用进程发送一个特殊的报文段，其首部的FIN(finish)标志位被置为1</li>
<li>服务器收到后回送一个ACK报文段，此时 TCP 属于半关闭状态，服务器能向客户端发送数据但是客户端不能向服务器发送数据。</li>
<li>当服务器不再需要连接时，服务器发送它自己的终止报文段，其首部的FIN标志位也被置为1</li>
<li>该客户对这个服务器的终止报文段进行确认。此时两台主机上用于该连接的所有资源都被释放了。</li>
</ol>
</li>
<li><strong>四次挥手的原因</strong></li>
</ul>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p>
<ul>
<li><strong>TIME_WAIT</strong></li>
</ul>
<p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器<br>设置的时间 2MSL。这么做有两个理由：<br>       1. 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。<br>       2. 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
<ul>
<li><strong>客户TCP经历的典型的TCP状态序列</strong></li>
</ul>
<p>建立：</p>
<ol>
<li>客户 TCP 开始时处于 CLOSE 状态</li>
<li>发送 SYN 报文段后，进入 SYN_SENT 状态。然后等待服务器 TCP 的对客户所发报文段进行确认且 SYN 比特置为 1 的一个报文段</li>
<li>收到来自服务器的确认后，客户 TCP 进入 ESTABLISHED 状态。TCP 客户就能发送和接收包含有效荷载数据的TCP报文段了</li>
</ol>
<p>拆除：</p>
<ol>
<li>客户 TCP 发送一个带有FIN比特被置为 1 的 TCP 报文段，并进入 FIN_WAIT_1 状态。客户 TCP 等待一个来自服务器的带有确认的 TCP 报文段。</li>
<li>收到来自服务器的确认后，客户 TCP 进入 FIN_WAIT_2 状态。客户等待来自服务器的 FIN 比特被置为1的另一个报文段</li>
<li>收到服务器的 FIN 比特被置为 1 的报文段后，客户 TCP 对服务器的报文段进行确认，然后进去 TIME_WAIT 状态。(假定 ACK 丢失，TIME_WAIT 状态使 TCP 客户重传最后的确认报文)</li>
</ol>
<ul>
<li><strong>SYN洪泛攻击</strong></li>
</ul>
<p>SYN cookie</p>
<ul>
<li>服务器收到一个 SYN 报文段时，并不会立即生成一个半开连接，而是生成一个初始 TCP 序列号，该序列号是 SYN 报文段的源和目的 IP 地址与端口号以及仅有该服务器知道的秘密数的一个复杂函数。这种精心制作的初试序列号被称为 cookie。服务器并不记忆该 cookie 或任何对应于 SYN 的其他状态信息。</li>
<li>如果客户合法，返回一个 ACK 报文段，这个合法的 ACK ，在确认字段中的值等于在 SYNACK 字段(此时为 cookie 的值)中的值 + 1 .</li>
</ul>
<h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><ul>
<li><strong>拥塞网络的代价：</strong></li>
</ul>
<ol>
<li>分组的到达速率接近链路容量时，分组经历巨大的排队时延。</li>
<li>发送方必须执行重传以补偿因为缓存溢出而丢弃(丢失)的分组。</li>
<li>发送方在遇到大时延时所进行的不必要的重传会引起路由器利用其链路带宽来转发不必要的副本。</li>
<li>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了。</li>
</ol>
<ul>
<li><strong>拥塞控制方法</strong>：</li>
</ul>
<ol>
<li>端到端拥塞控制：网络层没有为运输层拥塞控制提供显示支持，端系统通过对网络行为的观察(如分组丢失与时延)来推断之</li>
<li>网络辅助的拥塞控制：路由器向发送方提供关于网络中拥塞状态的显示反馈信息。ATM可用比特率拥塞控制中，路由器显示的通知发送方它能在输出链路上支持的最大主机发送速率。<ul>
<li>网络辅助的拥塞控制有两种方式：<ul>
<li>直接网络反馈：由网络路由器发给发送方。（通常采用一种阻塞分组的形式）</li>
<li>路由器标记或更新从发送方流向接受方的分组中的某个字段来指示拥塞的产生。（更为通用，但是要经过一个RTT）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><ul>
<li><strong>TCP发送方如何限制它向其连接发送流量的速率呢？</strong></li>
</ul>
<p>TCP拥塞控制机制跟踪一个额外的变量，<strong>拥塞窗口cwnd</strong></p>
<p>LastByteSent - LastByteAcked &lt;=min｛cwnd,rwnd｝</p>
<p>通过限制了发送方中未被确认的数据量，间接的限制了发送方的发送速率。</p>
<ul>
<li><strong>TCP发送方如何感知它到目的地之间的路径上存在拥塞的呢？</strong></li>
</ul>
<p>“丢包事件”：超时事件和收到三个冗余的ACK。</p>
<p>因为TCP使用确认来触发增大它的拥塞窗口长度，TCP被称做自计时的。</p>
<ul>
<li><strong>TCP发送方怎样确定它应当发送的速率呢？</strong></li>
</ul>
<ol>
<li>一个丢失的报文段意味着拥塞，因此当丢失报文段时应当降低TCP发送方的速率。</li>
<li>一个确认的报文段指示该网络正在向接受方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率。</li>
<li>带宽探测，除非出现丢包才减慢速率，不然会一直加快。</li>
</ol>
<ul>
<li><p><strong>TCP拥塞控制算法</strong></p>
</li>
<li><p><strong>慢启动</strong></p>
</li>
</ul>
<ol>
<li>初始cwnd设置为一个MSS，当该确认到达时，TCP将以指数形式增大拥塞窗口。</li>
<li>何时结束指数增长：        <ul>
<li>当出现由超时指示的丢包事件 TCP发送方将cwnd设置为1，并重新开始慢启动，并且将ssthresh(<strong>慢启动阈值</strong>)设置为cwnd/2。</li>
<li>当cwnd到达或者超过ssthresh的值时，结束慢启动并且TCP转移到拥塞避免模式。</li>
<li>当检测到3个冗余ACK，这时TCP将执行一种快速重传并进入快速恢复状态。</li>
</ul>
</li>
</ol>
<ul>
<li><strong>拥塞避免</strong></li>
</ul>
<ol>
<li>每个RTT只将cwnd的值增加一个MSS，发送方无论何时到达一个新的确认，就将cwnd增加一个MSS字节。</li>
</ol>
<ul>
<li><strong>快速重传</strong></li>
</ul>
<ol>
<li>把ssthresh设置为cwnd的一半 </li>
<li>把cwnd再设置为ssthresh的值(具体实现有些为ssthresh+3) </li>
<li>重新进入拥塞避免阶段。</li>
</ol>
<ul>
<li><strong>快速恢复</strong></li>
</ul>
<ol>
<li>收到3个重复ACK时，把ssthresh设置为cwnd的一半，把cwnd设置为ssthresh的值加3，然后重传丢失的报文段，加3的原因是因为收到3个重复的ACK，表明有3个“老”的数据包离开了网络。</li>
<li>再收到重复的ACK时，拥塞窗口增加1。</li>
<li>当收到新的数据包的ACK时，把cwnd设置为第一步中的ssthresh的值。原因是因为该ACK确认了新的数据，说明从重复ACK时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。</li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>自顶向下方法：网络层-数据平面</title>
    <url>/2020/05/12/Internet/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%95%B0%E6%8D%AE%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><ul>
<li><p>输入端口</p>
<ul>
<li>最长前缀匹配规则：在路由表中寻找最长的匹配项，并向与最长前缀匹配相关联的链路转发分组</li>
<li>三态内容可寻址存储器：线性时间内找到匹配项</li>
</ul>
</li>
<li><p>交换结构</p>
<ul>
<li>经内存交换</li>
<li>经总线交换</li>
<li>经互联网络交换：纵横式交换</li>
</ul>
</li>
<li><p>输出端口</p>
</li>
<li><p>路由选择处理器或者是 SND</p>
</li>
<li><p>分组调度</p>
<ul>
<li>先进先出</li>
<li>优先权排队</li>
<li>循环和加权公平排队</li>
</ul>
</li>
</ul>
<h2 id="网际协议：IPv4、寻址、IPv6-及其他"><a href="#网际协议：IPv4、寻址、IPv6-及其他" class="headerlink" title="网际协议：IPv4、寻址、IPv6 及其他"></a>网际协议：IPv4、寻址、IPv6 及其他</h2><ul>
<li>IPv4 数据报格式</li>
</ul>
<p><img src="https://github.com/Wayne-98/image/blob/master/Internet/IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.jpg?raw=true" alt=""></p>
<ul>
<li>IPv4 数据分片</li>
</ul>
<p>生成一个数据报时，发送主机为该数据报设置源和目的地址的同时加上标识号。路由器需要分片的时候，形成的每一个数据报都具有相同的源和目的地址以及标识号。</p>
<p>标志位为 0 代表着这是较大数据报分片后的最后一片。</p>
<p>为了让目的主机确定是否丢失了一个片，使用偏移字段指定该片应放在初始 IP 数据报的哪个位置。</p>
<ul>
<li><p>IPv4 编址</p>
<ul>
<li>点分十进制</li>
<li>子网掩码：/ 左侧定义了子网地址</li>
<li>无类别域间路由(Classless Interdomain Routing, CIDR)：a . b . c . d / x</li>
<li>分类编址：IP 地址的网络部分被限制为长度为 8A, 16B, 或 24C 比特<ul>
<li>/ 24 C : 仅仅能容纳 254台主机</li>
<li>/ 16 B : 65534</li>
</ul>
</li>
</ul>
</li>
<li><p>获取地址：</p>
<ul>
<li>获取一块地址：ISP, 因特网名字和编号分配机构(Internet Corporation for Assigned Names and Numbers, ICANN)</li>
<li>获取主机地址：动态主机配置协议(Dynamic Host Configuration, DHCP)</li>
</ul>
</li>
<li><p>DHCP：</p>
<ul>
<li><p>一个客户-服务器协议。通常每个子网都有一台 DHCP 服务器，如果子网中没有服务器，则需要一个 DHCP 中继代理(路由器)。</p>
</li>
<li><p>DHCP 运行步骤</p>
<ol>
<li>DHCP 服务器发现：DHCP 发现报文，客户在 UDP 分组中向端口 67 发送该发现报文。目的IP 地址使用广播地址 255.255.255.255，源 IP 地址为 0.0.0.0.</li>
<li>DHCP 服务器提供：DHCP 服务器收到一个 DHCP 发现报文时，用 DHCP 提供报文向客户响应。目的 IP 地址仍然是广播地址。提供报文中还包含有收到发现报文的事务 ID, 向客户推荐的 IP 地址、网络掩码以及 IP 地址租用期。</li>
<li>DHCP 请求：客户从收到的一个或多个服务器提供中选择一个，向选中的服务器提供用 DHCP 请求报文进行响应，回显配置的参数</li>
<li>DHCP ACK：服务器用 DHCP ACK 报文对 DHCP 请求报文进行响应，证实所要求的参数。</li>
</ol>
</li>
</ul>
</li>
<li><p>网络地址转换 NAT：</p>
<p>路由器上的一张 NAT 转换表，表项中包含了端口号及其 IP 地址。</p>
</li>
</ul>
<ul>
<li>IPv6 数据报格式</li>
</ul>
<p><img src="https://github.com/Wayne-98/image/blob/master/Internet/IPv6.png?raw=true" alt=""></p>
<ul>
<li>IPv6 的向后兼容：隧道技术</li>
<li>通用转发和 SND(待学习)</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机第三部分：虚拟机执行子系统</title>
    <url>/2020/05/10/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h2 id="无关系的基石"><a href="#无关系的基石" class="headerlink" title="无关系的基石"></a>无关系的基石</h2><p>实现语言无关性的基石是<strong>虚拟机</strong>和<strong>字节码存储格式</strong>。 Java 虚拟机不与任何包括 Java 在内的语言绑定，它只与“ Class 文件”这种特定的二进制文件格式所关联，Class 文件中包含了 Java 虚拟机指令集和符号表以及若干其他辅助信息。</p>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>Class文件是一组以8字节为基础单位的<strong>二进制流</strong>。// 包括但不限于磁盘文件、网络、数据库、内存或者动态产生等。</p>
<p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：</p>
<ul>
<li>无符号数：基本的数据类型，1,2,4,8个字节，可以用来描述数字、索引引用、数量值或者UTF-8编码构成字符串值。</li>
<li>表：表是由多个无符号数或者其他表作为数据项构成的复合结构，习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表。</li>
</ul>
<h3 id="魔数和Class文件的版本"><a href="#魔数和Class文件的版本" class="headerlink" title="魔数和Class文件的版本"></a>魔数和Class文件的版本</h3><p>Class 文件的头四个字节称为 Magic Number，它的唯一的作用就是确定这个文件是否是一个能被虚拟机接收的Class 文件(类似于文件后缀的作用)。0xCAFEBABY</p>
<p>紧接着魔数的4个字节存储的是 Class 文件的版本号，前两个字节是次版本，后两个是主版本。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>主次版本号之后的是常量池入口，可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，也是 Class 文件中第一个出现的表类型数据项目。</p>
<p>常量池主要存放两大类常量：<strong>字面量</strong> (Literal) 和<strong>符号引用</strong> (Symbolic References)</p>
<ul>
<li><p>字面量接近于Java语言层面的常量概念，如文本字符串、声明为 final 的常量值。</p>
</li>
<li><p>符号引用则属于编译原理方面的概念：</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
<p>常量池的入口需要放置一项 u2 类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不同，这个容量计数是从1而不是0开始的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。</p>
<p>常量池中每一项常量都是一个表，截止 JDK13 常量表中分别有17种不同类型的常量，他们的表结构起始的第一位是个 u1 类型的标志位，代表着当前常量属于哪种常量类型。</p>
<p>例如  u1 类型的标志位中为7，可知这个常量属于 CONSTANT_Class_info 类型，此类型的常量代表一个类或者接口的符号引用。他的结构为一个 u1 类型的 tag 和一个 u2 类型的 name_index。tag是标志位，它用于区分常量类型；name_index 是常量池的索引值，它指向常量池中一个 CONSTANT_Utf8_info 类型常量，此常量代表了这个类（或者接口）的全限定名。</p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等</p>
<h3 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h3><p>类索引和父类索引都是一个u2类型的数据，接口索引集合是一组u2类型的数据，Class文件中由这三项数据来确定该类型的继承关系。</p>
<p>u2类型的数据指向一个CONSTANT_Class_info的类描述符常量，通过常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表（field_info）用于描述接口或者类中声明的变量，包括类级变量以及实例变量，但是不包括方法内部声明的局部变量。</p>
<p>字段表结构：依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。</p>
<p>字段可以包括的修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。</p>
<p>而字段叫做什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p>
<ul>
<li>全限定名，“org/fenixsoft/clazz/TestClass”</li>
<li>简单名称(name_index)则就是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别就是“inc”和“m”。</li>
<li>方法和字段的描述符：作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</li>
</ul>
<p>字段表所包含的固定数据项目到 descriptor_index 为止就全部结束了，不过在 descriptor_index 之后跟随着一个属性表集合，用于存储一些额外的信息，字段表可以在属性表中附加描述零至多项的额外信息。(ConstantValue)</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>结构和字段表几乎完全一致。</p>
<p>方法里的 Java 代码，经过 Javac 编译器编译成字节码指令之后，存放在方法属性表集合中一个名为 “Code” 的属性里面。</p>
<p>父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><h2 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h2><h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><ul>
<li>类从被加载到虚拟机内存直到卸载出内存的<strong>生命周期</strong></li>
</ul>
<ol>
<li>加载</li>
<li>连接<ol>
<li>验证</li>
<li>准备</li>
<li>解析：解析阶段不一定会按照顺序，为了支持 Java 语言的运行时绑定</li>
</ol>
</li>
<li>使用</li>
<li>卸载</li>
</ol>
<ul>
<li>有且只有六种情况必须立即对类进行“初始化”</li>
</ul>
<ol>
<li><p>遇到new、getstatic、putstatic或 invokestatic 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。</p>
<ol>
<li>使用 new 关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ol>
</li>
<li><p>使用 java.lang.reflect 包的方法进行反射调用时，如果类型没有进行过初始化，则需要先触发其初始化。</p>
</li>
<li><p>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。</p>
</li>
<li><p>当使用JDK 7新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>
</li>
<li><p>当一个接口中定义了JDK 8新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p>
</li>
</ol>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。文件格式验证之后，字节流会进入内存的方法区中，所有之后的验证都是基于方法区的存储结构进行的。</p>
<ol>
<li><p><strong>文件格式验证</strong></p>
<ul>
<li>是否以魔数 0xCAFEBABE 开头。</li>
<li>主、次版本号是否在当前 Java 虚拟机接受范围之内。</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量 tag 标志）。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>CONSTANT_Utf8_info 型的常量中是否有不符合 UTF-8 编码的数据。</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>
</ul>
</li>
<li><p><strong>元数据验证：对字节码描述的信息进行语义分析，保证符合 Java 语义规范</strong></p>
<ul>
<li>这个类是否有父类（除了 java.lang.Object 之外，所有的类都应当有父类）。</li>
<li>这个类的父类是否继承了不允许被继承的类（被 final 修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的 final 字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值类型却不同等）。</li>
</ul>
</li>
<li><p><strong>字节码验证：目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</strong></p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按 long 类型来加载入本地变量表中”这样的情况。</li>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换总是有效的，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。</li>
</ul>
</li>
<li><p><strong>符号引用验证：发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段-解析阶段发生，可以看做是对类自身以外的信息(常量池中的各种符号引用)进行匹配校验</strong></p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的可访问性（private、protected、public、<package>）是否可被当<br>前类访问。</li>
</ul>
</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段</strong>。从概念上讲，这些变量所使用的内存都应当在<strong>方法区</strong>中进行分配，但必须注意到方法区本身是一个<strong>逻辑</strong>上的区域。在JDK 7及之前，HotSpot 使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在JDK 8及之后，类变量则会随着 Class 对象一起存放在 Java 堆中，这时候“类变量在方法区”就完全是一种对逻辑概念的表述了。</p>
<ul>
<li>这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。初始值“通常情况”下是数据类型的零值，如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值。final</li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<ul>
<li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。</li>
<li>直接引用（Direct References）：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚 拟机实例上翻译出来的直接引用一般不会相同。</li>
</ul>
<p>虚拟机可以根据需要选择在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段就是执行类构造器clinit()方法的过程。clinit()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。</p>
<p>clinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”，是在 Java 虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><ul>
<li><p>从 Java 虚拟机角度，只存在两种不同的类加载器：</p>
<ol>
<li>启动类加载器，由C++语言实现，是虚拟机自身的一部分</li>
<li>其他所有的类加载器，由 Java 语言实现，独立于虚拟机外部，并且全部都继承自抽象类java.lang.ClassLoader</li>
</ol>
</li>
<li><p>Java开发人员的角度：</p>
<ol>
<li>启动类加载器：负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且被虚拟机识别的类库加载到虚拟机内存中。</li>
<li>扩展类加载器：负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有的类，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（系统类加载器）：负责加载用户类路径上所指定的类库，开发者可以直接使用应用程序类加载器。应用程序中如果没有自定义过自己的类加载器，一般情况下这个就是程序中的默认类加载器。</li>
</ol>
</li>
</ul>
<p>不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>
<p><strong>双亲委派模型的工作过程</strong>：</p>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p>
<p><strong>双亲委派模型的优点</strong>：</p>
<p>使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是 Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>
<hr>
<h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择或者两者兼备，但是从外观上看所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>Java 虚拟机以方法作为最基本的执行单元，栈帧是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。</p>
<ul>
<li><p>每一个栈帧都包括了局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息。</p>
</li>
<li><p>栈帧中需要多大的局部变量表，多深的操作数栈在编译程序代码之后就已经完全确定了，并且写入方法表的Code属性之中。</p>
</li>
<li><p>对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧。 </p>
</li>
</ul>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。</p>
<p>局部变量表的容量以变量槽(VariableSlot, Slot)为最小单位，虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的 Slot 数量。(在 Java 程序被编译为 Class 文件时，就在方法的 Code 属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量)</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>做算术运算是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的</p>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。</p>
<p>Class 文件的常量池中存有大量的符号引用，<strong>字节码中的方法调用指令</strong>就以常量池里指向方法的<strong>符号引用</strong>作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为<strong>静态解析</strong>。<br>另外一部分将在每一次运行期间都转化为直接引用，这部分就称为<strong>动态连接</strong>。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>正常完成出口：一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。</p>
<p>异常完成出口：方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p>
<p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：</p>
<ol>
<li><p>恢复上层方法的局部变量表和操作数栈</p>
</li>
<li><p>把返回值压入调用者栈帧的操作数栈中</p>
</li>
<li><p>调整PC计数器的值以指向方法调用指令后面的一条指令</p>
</li>
</ol>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是<strong>确定被调用的版本</strong>，暂时还不涉及方法内部的具体运行过程。</p>
<p>Class 文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局的入口地址(直接引用),这个特性给 Java 带来了更强大的动态扩展能力。</p>
<h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用的目标方法在 Class 文件里面都是一个常量池中的<strong>符号引用</strong>，在类加载的<strong>解析</strong>阶段，会将其中的一<strong>部分符号引用转化为直接引用</strong>。</p>
<p>这种解析能够成立的前提是：该方法“<strong>编译期可知，运行期不可变</strong>”，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。</p>
<p>在Java虚拟机支持以下5条方法调用字节码指令，分别是：</p>
<ol>
<li>invokestatic。用于调用静态方法。</li>
<li>invokespecial。用于调用实例构造器<init>()方法、私有方法和父类中的方法。</li>
<li>invokevirtual。用于调用所有的虚方法。</li>
<li>invokeinterface。用于调用接口方法，会在运行时再确定一个实现该接口的对象。</li>
<li>invokedynamic。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。</li>
</ol>
<p>只要能被<strong>invokestatic</strong>和<strong>invokespecial</strong>指令调用的方法，都可以在<strong>解析阶段中确定唯一的调用版本</strong>，Java语言里符合这个条件的方法共有<strong>静态方法</strong>、<strong>私有方法</strong>、<strong>实例构造器</strong>、<strong>父类</strong>方法4种，再加上被<strong>final</strong>修饰的方法（尽管它使用invokevirtual指令调用），<strong>这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用</strong>。这些方法统称为“非虚方法”（Non-Virtual Method），与之相反，其他方法就被称为“虚方法”（Virtual Method）。</p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><ul>
<li><strong>静态分派</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.fenixsoft.polymorphic;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方法静态分派演示</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello,guy!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man guy)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello,gentleman!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman guy)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello,lady!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Human man = <span class="keyword">new</span> Man();</span><br><span class="line">		Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">		StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">		sr.sayHello(man);	<span class="comment">//hello,guy!</span></span><br><span class="line">		sr.sayHello(woman);	<span class="comment">//hello,guy!</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，<strong>变量本身的静态类型不会被改变</strong>，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line">Human human = (<span class="keyword">new</span> Random()).nextBoolean() ? <span class="keyword">new</span> Man() : <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">sr.sayHello((Man) human)</span><br><span class="line">sr.sayHello((Woman) human)</span><br><span class="line"><span class="comment">//human的静态类型是Human，也可以在使用时（如sayHello()方法中的强制转型）临时改变这个类型，但这个改变仍是在编译期是可知的，两次sayHello()方法的调用，在编译期完全可以明确转型的是Man还是Woman。</span></span><br></pre></td></tr></table></figure>

<p>编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的。由于静态类型在编译期可知，所以在编译阶段，Javac 编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了 sayHello(Human) 作为调用目标，并把这个方法的符号引用写到 main() 方法里的两条 invokevirtual 指令的参数中。</p>
<p>所有<strong>依赖静态类型来决定方法执行版本的分派动作，都称为静态分派</strong>。静态分派的最典型应用表现就是<strong>方法重载</strong>。静态分派发生在编译阶段。</p>
<ul>
<li><strong>动态分派</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 方法动态分派演示</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"man say hello"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"woman say hello"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Human man = <span class="keyword">new</span> Man();</span><br><span class="line">		Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();<span class="comment">//man say hello</span></span><br><span class="line">		woman.sayHello();<span class="comment">//woman say hello</span></span><br><span class="line">		man = <span class="keyword">new</span> Woman();</span><br><span class="line">		man.sayHello();<span class="comment">//woman say hello</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>invokevirtual 指令的运行时解析过程：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回 java.lang.IllegalAccessError 异常。</li>
<li>否则，按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。</li>
</ol>
<p>正是因为 invokevirtual 指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的 invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会<strong>根据方法接收者的实际类型来选择方法版本</strong>，这个过程就是Java语言中方法<strong>重写</strong>的本质。我们把这种在<strong>运行期根据实际类型确定方法执行版本的分派过程称为动态分派</strong>。</p>
<h3 id="虚拟机动态分派的实现"><a href="#虚拟机动态分派的实现" class="headerlink" title="虚拟机动态分派的实现"></a>虚拟机动态分派的实现</h3><p>动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的方法元数据中搜索合适的目标方法，因此，Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地去反复搜索类型元数据。面对这种情况，一种基础而且常见的优化手段是为类型在方法区中建立一个虚方法表（Virtual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表——Interface Method Table，简称itable），使用虚方法表索引来代替元数据查找以提高性能。虚方法表中存放着各个方法的实际入口地址。</p>
<h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p>Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。</p>
<h3 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h3><p>基于栈的指令集主要优点是可移植，程序不直接依赖这些硬件寄存器，避免受到硬件的约束。</p>
<p>栈架构指令集的主要缺点是理论上执行速度相对来说会稍慢一些，不过这里的执行速度是要局限在解释执行的状态下，如果经过即时编译器输出成物理机上的汇编指令流，那就与虚拟机采用哪种指令集架构没有什么关系了。</p>
<p>在解释执行时，<strong>栈架构</strong>指令集的代码虽然紧凑，但是完成相同功能所需的<strong>指令数量</strong>一般会比寄存器架构来得更多，因为出栈、入栈操作本身就产生了相当大量的指令。<strong>更重要的是栈实现在内存中</strong>，频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。尽管虚拟机可以采取<strong>栈顶缓存</strong>的优化方法，把最常用的操作映射到寄存器中避免直接内存访问，但这也只是优化措施而不是解决本质问题的方法。因此由于<strong>指令数量和内存访问的原因</strong>，导致了栈架构指令集的执行速度会相对慢上一点。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机第二部分：走进内存管理</title>
    <url>/2020/05/10/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E8%B5%B0%E8%BF%9B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="Java内存区域与内存溢出异常"><a href="#Java内存区域与内存溢出异常" class="headerlink" title="Java内存区域与内存溢出异常"></a>Java内存区域与内存溢出异常</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><ul>
<li><strong>程序计数器</strong></li>
</ul>
<ol>
<li>定义：是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</li>
<li>作用：为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。</li>
<li>如果线程执行Java方法，程序计数器记录的是正在执行的虚拟机字节码指令的地址；如果是Native方法，则为空。</li>
<li>异常：程序计数器区域是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</li>
</ol>
<ul>
<li><strong>Java虚拟机栈</strong></li>
</ul>
<ol>
<li>定义：虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口信息。每个方法从调用直至运行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</li>
<li>Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。</li>
<li>异常：Java 虚拟机规范中对 Java 虚拟机栈规定了两种异常情况： 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverFlowError 异常; 如果虚拟机栈可以动态扩展，扩展时如果无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</li>
</ol>
<ul>
<li><strong>本地方法栈</strong><br>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</li>
<li><strong>Java堆</strong></li>
</ul>
<ol>
<li>一般来说，Java 堆是 Java 虚拟机所管理的内存中最大的一块，Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。<br>Java Heap 是垃圾收集器管理的主要区域，因此也别称为 GC 堆(Garbage Collected Heap)，收集器基本都采用分代收集算法。</li>
<li>异常：Java 堆可以处于物理上不连续的空间，只要逻辑上是连续的即可。既可以是固定大小，也可以是可扩展的，主流虚拟机都是按照可扩展来实现。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。</li>
</ol>
<ul>
<li><strong>方法区</strong><br>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常<ul>
<li>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</li>
<li>运行时常量池相对于 Class 文件常量池的另外一个重要特性是具备动态性。<br>当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常</li>
</ul>
</li>
<li><strong>直接内存</strong><br>直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的区域。但是这部分内存也被频繁地使用，而且也可能会导致 OutOfMemoryError 异常出现。<br>JDK1.4 新加入了 NIO ，引入了一种基于通道与缓冲区的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。因为避免了在 Java 堆和 Native 堆中来回复制数据，有些场景可以显著提升性能。</li>
</ul>
<hr>
<h2 id="HotSpot-虚拟机对象探秘"><a href="#HotSpot-虚拟机对象探秘" class="headerlink" title="HotSpot 虚拟机对象探秘"></a>HotSpot 虚拟机对象探秘</h2><ul>
<li><strong>对象的创建</strong></li>
</ul>
<ol>
<li>虚拟机遇到一条 new 指令的时候，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li>
<li>类加载通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。<ul>
<li>指针碰撞：如果堆中内存是绝对规整的，分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</li>
<li>空闲列表：如果不规整则需要维护一个“空闲列表”，记录上哪些内存块是可用的。</li>
<li>并发情况下分配内存：<ol>
<li>采用 CAS 配上失败重试的方式保证更新操作的原子性。</li>
<li>分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。</li>
</ol>
</li>
</ul>
</li>
<li>对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象 GC 的分代年龄等信息。这些信息保存在对象头之中。</li>
<li>从 JVM 视角来看，一个新的对象产生了，但从 Java 程序来看，对象创建才刚刚开始–<init>方法还没有执行</li>
</ol>
<ul>
<li><strong>对象的内存布局</strong></li>
</ul>
<ol>
<li>对象头Header<ul>
<li>存储对象自身的运行时数据<ol>
<li>Hashcode</li>
<li>GC 分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ol>
</li>
<li>类型指针，即对象指向它的类的指针（并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身）。</li>
<li>如果对象是一个数组，对象头中还需要有一块用于记录数组长度的数据。</li>
</ul>
</li>
<li>实例数据<br>存储真正的有效信息，包括从父类继承的</li>
<li>对齐填充<br>并不是必然存在的，占位符，因为 HotSpot VM 的自动内存管理系统要求对象起始地址必须是<strong>8</strong>字节的整数倍</li>
</ol>
<ul>
<li><strong>对象的访问定位</strong><ol>
<li>句柄：Java 堆中会划分一块内存作为句柄池，reference 中存储的是对象的句柄地址，句柄中包含了对象的实例数据与类型数据各自的具体地址信息。<ul>
<li>优点：对象被移动(垃圾收集时移动对象时很普遍的行为)时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</li>
<li>缺点：访问对象需要两次寻址，速度慢。</li>
</ul>
</li>
<li>直接指针：Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址。（ HotSpot 使用的是直接指针的方法）</li>
</ol>
</li>
</ul>
<hr>
<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h2><ul>
<li><strong>引用计数法</strong><br>给对象添加一个引用计数器，有一个地方引用时，计数器值加一，引用失效的时候就减一。任何时刻计数器为0的对象就是不可能再被使用的<ul>
<li>优点：实现简单，判断效率高</li>
<li>缺点：Java虚拟机没有采用，是因为它很难解决对象之间相互循环引用的问题</li>
</ul>
</li>
<li><strong>可达性分析算法</strong><br>通过一系列的称为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径成为引用链，当一个对象到 GC Roots 没有任何的引用链相连时，则证明此对象是不可用的<ul>
<li>可作为 GC Roots 的对象[全局性的引用(常量和静态属性)执行上下文(栈帧中的本地变量表)]<ol>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量。</li>
<li>方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。</li>
<li>本地方法栈中 JNI (一般来说的 Native 方法)引用的对象</li>
</ol>
</li>
</ul>
</li>
<li><strong>再谈引用</strong><ol>
<li>强引用：在程序代码中普遍存在的，类似 Object obj = new Object(); 只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用：用来描述一些还有用但是非必需的对象。在系统将要发生内存溢出异常之前，将会把软引用列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li>
<li>弱引用：也是描述非必需对象的，比软引用更弱一些。下一次垃圾回收就会回收掉只被弱引用关联的对象。</li>
<li>虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知.</li>
</ol>
</li>
<li><strong>生存还是死亡</strong><br>可达性分析算法中不可达的对象需要经过两次标记过程：<ol>
<li>第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法，当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则视为“没有必要执行”。</li>
<li>判定为有必要执行 finalize() 方法，会将这个对象放入一个叫做 F-Queue 的队列，并在稍后自动创建一个低优先级的 Finalizer 线程去执行，如果对象在 finalize() 方法中拯救自己，就会被移除“即将回收”集合，否则回收。</li>
</ol>
</li>
<li><strong>回收方法区</strong><ol>
<li>废弃常量</li>
<li>无用的类<ul>
<li>该类所有的实例已经被回收,也就是 Java 堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器已经被回收。(很难判断)</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><ul>
<li><strong>标记-删除算法</strong><br>缺点：<ol>
<li>执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低；</li>
<li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ol>
</li>
<li><strong>标记-复制算法</strong><ol>
<li>使用一半的内存空间，每次将存活的对象复制到空的另一半然后清空。</li>
<li>新生代中的对象 98% 很快消亡，所以没必要浪费一半的空间。把内存空间分成一个 Eden(80%) 和两个 survivor(10%) ,每次使用 Eden 和 一个survivor 空间，剩下一个 survivor 用来复制</li>
<li>没有办法保证每次回收都有不多于10%的对象存活，当 survivor 空间不够用时，需要依赖其他内存(老年代)进行分配担保。</li>
</ol>
</li>
<li><strong>标记-整理算法</strong><br>针对老年代复制算法的效率变低。采用“标记-整理”算法，标记之后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后清理掉边界以外的内存。<br>如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，需要“Stop The World” </li>
</ul>
<hr>
<h2 id="HotSpot-的算法细节实现"><a href="#HotSpot-的算法细节实现" class="headerlink" title="HotSpot 的算法细节实现"></a>HotSpot 的算法细节实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><ol>
<li>GC 停顿<br>在进行可达性分析的时候，必须在一个能确保一致性的快照中进行。“一致性”指的是在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况。</li>
<li>准确式 GC<br>执行系统停顿下来后并不需要一个不漏地检查完所有的执行上下文和全局变量的引用位置。<br>HotSpot 采用 OopMap 的数据结构来记录对象引用的位置。在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。在 OopMap 的协助下，HotSpot 可以快速且准确的完成 GC 。</li>
</ol>
<h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><ol>
<li>引用变化非常频繁，如果为每一条指令都生成对应的 OopMap ，GC 的空间成本太高。</li>
<li>HotSpot 只是在特定的位置记录了这些信息，叫做 “SafePoint”，SafePoint 的选取不能太少也不能太多。选定是以“是否具有让程序长时间执行的特征”为标准选定的。</li>
<li>如何在 GC 发生时让所有的线程停下来<ul>
<li>抢先式中断：首先把所有线程全部中断，然后发现有线程不在安全点上，则恢复线程让它跑到安全点上，几乎没有虚拟机采用这个方式来响应 GC 事件。</li>
<li>主动式中断：设置一个标志，各个线程主动的去轮询这个标志，发现中断标志为真的时候就自己中断挂起</li>
</ul>
</li>
</ol>
<h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>程序执行的时候可以根据安全点进行中断，但是没有获得CPU的程序就需要安全区域来解决，安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。</p>
<h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。<br>卡表最简单的形式可以只是一个字节数组。</p>
<p><a href="https://tech.meituan.com/2017/12/29/jvm-optimize.html" target="_blank" rel="noopener">从实际案例聊聊Java应用的GC优化</a><br>老年代中引用新生代，解决的方案是使用卡表，而不是每次 Minor GC 的时候扫描老年代。<br>新生代引用老年代，解决方案是老年代回收前，先对新生代进行一次 Minor GC 。</p>
<h3 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h3><p>在 HotSpot 虚拟机里是通过写屏障（Write Barrier）技术<strong>维护卡表状态</strong>的。<br>写屏障可以看作在虚拟机层面对“引用类型字段赋值”这个动作的 AOP 切面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。在赋值前的部分的写屏障叫作写前屏障（Pre-Write Barrier），在赋值后的则叫作写后屏障（Post-Write Barrier）</p>
<h3 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h3><h4 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h4><ul>
<li>白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</li>
<li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。</li>
<li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</li>
</ul>
<ul>
<li>因为用户线程与收集器是并发工作。收集器在对象图上标记颜色，同时用户线程在修改引用关系——即修改对象图的结构，这样可能出现两种后果：<pre><code>1. 把原本消亡的对象错误标记为存活，产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。</code></pre><ol start="2">
<li>把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误。</li>
</ol>
</li>
<li>导致“对象消失”的问题的两个条件：<pre><code>1. 赋值器插入了一条或多条从黑色对象到白色对象的新引用；</code></pre><ol start="2">
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ol>
</li>
<li>两种解决方案：增量更新（Incremental Update）和原始快照（Snapshot At The Beginning，SATB）。<br>（CMS 采用增量更新，G1 采用原始快照）  <ol>
<li>增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</li>
<li>原始快照要破坏的是第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><ol>
<li><strong>Serial 收集器</strong></li>
</ol>
<ul>
<li>单线程，并不仅仅说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它收集垃圾时，必须暂停其他所有的工作线程。</li>
<li>新生代采用复制算法，老年代采用标记整理算法，是虚拟机运行在 Client 模式下的默认新生代收集器</li>
</ul>
<ol start="2">
<li><strong>ParNew 收集器</strong></li>
</ol>
<ul>
<li>Serial 收集器的多线程版本</li>
<li>目前只有它与 CMS 收集器配合工作，CMS 作为老年代的收集器，ParNew 作为新生代的收集器。</li>
</ul>
<ol start="3">
<li><strong>Parallel Scavenge</strong></li>
</ol>
<ul>
<li>采用复制算法，并行的多线程新生代收集器，其关注点和其他收集器不同，CMS 收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge关注点是达到一个可控制的吞吐量。</li>
<li>停顿时间短适合与用户交互，高吞度量则可以高效率地利用 CPU 时间，适合在后台运算。</li>
</ul>
<ol start="4">
<li><strong>Serial Old 收集器</strong></li>
</ol>
<ul>
<li>单线程标记整理算法，主要意义在于给 Client 模式下的虚拟机使用</li>
<li>JDK1.5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用</li>
<li>作为 CMS 收集器的后备预案，并发收集发生Concurrent Mode Failure时使用</li>
</ul>
<ol start="5">
<li><strong>Parallel Old收集器</strong></li>
</ol>
<ul>
<li>多线程标记整理算法, JDK1.6 之后开始提供</li>
<li>搭配 Parallel Scavenge 在注重吞吐量和 CPU 资源敏感的工作场合</li>
</ul>
<ol start="6">
<li><strong>CMS（Concurrent Mark Sweep）收集器</strong></li>
</ol>
<ul>
<li>运行流程<ol>
<li>初始标记：仅仅标记 GC Roots 能直接关联到的对象，速度很快，需要Stop The World</li>
<li>并发标记：进行 GC Roots Tracing，相对耗时，但是是和用户线程并发运行</li>
<li>重新标记<ul>
<li>修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，比初始标记稍慢，远比并发标记的时间短。</li>
<li>这个阶段是以新生代中对象为根来判断对象是否存活的</li>
<li>新生代对象持有老年代中对象的引用，这种情况称为“跨代引用”。因它的存在，Remark阶段必须扫描整个堆来判断对象是否存活</li>
<li>新生代的部分对象已经不可达，但仍然需要扫描的原因：新生代 GC 和老年代的 GC 是各自分开独立进行的，只有 Minor GC 时才会使用根搜索算法，标记新生代对象是否可达，也就是说虽然一些对象已经不可达，但在 Minor GC 发生前不会被标记为不可达，CMS 也无法辨认哪些对象存活，只能全堆扫描（新生代+老年代）。</li>
<li>新生代中对象的特点是“朝生夕灭”，这样如果 Remark 前执行一次 Minor GC，大部分对象就会被回收。CMS 就采用了这样的方式，在 Remark 前增加了一个可中断的并发预清理（CMS-concurrent-abortable-preclean），该阶段主要工作仍然是并发标记对象是否存活，只是这个过程可被中断。如果此阶段执行时等到了 Minor GC，那么上述灰色对象将被回收，Remark 阶段需要扫描的对象就少了。除此之外 CMS 为了避免这个阶段没有等到 Minor GC 而陷入无限等待，提供了参数CMSMaxAbortablePrecleanTime，默认为5s，含义是如果可中断的预清理执行超过5s，不管发没发生 Minor GC 都会中止此阶段，进入Remark。</li>
<li>JVM 是如何避免 Minor GC 时扫描全堆的？卡表的具体策略是将老年代的空间分成大小为512B的若干张卡（card）。卡表本身是单字节数组，数组中的每个元素对应着一张卡，当发生老年代引用新生代时，虚拟机将该卡对应的卡表元素设置为适当的值。卡表被标记为脏（卡表还有另外的作用，标识并发标记阶段哪些块被修改过），之后 Minor GC 时通过扫描卡表就可以很快的识别哪些卡中存在老年代指向新生代的引用。这样虚拟机通过空间换时间的方式，避免了全堆扫描。</li>
<li>什么时候可能会触发 STW 的 FullGC 呢？<ol>
<li>Perm空间不足；</li>
<li>CMS GC 时出现 promotionfailed 和 concurrentmodefailure（发生的原因一般是 CMS 正在进行，但是由于老年代空间不足，需要尽快回收老年代里面的不再被使用的对象，这时停止所有的线程，同时终止 CMS ，直接进行 SerialOld GC）；</li>
<li>统计得到的 YoungGC 晋升到老年代的平均大小大于老年代的剩余空间</li>
<li>主动触发 Full GC（执行jmap-histo:live [pid]）来避免碎片问题。</li>
</ol>
</li>
</ul>
</li>
<li>并发清除：可以和用户线程并发运行</li>
</ol>
</li>
<li>CMS 的缺点<ol>
<li>CMS 收集器对 CPU 资源非常敏感</li>
<li>CMS 收集器无法处理浮动垃圾，可能出现 Concurrent Mode Failure 而导致另一次Full GC 的发生<ul>
<li>浮动垃圾：CMS 在并发清除阶段，此刻并发运行的用户线程产生的垃圾只能下一次 GC 的时候回收</li>
<li>也是因为在垃圾收集阶段用户线程在需要运行，所以需要预留一部分空间提供并发收集时的程序运作使用</li>
<li>预留的内存无法满足程序需求就会出现 CMF ，此刻需要临时启用 Serial Old 重新进行老年代的垃圾收集</li>
</ul>
</li>
<li>标记清除算法容易产生空间碎片导致大对象没有足够的空间分配，不得不提前触发一次 Full GC。</li>
</ol>
</li>
</ul>
<ol start="7">
<li><strong>G1收集器</strong></li>
</ol>
<ul>
<li><strong>Mixed GC</strong><br>G1 可以面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是 G1 收集器的 Mixed GC 模式。</li>
<li><strong>Region</strong><br>G1把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。</li>
<li><strong>Why Garbage First ？</strong></li>
</ul>
<ol>
<li>G1 收集器之所以能建立可预测的停顿时间模型，是因为它将 Region 作为单次回收的最小单元，即每次收集到的内存空间都是 Region 大小的整数倍，这样可以有计划地避免在整个 Java 堆中进行全区域的垃圾收集。</li>
<li>更具体的处理思路是让 G1 收集器去跟踪各个 Region 里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（使用参数-XX：MaxGCPauseMillis指定，默认值是200毫秒），优先处理回收价值收益最大的那些Region，这也就是“Garbage First”名字的由来。</li>
</ol>
<ul>
<li><strong>Region里面存在的跨Region引用对象如何解决？</strong><br>使用记忆集避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集（哈希表），这些记忆集会记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。</li>
<li><strong>并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</strong><ol>
<li>解决的是用户线程改变对象引用关系时，必须保证其不能打破原本的对象图结构，导致标记结果出现错误。解决方案是原始快照。</li>
<li>垃圾收集对用户线程的影响还体现在回收过程中新创建对象的内存分配上，程序要继续运行就肯定会持续有新对象被创建，G1 为每一个 Region 设计了两个名为 TAMS（Top at Mark Start）的指针，把 Region 中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1 收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。</li>
</ol>
</li>
<li><strong>G1收集器的运作过程</strong></li>
</ul>
<ol>
<li>初始标记<br>仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改 TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的 Region 中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC 的时候同步完成的，所以 G1 收集器在这个阶段实际并没有额外的停顿。</li>
<li>并发标记<br>从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</li>
<li>最终标记<br>对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li>
<li>筛选回收<br>负责更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</li>
</ol>
<ul>
<li><strong>G1的美中不足</strong><br>在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比CMS要高。</li>
</ul>
<hr>
<h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ul>
<li><p><strong>对象优先在Eden分配</strong><br>1Eden2Survivor，其中1Eden1Survivor用来分配，剩下的一个Survivor用来GC的时候复制。同时老年代区域为新生代区域担保。<br>当Eden区没有足够的空间进行分配，虚拟机会进行一次Minor GC</p>
</li>
<li><p><strong>大对象直接进入老年代</strong></p>
<p>-XX:PretenureSizeThreshold,令大于这个设置值的对象直接在老年代分配。<br>目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。</p>
</li>
<li><p><strong>长期存活的对象将进入老年代</strong><br>虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象的年龄设为1，对象在Survivor区中每“熬过”一次Minor GC，年龄就增加一岁。–XX:MaxTenuringThreshold</p>
</li>
<li><p><strong>动态对象年龄判定</strong><br>并不是永远地要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象的大小超过Survivor空间的一半，那么年龄大于等于该年龄的对象就可以直接进入老年代</p>
</li>
<li><p><strong>空间分配担保</strong></p>
</li>
</ul>
<ol>
<li><p>发生 Minor GC 之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，那么 Minor GC 是绝对安全的。</p>
</li>
<li><p>HandlePromotionFailure 设置值是否允许担保失败：</p>
<ul>
<li>如果允许，会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次 Minor GC，尽管这个 GC 是有风险的。</li>
<li>出现担保失败，就只好在失败后进行一次 Full GC</li>
<li>如果小于，或者 HandlePromotionFailure 设置不允许冒险，则进行一次 Full GC</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Java虚拟机第四部分：程序编译与代码优化</title>
    <url>/2020/05/10/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%EF%BC%9A%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="前端编译与优化"><a href="#前端编译与优化" class="headerlink" title="前端编译与优化"></a>前端编译与优化</h1><p>Java中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说关系更加密切。</p>
<h2 id="Javac编译器"><a href="#Javac编译器" class="headerlink" title="Javac编译器"></a>Javac编译器</h2><h3 id="解析与填充符号表过程"><a href="#解析与填充符号表过程" class="headerlink" title="解析与填充符号表过程"></a>解析与填充符号表过程</h3><ol>
<li>词法，语法分析</li>
</ol>
<ul>
<li><p>词法分析是将源代码的字符流转变为标记(Token)集合，单个字符是程序编写过程的最小元素，而标记则是编译过程中的最小元素</p>
</li>
<li><p>语法分析是根据Token序列构造抽象语法树的过程</p>
<p>抽象语法树是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构    </p>
</li>
<li><p>经过这个步骤之后，编译器就基本不会再対源码文件进行操作了，后续的操作都基于抽象语法树    </p>
</li>
</ul>
<ol start="2">
<li>填充符号表</li>
</ol>
<p>符号表是由一组符号地址和符号信息构成的表格，符号表中所登记的信息在编译的不同阶段都要用到。</p>
<p>在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码。</p>
<p>在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。</p>
<h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><h2 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h2><p>语法树能够表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。</p>
<ul>
<li>标注检查步骤检查的内容包括诸如变量使用前是否被声明、变量与赋值之间的数据类型是否匹配；标注检查中还有一个重要的动作称为常量折叠。</li>
<li>数据及控制流分析是对程序上下文逻辑更进一步的验证，它可以检查出诸如程序局部变量在使用前是否有赋值，方法的每条路径是否都有返回值，是否所有的受查异常都被正确处理了等问题</li>
<li>解语法糖：语法糖指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用</li>
<li>字节码生成阶段不仅仅是把前面各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作</li>
</ul>
<h2 id="Java语法糖的味道"><a href="#Java语法糖的味道" class="headerlink" title="Java语法糖的味道"></a>Java语法糖的味道</h2><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型的本质是参数化类型（Parameterized Type）或者参数化多态（Parametric Polymorphism）的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数，这种参数类型能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法。泛型让程序员能够针对泛化的数据类型编写相同的算法，这极大地增强了编程语言的类型系统及抽象能力。</p>
<p>C#里面的泛型无论在程序源码中、编译后的 Intermediate Language 中，或是运行期的CLR中，都是切实存在的，List(int)与List(String)就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为<strong>真实泛型</strong>。</p>
<p>Java语言中的泛型则不一样，它只在程序源码中存在，编译后的字节码文件中，就已经替换为原始类型了，并且在相应的地方插入了强制类型转换。因此对于运行期的Java语言来说，ArrayList(Integer)与ArrayList(String)就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为<strong>类型擦除</strong>，基于这种方法实现的泛型称为伪泛型</p>
<p>擦除法所谓的擦除，仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。</p>
<h3 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h3><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><p>Java语言中条件编译的实现，也是Java语言的一颗语法糖，根据布尔常量值的真假，编译器将会把分支中不成立的代码块消除掉</p>
<h1 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h1><h2 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h2><p>Java程序最初是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为”热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成本地平台的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器JIT</p>
<h3 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h3><ul>
<li><p>热点代码：被多次调用的方法以及被多次执行的循环体（编译器都是编译整个方法）</p>
</li>
<li><p>热点探测判定方式：</p>
</li>
</ul>
<ol>
<li>基于采样的热点探测：虚拟机周期性地检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那个这个方法就是“热点方法”。<ul>
<li>优点是实现简单、高效，还可以很容易的获取方法调用关系。</li>
<li>缺点是不够精确，且容易受到线程阻塞或别的外界因素的印象而扰乱热点探测。</li>
</ul>
</li>
<li>基于计数器的热点探测：虚拟机为每个方法建立计数器，统计方法的执行次数，执行次数超过一定的阈值就认为它是热点方法<ul>
<li>实现麻烦，需要为每个方法建立并维护计数器，并且不能直接获取到方法的调用关系。</li>
<li>统计结果精确严谨。</li>
<li>默认方法调用计数器统计的并不是方法被调用的次数，而是一个相对的执行频率。当超过一定的时间限度，如果方法的调用次数仍不足以让它提交给JIT，那个这个方法的调用计数器就被减少一半，这个过程称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的半衰周期。</li>
<li>回边计数器，它的作用是统计一个方法中循环体代码执行的次数，建立回边计数器的目的就是为了出发OSR编译</li>
</ul>
</li>
</ol>
<h2 id="Java与C-C-的编译器对比"><a href="#Java与C-C-的编译器对比" class="headerlink" title="Java与C/C++的编译器对比"></a>Java与C/C++的编译器对比</h2><p>即时编译器运行占用的是用户程序的运行时间，所以不可以随便引入大规模的优化技术；静态编译的时间成本不是主要关注点。</p>
<p>Java语言是动态的类型安全语言，意味着虚拟机来确保程序不会违反语言语义或访问非结构化内存。动态检查会消耗不少的运行时间。</p>
<p>虚方法的频率远大于C/C++语言，方法接收者进行多态选择的频率高于C/C++语言。即时编译器的一些优化难度较高，例如方法内联。</p>
<p>Java语言是可动态扩展的语言，运行时加载新的类可能改变程序类型的继承关系，这使得很多全局优化难以进行，因为编译器无法看到程序的全貌，许多全局优化都只能以激进优化的方式来完成，便以其不得不时刻注意并随着类型的变化而在运行时撤销或者重新进行一些优化。</p>
<p>C/C++垃圾回收不存在无用对象筛选的过程，效率较高</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的并发工具类</title>
    <url>/2020/05/10/Java%20Concurrent/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="等待多线程完成的CountDownLatch"><a href="#等待多线程完成的CountDownLatch" class="headerlink" title="等待多线程完成的CountDownLatch"></a>等待多线程完成的CountDownLatch</h2><blockquote>
<p><a href="https://blog.csdn.net/zhutulang/article/details/48504487" target="_blank" rel="noopener">CountDownLatch理解一：与join的区别</a></p>
</blockquote>
<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinCountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread parser1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread parser2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"parser2 finish"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    parser1.start();</span><br><span class="line">    parser2.start();</span><br><span class="line">    parser1.join();</span><br><span class="line">    parser2.join();</span><br><span class="line">    System.out.println(<span class="string">"all parser finish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看一下join，在当前线程中，如果调用某个thread的join方法，那么当前线程就会被阻塞，直到thread线程执行完毕，当前线程才能继续执行。join的原理是，不断的检查thread是否存活，如果存活，那么让当前线程一直wait，直到thread线程终止，线程的this.notifyAll 就会被调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    staticCountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">            c.countDown();</span><br><span class="line">            System.out.println(<span class="number">2</span>);</span><br><span class="line">            c.countDown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    c.await();</span><br><span class="line">    System.out.println(<span class="string">"3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CountDownLatch的构造函数接收一个int类型的参数作为计数器，如果你想等待N个点完成，这里就传入N。<br>当我们调用CountDownLatch的countDown方法时，N就会减1，CountDownLatch的await方法会阻塞当前线程，直到N变成零。由于countDown方法可以用在任何地方，所以这里说的N个点，可以是N个线程，也可以是1个线程里的N个执行步骤。用在多个线程时，只需要把这个CountDownLatch的引用传递到线程里即可。</p>
<blockquote>
<p>CountDownLatch中我们主要用到两个方法一个是await()方法，调用这个方法的线程会被阻塞，另外一个是countDown()方法，调用这个方法会使计数器减一，当计数器的值为0时，因调用await()方法被阻塞的线程会被唤醒，继续执行。</p>
</blockquote>
<hr>
<h2 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h2><blockquote>
<p><a href="https://www.jianshu.com/p/9262361a1200" target="_blank" rel="noopener">CyclicBarrier 相关整理</a></p>
</blockquote>
<p>CyclicBarrier的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义工作线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.run();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"开始等待其他线程"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"开始执行"</span>);</span><br><span class="line">                <span class="comment">// 工作线程开始处理，这里用Thread.sleep()来模拟业务处理</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"执行完毕"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">3</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(threadCount);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"创建工作线程"</span> + i);</span><br><span class="line">            Worker worker = <span class="keyword">new</span> Worker(cyclicBarrier);</span><br><span class="line">            worker.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;<span class="comment">/**</span></span><br><span class="line"><span class="comment">创建工作线程0</span></span><br><span class="line"><span class="comment">创建工作线程1</span></span><br><span class="line"><span class="comment">Thread-0开始等待其他线程</span></span><br><span class="line"><span class="comment">创建工作线程2</span></span><br><span class="line"><span class="comment">Thread-1开始等待其他线程</span></span><br><span class="line"><span class="comment">Thread-2开始等待其他线程</span></span><br><span class="line"><span class="comment">Thread-2开始执行</span></span><br><span class="line"><span class="comment">Thread-0开始执行</span></span><br><span class="line"><span class="comment">Thread-1开始执行</span></span><br><span class="line"><span class="comment">Thread-1执行完毕</span></span><br><span class="line"><span class="comment">Thread-0执行完毕</span></span><br><span class="line"><span class="comment">Thread-2执行完毕</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>总结<br>CyclicBarrier 的用途是让一组线程互相等待，直到全部到达某个公共屏障点才开始继续工作。CyclicBarrier 是可以重复利用的。在等待的只要有一个线程发生中断，则其它线程就会被唤醒继续正常运行。CyclicBarrier 指定的任务是进行 barrier 处最后一个线程来调用的，如果在执行这个任务发生异常时，则会传播到此线程，其它线程不受影响继续正常运行。</li>
<li>CyclicBarrier 和 CountDownLatch 的区别</li>
</ul>
<ol>
<li>CountDownLatch 是一个线程(或者多个)，等待另外 N 个线程完成某个事情之后才能执行；CyclicBarrier 是 N 个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</li>
<li>CountDownLatch 的计数器只能使用一次。而 CyclicBarrier 的计数器可以使用 reset() 方法重置；<br>CyclicBarrier 能处理更为复杂的业务场景，比如如果计算发生错误，可以重置计数器，并让线程们重新执行一次。</li>
<li>CountDownLatch 采用减计数方式；CyclicBarrier 采用加计数方式。</li>
</ol>
]]></content>
      <categories>
        <category>Java Concurrent</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Condition</title>
    <url>/2020/05/10/Java%20Concurrent/Condition/</url>
    <content><![CDATA[<h1 id="Condition接口与示例"><a href="#Condition接口与示例" class="headerlink" title="Condition接口与示例"></a>Condition接口与示例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> Object[] items;    <span class="comment">// 添加的下标，删除的下标和数组当前数量    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> addIndex, removeIndex, count;    </span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();    </span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();    </span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedQueue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;        </span><br><span class="line">        items = <span class="keyword">new</span> Object[size];    </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 添加一个元素，如果数组满，则添加线程进入等待状态，直到有"空位"    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;        </span><br><span class="line">        lock.lock();<span class="comment">//首先需要获得锁，目的是确保数组修改的可见性和排他性</span></span><br><span class="line">        <span class="keyword">try</span> &#123;            </span><br><span class="line">            <span class="keyword">while</span> (count == items.length)                </span><br><span class="line">                notFull.await();            </span><br><span class="line">            items[addIndex] = t;            </span><br><span class="line">            <span class="keyword">if</span> (++addIndex == items.length)                </span><br><span class="line">                addIndex = <span class="number">0</span>;            </span><br><span class="line">            ++count;            </span><br><span class="line">            notEmpty.signal();        </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line">            lock.unlock();        </span><br><span class="line">            &#125;   </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素    @SuppressWarnings("unchecked")    </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">remove</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();        </span><br><span class="line">    <span class="keyword">try</span> &#123;            </span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)                </span><br><span class="line">            notEmpty.await();            </span><br><span class="line">        Object x = items[removeIndex];            </span><br><span class="line">        <span class="keyword">if</span> (++removeIndex == items.length)                </span><br><span class="line">            removeIndex = <span class="number">0</span>;            </span><br><span class="line">        --count;            </span><br><span class="line">        notFull.signal();            </span><br><span class="line">        <span class="keyword">return</span> (T) x;        </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line">        lock.unlock();        </span><br><span class="line">        &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的。</p>
<p>Condition的使用方式比较简单，需要注意在调用方法前获取锁。当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p>
<h1 id="Condition的实现分析"><a href="#Condition的实现分析" class="headerlink" title="Condition的实现分析"></a>Condition的实现分析</h1><ol>
<li>等待队列</li>
</ol>
<p><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/ConditionQueue.png?raw=true" alt=""><br>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。<br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/JoinConditionQueue.png?raw=true" alt=""><br>调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。<br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/removeFromConditionQueue.png?raw=true" alt=""></p>
]]></content>
      <categories>
        <category>Java Concurrent</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS</title>
    <url>/2020/05/10/Java%20Concurrent/AQS/</url>
    <content><![CDATA[<p><a href="https://segmentfault.com/a/1190000017372067" target="_blank" rel="noopener">AQS</a></p>
<p>AbstractQueuedSynchronizer</p>
<p>Sync extends AbstractQueuedSynchronizer</p>
<p>Sync 有两个主要的实现类 NofairSync，FailSync</p>
<h2 id="NofairSync-lock"><a href="#NofairSync-lock" class="headerlink" title="NofairSync.lock()"></a>NofairSync.lock()</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">//通过cas操作来修改state状态，表示争抢锁的操作</span></span><br><span class="line">		setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置当前获得锁状态的线程</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		acquire(<span class="number">1</span>); <span class="comment">//尝试去获取锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">		selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//获得当前执行的线程</span></span><br><span class="line">	<span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">	<span class="keyword">int</span> c = getState(); <span class="comment">//获得state的值</span></span><br><span class="line">	<span class="keyword">if</span> (c == <span class="number">0</span>) &#123; <span class="comment">//state=0说明当前是无锁状态</span></span><br><span class="line">		<span class="comment">//通过cas操作来替换state的值改为1</span></span><br><span class="line">		<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">			<span class="comment">//保存当前获得锁的线程</span></span><br><span class="line">			setExclusiveOwnerThread(current);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//这段逻辑就很简单了。如果是同一个线程来获得锁，则直接增加重入次数</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">		<span class="keyword">int</span> nextc = c + acquires; <span class="comment">//增加重入次数</span></span><br><span class="line">		<span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">		setState(nextc);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//自旋</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		Node t = tail; <span class="comment">//如果是第一次添加到队列，那么tail=null</span></span><br><span class="line">		<span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">			<span class="comment">//CAS的方式创建一个空的Node作为头结点</span></span><br><span class="line">			<span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">			<span class="comment">//此时队列中只一个头结点，所以tail也指向它</span></span><br><span class="line">			tail = head;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">//进行第二次循环时，tail不为null，进入else区域。将当前线程的Node结点的prev指向tail，然后使用CAS将tail指向Node</span></span><br><span class="line">			node.prev = t;</span><br><span class="line">			<span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">			<span class="comment">//t此时指向tail,所以可以CAS成功，将tail重新指向Node。此时t为更新前的tail的值，即指向空的头结点，t.next=node，就将头结点的后续结点指向Node，返回头结点</span></span><br><span class="line">				t.next = node;</span><br><span class="line">				<span class="keyword">return</span> t;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123; <span class="comment">//mode=Node.EXCLUSIVE</span></span><br><span class="line">	<span class="comment">//将当前线程封装成Node，并且mode为独占锁</span></span><br><span class="line">	Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">	<span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">	<span class="comment">// tail是AQS的中表示同步队列队尾的属性，刚开始为null，所以进行enq(node)方法</span></span><br><span class="line">	Node pred = tail;</span><br><span class="line">	<span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">//tail不为空的情况，说明队列中存在节点数据</span></span><br><span class="line">		node.prev = pred; <span class="comment">//讲当前线程的Node的prev节点指向tail</span></span><br><span class="line">		<span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;<span class="comment">//通过cas讲node添加到AQS队列</span></span><br><span class="line">			pred.next = node;<span class="comment">//cas成功，把旧的tail的next指针指向新的tail</span></span><br><span class="line">			<span class="keyword">return</span> node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	enq(node); <span class="comment">//tail=null，将node添加到同步队列中</span></span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">// 获取prev节点,若为null即刻抛出NullPointException</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="comment">// 如果前驱为head才有资格进行锁的抢夺</span></span><br><span class="line">                setHead(node); <span class="comment">// 获取锁成功后就不需要再进行同步操作了,获取锁成功的线程作为新的head节点</span></span><br><span class="line"><span class="comment">//凡是head节点,head.thread与head.prev永远为null, 但是head.next不为null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">//获取锁成功</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//如果获取锁失败，则根据节点的waitStatus决定是否需要挂起线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">// 若前面为true,则执行挂起,待下次唤醒的时候检测中断的标志</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果抛出异常则取消锁的获取,进行出队(sync queue)操作</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus; <span class="comment">//前继节点的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)<span class="comment">//如果是SIGNAL状态，意味着当前线程需要被unpark唤醒</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//如果前节点的状态大于0，即为CANCELLED状态时，则会从前节点开始逐步循环找到一个没有被“CANCELLED”节点设置为当前节点的前节点，返回false。在下次循环执行shouldParkAfterFailedAcquire时，返回true。这个操作实际是把队列中CANCELLED的节点剔除掉。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果前继节点是“取消”状态，则设置 “当前节点”的 “当前前继节点” 为 “‘原前继节点'的前继节点”。</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果前继节点为“0”或者“共享锁”状态，则设置前继节点为SIGNAL状态。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ReentrantLock-unlock"><a href="#ReentrantLock-unlock" class="headerlink" title="ReentrantLock.unlock"></a>ReentrantLock.unlock</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases; <span class="comment">// 这里是将锁的数量减1</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<span class="comment">// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123; </span><br><span class="line"><span class="comment">// 由于重入的关系，不是每次释放锁c都等于0，</span></span><br><span class="line">    <span class="comment">// 直到最后一次释放锁时，才会把当前线程释放</span></span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//判断后继节点是否为空或者是否是取消状态,</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) <span class="comment">//然后从队列尾部向前遍历找到最前面的一个waitStatus小于0的节点, 至于为什么从尾部开始向前遍历，因为在doAcquireInterruptibly.cancelAcquire方法的处理过程中只设置了next的变化，没有设置prev的变化，在最后有这样一行代码：node.next = node，如果这时执行了unparkSuccessor方法，并且向后遍历的话，就成了死循环了，所以这时只有prev是稳定的</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//内部首先会发生的动作是获取head节点的next节点，如果获取到的节点不为空，则直接通过：“LockSupport.unpark()”方法来释放对应的被挂起的线程，这样一来将会有一个节点唤醒后继续进入循环进一步尝试tryAcquire()方法来获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread); <span class="comment">//释放许可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java Concurrent</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程的艺术 第三章：Java内存模型</title>
    <url>/2020/05/10/Java%20Concurrent/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%20%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="3-Java内存模型"><a href="#3-Java内存模型" class="headerlink" title="3. Java内存模型"></a>3. Java内存模型</h1><p>Java线程之间的通信对程序员完全透明，内存可见性问题很容易困扰Java程序员。</p>
<ul>
<li>Java内存模型的基础：主要介绍内存模型相关的基本概念；</li>
<li>Java内存模型中的顺序一致性：主要介绍重排序与顺序一致性内存模型；</li>
<li>同步原语：主要介绍3个同步原语（synchronized、volatile和final）的内存语义及重排序规则在处理器<br>中的实现；</li>
<li>Java内存模型的设计：主要介绍Java内存模型的设计原理，及其与处理器内存模型和顺序一致性内存模型的关系。</li>
</ul>
<h2 id="3-1-Java内存模型的基础"><a href="#3-1-Java内存模型的基础" class="headerlink" title="3.1 Java内存模型的基础"></a>3.1 Java内存模型的基础</h2><h3 id="3-1-1-并发编程模型的两个关键问题"><a href="#3-1-1-并发编程模型的两个关键问题" class="headerlink" title="3.1.1 并发编程模型的两个关键问题"></a>3.1.1 并发编程模型的两个关键问题</h3><ol>
<li><strong>线程之间的通信</strong>  <ul>
<li>共享内存</li>
<li>消息传递</li>
</ul>
</li>
<li><strong>线程之间的同步</strong><ul>
<li>在共享内存并发模型中，同步是显示进行的</li>
<li>在消息传递并发模型中，由于消息的发送必须在消息的接收之前，同步是隐式进行</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-1-2-Java内存模型的抽象结构"><a href="#3-1-2-Java内存模型的抽象结构" class="headerlink" title="3.1.2 Java内存模型的抽象结构"></a>3.1.2 Java内存模型的抽象结构</h3><p>实例域，静态域和数组存储在堆内存中，多线程共享（共享变量）。<br>局部变量，方法定义参数和异常处理器参数不在线程之间共享，所以不会有内存可见性问题，也不受内存模型的影响。</p>
<p><strong>Java线程之间的通信由Java内存模型JMM控制, JMM决定一个线程对共享变量的写入何时对另一个线程可见</strong></p>
<ul>
<li><p>JMM定义了线程和主内存之间的抽象关系<br>  线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。</p>
<ul>
<li>本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化</li>
</ul>
</li>
<li><p>JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</p>
</li>
</ul>
<hr>
<h3 id="3-1-3-从源代码到指令序列的重排序"><a href="#3-1-3-从源代码到指令序列的重排序" class="headerlink" title="3.1.3 从源代码到指令序列的重排序"></a>3.1.3 从源代码到指令序列的重排序</h3><ol>
<li><strong>编译器优化的重排序</strong><br>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li><strong>指令级并行的重排序</strong><br>现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li><strong>内存系统的重排序</strong><br>由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ol>
<p>对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障（Memory Barriers，Intel称之为Memory Fence）指令，通过<strong>内存屏障指令</strong>来禁止特定类型的处理器重排序。</p>
<h3 id="3-1-4-并发编程模型的分类"><a href="#3-1-4-并发编程模型的分类" class="headerlink" title="3.1.4 并发编程模型的分类"></a>3.1.4 并发编程模型的分类</h3><p>现代处理器使用写缓冲区临时保存向内存写入的数据。</p>
<p>优点：</p>
<ul>
<li><p>保证指令流水线式持续运行，避免由于处理器停顿等待向内存写入数据而产生的延迟。</p>
</li>
<li><p>通过批处理的方式刷新写缓冲区，以及合并写缓冲区对同一内存地址的多次写，可以减少对内存总线的占用</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>每个处理器上的写缓冲区仅仅对其自己可见，处理器对内存的读写操作的执行顺序，并不一定与内存实际发生的读写顺序一致。</li>
</ul>
<p>为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p>
<table>
<thead>
<tr>
<th align="left">屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LoadLoad Barriers</td>
<td>Load 1; LoadLoad; Load 2</td>
<td>确保Load 1 数据的装载先于 <br/>Load 2 及后续所有装载指令的装载</td>
</tr>
<tr>
<td align="left">StoreStore Barriers</td>
<td>Store 1; StoreStore; Store 2</td>
<td>确保 Store1 的数据对其他处理器可见<br/>(刷新到内存)先于 Store2 及后续存储指令的存储</td>
</tr>
<tr>
<td align="left">LoadStore Barriers</td>
<td>Load 1; LoadStore; Store 2</td>
<td>确保Load 1 数据的装载先于 <br/>Store 2 及后续的存储指令刷新到内存</td>
</tr>
<tr>
<td align="left">StoreLoad Barriers</td>
<td>Store 1; StoreLoad; Load 2</td>
<td>确保 Store1 的数据对其他处理器可见<br/>(刷新到内存)先于 Load 2 及后续装载指令的装载。</td>
</tr>
</tbody></table>
<p>StoreLoad Barriers 是一个“全能型” 的屏障，执行该屏障开销大，因为当前处理器会把写缓冲区中的数据全部刷新到内存中。</p>
<hr>
<h3 id="3-1-5-happens-before简介"><a href="#3-1-5-happens-before简介" class="headerlink" title="3.1.5 happens-before简介"></a>3.1.5 happens-before简介</h3><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关<br>系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p>
<ul>
<li>the first is visible to and ordered before the second</li>
<li>一个happens-before规则对应于一个或多个编译器和处理器重排序规则</li>
</ul>
<ol>
<li><strong>程序顺序规则</strong><br>一个线程中的每个操作，happens-before于线程中的任意后续操作</li>
<li><strong>监视器锁规则</strong><br>对一个锁的解锁，happens-before于随后对这个锁的加锁</li>
<li><strong>volatile变量规则</strong><br>对一个volatile域的写，happens-before于任意后续对这个volatile域的读</li>
<li><strong>传递性</strong></li>
</ol>
<hr>
<h2 id="3-2-重排序"><a href="#3-2-重排序" class="headerlink" title="3.2 重排序"></a>3.2 重排序</h2><p>重排序是指编译器和处理器为了优化程序性能而对<strong>指令序列进行重新排序</strong>的一种手段。</p>
<h3 id="3-2-1-数据依赖性"><a href="#3-2-1-数据依赖性" class="headerlink" title="3.2.1 数据依赖性"></a>3.2.1 数据依赖性</h3><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性</p>
<p>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p>
<h3 id="3-2-2-as-if-serial-语义"><a href="#3-2-2-as-if-serial-语义" class="headerlink" title="3.2.2 as-if-serial 语义"></a>3.2.2 as-if-serial 语义</h3><p>as-if-serial 语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>as-if-serial 语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p>
<h3 id="3-2-3-程序顺序规则"><a href="#3-2-3-程序顺序规则" class="headerlink" title="3.2.3 程序顺序规则"></a>3.2.3 程序顺序规则</h3><p>在不改变程序执行结果的前提下，尽可能提高并行度。</p>
<h3 id="3-2-4-重排序对多线程的影响"><a href="#3-2-4-重排序对多线程的影响" class="headerlink" title="3.2.4 重排序对多线程的影响"></a>3.2.4 重排序对多线程的影响</h3><p>代码中存在控制依赖性时，会影响指令序列执行的并行度。为此，编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲（Reorder Buffer，ROB）的硬件缓存中。当操作3的条<br>件判断为真时，就把该计算结果写入变量i中。</p>
<h2 id="3-3-顺序一致性"><a href="#3-3-顺序一致性" class="headerlink" title="3.3 顺序一致性"></a>3.3 顺序一致性</h2><p>顺序一致性内存模型是一个理论参考模型。</p>
<h3 id="3-3-1-数据竞争和顺序一致性"><a href="#3-3-1-数据竞争和顺序一致性" class="headerlink" title="3.3.1 数据竞争和顺序一致性"></a>3.3.1 数据竞争和顺序一致性</h3>]]></content>
      <categories>
        <category>Java Concurrent</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap</title>
    <url>/2020/05/10/Java%20%E5%AE%B9%E5%99%A8/ConcurrentHashMap/</url>
    <content><![CDATA[<p>JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树,相对而言，总结如下思考</p>
<ol>
<li><p>JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度是基于Segment的，包含多个HashEntry，而JDK1.8锁的粒度就是HashEntry（首节点）</p>
</li>
<li><p>JDK1.8版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用synchronized来进行同步，所以不需要分段锁的概念，也就不需要Segment这种数据结构了，由于粒度的降低，实现的复杂度也增加了</p>
</li>
<li><p>JDK1.8使用红黑树来优化链表，基于长度很长的链表的遍历是一个很漫长的过程，而红黑树的遍历效率是很快的，代替一定阈值的链表，这样形成一个最佳拍档</p>
</li>
<li><p>JDK1.8为什么使用内置锁synchronized来代替重入锁ReentrantLock，我觉得有以下几点 </p>
<ul>
<li><p>因为粒度降低了，在相对而言的低粒度加锁方式，synchronized并不比ReentrantLock差，在粗粒度加锁中ReentrantLock可能通过Condition来控制各个低粒度的边界，更加的灵活，而在低粒度中，Condition的优势就没有了</p>
</li>
<li><p>JVM的开发团队从来都没有放弃synchronized，而且基于JVM的synchronized优化空间更大，使用内嵌的关键字比使用API更加自然</p>
</li>
<li><p>在大量的数据操作下，对于JVM的内存压力，基于API的ReentrantLock会开销更多的内存，虽然不是瓶颈，但是也是一个选择依据</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java 容器</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从Paxos到Zookeeper 第一章：分布式架构</title>
    <url>/2020/05/10/Distributed%20System/%E4%BB%8EPaxos%E5%88%B0Zookeeper%20%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="第一章：分布式架构"><a href="#第一章：分布式架构" class="headerlink" title="第一章：分布式架构"></a>第一章：分布式架构</h1><h2 id="从集中式到分布式"><a href="#从集中式到分布式" class="headerlink" title="从集中式到分布式"></a>从集中式到分布式</h2><ul>
<li><p>分布式系统的定义：分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p>
</li>
<li><p>分布式环境的各种问题：</p>
<ul>
<li>通信异常</li>
<li>网络分区：当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点能够进行正常的通信，俗称“脑裂”</li>
<li>三态：成功、失败和超时</li>
<li>节点故障</li>
</ul>
</li>
</ul>
<h2 id="从ACID到CAP-BASE"><a href="#从ACID到CAP-BASE" class="headerlink" title="从ACID到CAP/BASE"></a>从ACID到CAP/BASE</h2><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>一个分布式系统不可能同时满足 一致性(C: Consistency)、可用性(A: Availability) 和分区容错性(P: Partition tolerance) 这三个基本需求，最多只能同时满足其中两项。</p>
<ul>
<li>一致性：在分布式系统中，一致性是指数据在多个副本之间是否能够保持一致的特性。</li>
<li>可用性：可用性是指系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</li>
<li>分区容错性：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</li>
</ul>
<p><img src="https://github.com/Wayne-98/image/blob/master/Distributed%20System/cap.png?raw=true" alt=""></p>
<ul>
<li>分区容错性是一个最基本的需求。因为既然是一个分布式系统，那么分布式系统的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了，因此必然会出现子网络。而对于分布式系统而言，网络问题又是一个必然会出现的异常情况，因此分区容错性也就成了一个分布式系统必然需要面对和解决的问题。因此系统架构师往往需要把精力花在如何根据业务特点在C（一致性）和 A （可用性）之间寻求平衡。</li>
</ul>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>BASE 是  Basically Available(基本可用)、Soft State(软状态) 和 Eventually Consistent(最终一致性) 三个短语的简写。</p>
<p>BASE 是对 CAP 中一致性和可用性权衡的结果， 其来源于对大规模互联网系统分布式实践的总结，基于 CAP 定理逐渐演化而来，其核心思想是即使无法做到 强一致性(Strong consistency)，但每个应用可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)。</p>
<ul>
<li>基本可用：分布式系统在出现不可预知的故障的时候，允许损失部分可用性。</li>
<li>弱状态(软状态)：是指系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</li>
<li>最终一致性：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。最终一致性的本质是需要系统保证最终数据能够达成一致，而不需要实时保证系统数据的强一致性。</li>
</ul>
<p>最终一致性的主要变种：</p>
<ol>
<li>因果一致性(Causal consistency)：如果进程 A 在更新完某个数据项后通知了进程 B ，那么进程 B 之后对该数据项的访问都应该能够获取到进程 A 更新后的最新值，并且如果进程 B 要对该数据项进行更新操作的话，务必基于进程 A 更新后的最新值，即不能发生丢失更新的情况。</li>
<li>读己之所写(Read your writes)：进程 A 更新一个数据项之后，它总是能够访问到更新后的最新值，而不会看到旧值。</li>
<li>会话一致性(Session consistency)：会话一致性将对系统数据的访问过程框定在一个会话当中：系统能够保证在同一个有效的会话中实现“读己之所写”的一致性。也就是说，执行更新操作后，客户端能够在同一个会话中始终读取到该数据项的最新值。</li>
<li>单调读一致性(Monotonic read consistency)：如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。</li>
<li>单调写一致性(Monotonic write consistency)：一个系统需要能够保证来自同一个进程的写操作被顺序地执行。</li>
</ol>
]]></content>
      <categories>
        <category>从Paxos到Zookeeper</category>
      </categories>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程的艺术 第二章：Java并发机制的底层实现原理</title>
    <url>/2020/05/10/Java%20Concurrent/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9AJava%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Java并发编程的艺术-第二章"><a href="#Java并发编程的艺术-第二章" class="headerlink" title="Java并发编程的艺术 第二章"></a>Java并发编程的艺术 第二章</h1><p>Java代码在编译后会变成Java字节码，字节码被类加载器加载到JVM里，JVM执行字节码，最终需要转化为汇编指令在CPU上执行，Java中所使用的并发机制依赖于<strong>JVM的实现</strong>和<strong>CPU的指令</strong>。</p>
<h2 id="volatile的应用"><a href="#volatile的应用" class="headerlink" title="volatile的应用"></a>volatile的应用</h2><h3 id="volatile的定义以及实现原理"><a href="#volatile的定义以及实现原理" class="headerlink" title="volatile的定义以及实现原理"></a>volatile的定义以及实现原理</h3><ul>
<li><strong>有什么作用？</strong><br>Java线程内存模型确保所有线程看到这个变量的值是一致的。</li>
<li><strong>volatile是如何来保证可见性的呢？</strong><ol>
<li>将当前处理器缓存行的数据写回到系统内存。<br>（Lock前缀指令会引起处理器缓存回写到内存。）</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。<br>（一个处理器的缓存回写到内存会导致其他处理器的缓存无效。）</li>
</ol>
</li>
<li><strong>缓存一致性协议</strong><br>每个处理器通过嗅探在总线上传播的数据来检查自己的缓存是不是过期了，这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。</li>
</ul>
<hr>
<h2 id="synchronized的实现原理与应用"><a href="#synchronized的实现原理与应用" class="headerlink" title="synchronized的实现原理与应用"></a>synchronized的实现原理与应用</h2><ul>
<li><p><strong>实现的基础</strong><br>Java中的每一个对象都可以作为锁。</p>
<ol>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的Class对象。</li>
<li>对于同步方法块，锁是Synchronized括号里配置的对象。</li>
</ol>
</li>
</ul>
<p>当一个线程访问同步代码块时，必须得到锁，退出或抛出异常时必须释放锁。</p>
<h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><ul>
<li><p><strong>synchronized用的锁是存在Java对象头里的</strong></p>
<ol>
<li>Mark Word<br>存储对象的 HashCode、分代年龄和锁标记位</li>
<li>Class Metadata Address<br>存储到对象类型的指针</li>
<li>Array Length<br>如果是数组对象，则需要记录数组的长度</li>
</ol>
<hr>
</li>
<li><p><strong>Mark Word的存储格式</strong><br>在32位系统上mark word长度为32bit，64位系统上长度为64bit。<br>为了能在有限的空间里存储下更多的数据，其存储格式是不固定的，在32位系统上各状态的格式如下：<br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/MarkWord.png?raw=true" alt=""><br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/MarkWord1.png?raw=true" alt=""></p>
</li>
</ul>
<ol>
<li>当对象状态为偏向锁（biasable）时，mark word 存储的是偏向的线程 ID；</li>
<li>当状态为轻量级锁（lightweight locked）时，mark word存储的是指向线程栈中Lock Record的指针；</li>
<li>当状态为重量级锁（inflated）时，为指向堆中的monitor对象的指针。</li>
</ol>
<hr>
<ul>
<li><strong>Synchonized在JVM里的实现原理</strong><br><code>javap -v 查看class文件对应的JVM字节码信息.</code><br>对于synchronized关键字而言，javac在编译时，会生成对应的monitorenter和monitorexit指令分别对应synchronized同步块的进入和退出<ul>
<li><strong>synchronized 修饰一个同步块的时候</strong><br>一个monitorenter指令和两个monitorexit指令。<ul>
<li>原因是：为了保证抛异常的情况下也能释放锁，所以javac为同步代码块添加了一个隐式的try-finally，在finally中会调用monitorexit命令释放锁。<ul>
<li><strong>synchronized 修饰一个方法的时候</strong><br>javac为其生成了一个ACC_SYNCHRONIZED关键字，在JVM进行方法调用时，发现调用的方法被ACC_SYNCHRONIZED修饰，则会先尝试获得锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="锁的升级与对比"><a href="#锁的升级与对比" class="headerlink" title="锁的升级与对比"></a>锁的升级与对比</h3><ul>
<li><p><strong>锁的状态</strong></p>
<p>  无锁状态–&gt;偏向锁状态–&gt;轻量级锁状态–&gt;重量级锁状态<br>  锁可以升级但是不可以降级（为了提高锁获得和锁释放的效率）</p>
</li>
</ul>
<hr>
<ul>
<li><p><strong>重量级锁</strong><br>重量级锁是我们常说的传统意义上的锁，其利用操作系统底层的同步机制去实现Java中的线程同步。<br>重量级锁的状态下，对象的mark word为指向一个堆中monitor对象的指针。<br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/Monitor.png?raw=true" alt=""></p>
</li>
<li><p>Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；</p>
</li>
<li><p>Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中；</p>
</li>
<li><p>Wait Set：哪些调用wait方法被阻塞的线程被放置在这里；</p>
</li>
<li><p>OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被称为OnDeck；</p>
</li>
<li><p>Owner：当前已经获取到所资源的线程被称为Owner；</p>
</li>
<li><p>!Owner：当前释放锁的线程。</p>
</li>
</ul>
<hr>
<ul>
<li><p>线程获取重量级锁的过程</p>
<ul>
<li>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到Contention List的队列尾部，然后暂停当前线程；</li>
<li>当持有锁的线程释放锁前，会将Contention List中的所有元素移动到Entry List中去，并唤醒Entry List的队首线程。</li>
<li>如果一个线程在同步块中调用了Object#wait方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁；</li>
<li>当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</li>
</ul>
<hr>
</li>
<li><p><strong>轻量级锁</strong></p>
<ul>
<li><strong>为什么引入轻量级锁？</strong><br>  在 Java 程序运行时，同步块中的代码都是不存在竞争的，不同的线程交替的执行同步块中的代码。这种情况下，用重量级锁是没必要的。因此 JVM 引入了轻量级锁的概念。</li>
</ul>
</li>
</ul>
<p>线程在执行同步块之前，JVM 会先在当前的线程的栈帧中创建一个 Lock Record，其包括一个用于存储对象头中的  mark word（官方称之为 Displaced Mark Word）以及一个指向对象的指针。下图右边的部分就是一个 Lock Record 。<br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/LockRecord.png?raw=true" alt=""></p>
<ul>
<li><strong>加锁过程</strong><br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/Locking.png?raw=true" alt=""><br><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/Locking1.png?raw=true" alt=""></li>
</ul>
<ol>
<li>在线程栈中创建一个Lock Record，将其obj（即上图的Object reference）字段指向锁对象。</li>
<li>直接通过CAS指令将Lock Record的地址存储在对象头的mark word中，如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。如果失败，进入到步骤3。</li>
<li>如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分（Displaced Mark Word）为null，起到了一个重入计数器的作用。然后结束。</li>
<li>走到这一步说明发生了竞争，需要膨胀为重量级锁。</li>
</ol>
<ul>
<li><strong>解锁过程</strong> </li>
</ul>
<ol>
<li>遍历线程栈,找到所有obj字段等于当前锁对象的Lock Record。</li>
<li>如果Lock Record的Displaced Mark Word为null，代表这是一次重入，将obj设置为null后continue。</li>
<li>如果Lock Record的Displaced Mark Word不为null，则利用CAS指令将对象头的mark word恢复成为Displaced Mark Word。如果成功，则continue，否则膨胀为重量级锁。</li>
</ol>
<hr>
<ul>
<li><strong>偏向锁</strong><ul>
<li><strong>为什么引入偏向锁？</strong><br>偏向锁是在针对轻量级锁在没有竞争的情况下作出的优化,降低无竞争情况下获取锁的开销。</li>
<li><strong>对象创建</strong><br>  当JVM启用了偏向锁模式（1.6以上默认开启），当新创建一个对象的时候，如果该对象所属的class没有关闭偏向锁模式，那新创建对象的mark word将是可偏向状态，此时mark word中的thread id为0，表示未偏向任何线程，也叫做匿名偏向(anonymously biased)。</li>
<li><strong>加锁过程</strong><ol>
<li>当该对象第一次被线程获得锁的时候，发现是匿名偏向状态，则会用CAS指令，将mark word中的thread id由0改成当前线程Id。如果成功，则代表获得了偏向锁，继续执行同步块中的代码。否则，将偏向锁撤销，升级为轻量级锁。</li>
<li>当被偏向的线程再次进入同步块时，发现锁对象偏向的就是当前线程，在通过一些额外的检查后，会往当前线程的栈中添加一条Displaced Mark Word为空的Lock Record中，然后继续执行同步块的代码，因为操纵的是线程私有的栈，因此不需要用到CAS指令；由此可见偏向锁模式下，当被偏向的线程再次尝试获得锁时，仅仅进行几个简单的操作就可以了，在这种情况下，synchronized关键字带来的性能开销基本可以忽略。</li>
<li>当其他线程进入同步块时，发现已经有偏向的线程了，则会进入到撤销偏向锁的逻辑里，一般来说，会在safepoint中去查看偏向的线程是否还存活，如果存活且还在同步块中则将锁升级为轻量级锁，原偏向的线程继续拥有锁，当前线程则走入到锁升级的逻辑里；如果偏向的线程已经不存活或者不在同步块中，则将对象头的mark word改为无锁状态（unlocked），之后再升级为轻量级锁。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>由此可见，偏向锁升级的时机为：当锁已经发生偏向后，只要有另一个线程尝试获得偏向锁，则该偏向锁就会升级成轻量级锁。当然这个说法不绝对，因为还有批量重偏向这一机制。</p>
<hr>
<ul>
<li><strong>偏向锁的撤销</strong></li>
</ul>
<p>当有其他线程尝试获得锁时，是根据遍历偏向线程的lock record来确定该线程是否还在执行同步块中的代码。因此偏向锁的解锁很简单，仅仅将栈中的最近一条lock record的obj字段设置为null。需要注意的是，偏向锁的解锁步骤中并不会修改对象头中的thread id。   </p>
<p>偏向锁默认不是立即就启动的，在程序启动后，通常有几秒的延迟，可以通过命令<br>-XX:BiasedLockingStartupDelay=0来关闭延迟</p>
<hr>
<ul>
<li><strong>批量重偏向与撤销</strong><ul>
<li><strong>为什么要引入批量重偏向与撤销？</strong><br>从上文偏向锁的加锁解锁过程中可以看出，当只有一个线程反复进入同步块时，偏向锁带来的性能开销基本可以忽略，但是当有其他线程尝试获得锁时，就需要等到safepoint时将偏向锁撤销为无锁状态或升级为轻量级/重量级锁。总之，偏向锁的撤销是有一定成本的，如果说运行时的场景本身存在多线程竞争的，那偏向锁的存在不仅不能提高性能，而且会导致性能下降。因此，JVM中增加了一种批量重偏向/撤销的机制。</li>
<li><strong>存在两种情况会导致偏向锁降低性能</strong></li>
</ul>
<ol>
<li>一个线程创建了大量对象并执行了初始的同步操作，之后在另一个线程中将这些对象作为锁进行之后的操作。这种case下，会导致大量的偏向锁撤销操作。</li>
<li>存在明显多线程竞争的场景下使用偏向锁是不合适的，例如生产者/消费者队列。</li>
</ol>
</li>
</ul>
<p>批量重偏向（bulk rebias）机制是为了解决第一种场景。批量撤销（bulk revoke）则是为了解决第二种场景。</p>
<ul>
<li><strong>做法</strong><ol>
<li>以class为单位，为每个class维护一个偏向锁撤销计数器，每一次该class的对象发生偏向撤销操作时，该计数器+1，当这个值达到重偏向阈值（默认20）时，JVM就认为该class的偏向锁有问题，因此会进行批量重偏向。 </li>
<li>每个class对象会有一个对应的epoch字段，每个处于偏向锁状态对象的mark word中也有该字段，其初始值为创建该对象时class中的epoch的值。每次发生批量重偏向时，就将该值+1，同时遍历JVM中所有线程的栈，找到该class所有正处于加锁状态的偏向锁，将其epoch字段改为新值。下次获得锁时，发现当前对象的epoch值和class的epoch不相等，那就算当前已经偏向了其他线程，也不会执行撤销操作，而是直接通过CAS操作将其mark word的Thread Id 改成当前线程Id。 </li>
<li>当达到重偏向阈值后，假设该class计数器继续增长，当其达到批量撤销的阈值后（默认40），JVM就认为该class的使用场景存在多线程竞争，会标记该class为不可偏向，之后，对于该class的锁，直接走轻量级锁的逻辑。</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li><strong>End</strong><br>Java中的synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应了锁只被一个线程持有、不同线程交替持有锁、多线程竞争锁三种情况。当条件不满足时，锁会按偏向锁-&gt;轻量级锁-&gt;重量级锁 的顺序升级。JVM种的锁也是能降级的，只不过条件很苛刻，暂不讨论。</li>
</ul>
<hr>
<h2 id="原子操作的实现原理"><a href="#原子操作的实现原理" class="headerlink" title="原子操作的实现原理"></a>原子操作的实现原理</h2><ul>
<li><strong>处理器实现原子操作</strong></li>
</ul>
<ol>
<li>通过总线锁保证原子性。总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</li>
<li>通过缓存锁定来保证原子性。缓存一致性协议</li>
</ol>
<ul>
<li><strong>Java实现原子操作</strong></li>
</ul>
<ol>
<li>循环CAS实现原子操作<br>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = get();</span><br><span class="line">        <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line">            <span class="keyword">return</span> next;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<ol start="2">
<li>CAS实现原子操作的三大问题</li>
</ol>
<ul>
<li><strong>ABA问题</strong><br>如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A</li>
<li><strong>循环时间长开销大</strong><br>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。<ul>
<li>pause指令有两个作用：<ol>
<li>它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。</li>
<li>它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。</li>
</ol>
</li>
</ul>
</li>
<li><strong>只能保证一个共享变量的原子操作</strong><ol>
<li>用锁机制。</li>
<li>把多个共享变量合并成一个共享变量来操作。</li>
</ol>
</li>
</ul>
<hr>
<ol start="3">
<li>使用锁机制实现原子操作<br>除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</li>
</ol>
]]></content>
      <categories>
        <category>Java Concurrent</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap</title>
    <url>/2020/05/10/Java%20%E5%AE%B9%E5%99%A8/HashMap/</url>
    <content><![CDATA[<p>java.util.Map 的实现类主要有四个常用的：HashMap、Hashtable、LinkedHashMap和TreeMap</p>
<p>(1) HashMap：<strong>遍历顺序不确定</strong>， HashMap最多只<strong>允许一条记录的</strong>键为null。HashMap非线程安全。</p>
<p>(2) Hashtable：<strong>线程安全的</strong>(sync)，Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<p>(3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的<strong>插入顺序</strong>，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
<p>(4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是<strong>按键值的升序排序</strong>，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
<p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p>
<h2 id="存储结构字段"><a href="#存储结构字段" class="headerlink" title="存储结构字段"></a>存储结构字段</h2><ol>
<li>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用<strong>开放地址法</strong>和<strong>链地址法</strong>等来解决问题，Java中HashMap采用了链地址法。</li>
</ol>
<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在<strong>空间成本和时间成本</strong>之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是<strong>好的Hash算法和扩容机制</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">int</span> modCount;  <span class="comment">//记录HashMap内部结构发生变化的次数</span></span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<p>Node[] table的初始化长度length(默认值是<strong>16</strong>)，Load factor为负载因子(默认值是<strong>0.75</strong>)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的<strong>两倍</strong>。<strong>默认的负载因子0.75是对空间和时间效率的一个平衡选择</strong>，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果<strong>内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值</strong>；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<p>哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数。<strong>当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</strong></p>
<p>负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。</p>
<h2 id="功能实现-方法"><a href="#功能实现-方法" class="headerlink" title="功能实现-方法"></a>功能实现-方法</h2><h3 id="1-确定哈希桶数组索引位置"><a href="#1-确定哈希桶数组索引位置" class="headerlink" title="1. 确定哈希桶数组索引位置"></a>1. 确定哈希桶数组索引位置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></span><br><span class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span></span><br><span class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这里的Hash算法本质上就是三步：<strong>取key的hashCode值、高位运算、取模运算</strong>。</p>
<p><img src="https://github.com/Wayne-98/image/blob/master/Java%20%E5%AE%B9%E5%99%A8/hash.png?raw=true" alt=""></p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (<strong>h &gt;&gt;&gt; 16</strong>)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到<strong>高低Bit都参与到Hash的</strong>计算中，同时不会有太大的开销。</p>
<h2 id="2-分析HashMap的put方法"><a href="#2-分析HashMap的put方法" class="headerlink" title="2. 分析HashMap的put方法"></a>2. 分析HashMap的put方法</h2><p><img src="https://github.com/Wayne-98/image/blob/master/Java%20%E5%AE%B9%E5%99%A8/put.png?raw=true" alt=""></p>
<h2 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a>3. 扩容机制</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></span><br><span class="line"> <span class="number">2</span>     Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> oldCapacity = oldTable.length;         </span><br><span class="line"> <span class="number">4</span>     <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></span><br><span class="line"> <span class="number">5</span>         threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line"> <span class="number">6</span>         <span class="keyword">return</span>;</span><br><span class="line"> <span class="number">7</span>     &#125;</span><br><span class="line"> <span class="number">8</span>  </span><br><span class="line"> <span class="number">9</span>     Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></span><br><span class="line"><span class="number">10</span>     transfer(newTable);                         <span class="comment">//！！将数据转移到新的Entry数组里</span></span><br><span class="line"><span class="number">11</span>     table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></span><br><span class="line"><span class="number">12</span>     threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line"> <span class="number">2</span>     Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line"> <span class="number">4</span>     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></span><br><span class="line"> <span class="number">5</span>         Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></span><br><span class="line"> <span class="number">6</span>         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line"> <span class="number">7</span>             src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</span></span><br><span class="line"> <span class="number">8</span>             <span class="keyword">do</span> &#123;</span><br><span class="line"> <span class="number">9</span>                 Entry&lt;K,V&gt; next = e.next;</span><br><span class="line"><span class="number">10</span>                 <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//！！重新计算每个元素在数组中的位置</span></span><br><span class="line"><span class="number">11</span>                 e.next = newTable[i]; <span class="comment">//标记[1]</span></span><br><span class="line"><span class="number">12</span>                 newTable[i] = e;      <span class="comment">//将元素放在数组上</span></span><br><span class="line"><span class="number">13</span>                 e = next;             <span class="comment">//访问下一个Entry链上的元素</span></span><br><span class="line"><span class="number">14</span>             &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line"><span class="number">15</span>         &#125;</span><br><span class="line"><span class="number">16</span>     &#125;</span><br><span class="line"><span class="number">17</span> &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/Wayne-98/image/blob/master/Java%20%E5%AE%B9%E5%99%A8/transfer.png?raw=true" alt=""></p>
<p>我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="https://github.com/Wayne-98/image/blob/master/Java%20%E5%AE%B9%E5%99%A8/reHash.png?raw=true" alt=""></p>
<p><img src="https://github.com/Wayne-98/image/blob/master/Java%20%E5%AE%B9%E5%99%A8/OldCap.png?raw=true" alt=""></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p>
<h3 id="HashMap-线程不安全"><a href="#HashMap-线程不安全" class="headerlink" title="HashMap 线程不安全"></a>HashMap 线程不安全</h3><p>并发的多线程使用场景中使用HashMap可能造成死循环。主要是多线程同时put时，如果同时触发了rehash操作，会导致HashMap中的链表中出现循环节点，进而使得后面get的时候，会死循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapInfiniteLoop</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>，<span class="number">0.75f</span>);  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        map.put(<span class="number">5</span>， <span class="string">"C"</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread1"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">7</span>, <span class="string">"B"</span>);  </span><br><span class="line">                System.out.println(map);  </span><br><span class="line">            &#125;;  </span><br><span class="line">        &#125;.start();  </span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread2"</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">                map.put(<span class="number">3</span>, <span class="string">"A);  </span></span><br><span class="line"><span class="string">                System.out.println(map);  </span></span><br><span class="line"><span class="string">            &#125;;  </span></span><br><span class="line"><span class="string">        &#125;.start();        </span></span><br><span class="line"><span class="string">    &#125;  </span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>





<p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">主要参考与美团的文章：Java 8系列之重新认识HashMap</a></p>
]]></content>
      <categories>
        <category>Java 容器</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的线程池</title>
    <url>/2020/05/10/Java%20Concurrent/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p><strong>线程池的优点：</strong></p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
</ul>
<hr>
<h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p>提交一个新任务到线程池时，<strong>线程池的处理流程</strong>：</p>
<ol>
<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li>
<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程</li>
<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li>
</ol>
<hr>
<p><strong>ThreadPoolExecutor执行execute方法的4种情况：</strong></p>
<ol>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）</li>
<li>如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。</li>
<li>如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）。</li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法。</li>
</ol>
<p><img src="https://github.com/Wayne-98/image/blob/master/Java%20Concurrent/ThreadPollExecutor.png?raw=true" alt=""><br><strong>总体设计思路</strong></p>
<ul>
<li>是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）</li>
<li>在ThreadPoolExecutor完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。</li>
</ul>
<p><strong>工作线程</strong></p>
<ul>
<li>工作线程：线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会循环获取工作队列里的任务来执行<ul>
<li>线程池线程执行任务分两种情况：<ol>
<li>在execute()方法中创建一个线程时，会让这个线程执行当前任务。</li>
<li>这个线程执行完上述任务时，会反复从BlockingQueue获取任务来执行</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime,milliseconds,runnableTaskQueue, handler);</span><br></pre></td></tr></table></figure>
<ol>
<li><p>corePoolSize（线程池的基本大小）<br> 如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p>
</li>
<li><p>runnableTaskQueue（任务队列）</p>
<ul>
<li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</li>
<li><strong>LinkedBlockingQueue</strong>：一个基于链表结构的阻塞队列，此队列按 FIFO 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li><strong>SynchronousQueue</strong>：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlockingQueue，静态工厂方法 Executors.newCachedThreadPool 使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li>
</ul>
</li>
<li><p>maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</p>
</li>
<li><p>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</p>
</li>
<li><p>RejectedExecutionHandler（饱和策略）：</p>
<ul>
<li><p>AbortPolicy：直接抛出异常。（默认饱和处理策略）</p>
</li>
<li><p>CallerRunsPolicy：用“线程池正在运行的线程”来运行任务。(创建线程池的线程，一般是主线程)</p>
</li>
<li><p>DiscardOldestPolicy：当有任务添加到线程池被拒绝时，线程池会丢弃阻塞队列中末尾的任务，然后将被拒绝的任务添加到末尾</p>
</li>
<li><p>DiscardPolicy：不处理，丢弃掉。</p>
</li>
<li><p>自定义饱和处理策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(r,<span class="string">"新线程"</span>+<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>)).start();</span><br><span class="line">    &#125;<span class="comment">//让被拒绝的任务在一个新的线程中执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。</p>
<ul>
<li>如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</li>
</ul>
</li>
<li><p>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</p>
</li>
</ol>
<hr>
<h2 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h2><ul>
<li><strong>execute()</strong> 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功</li>
<li><strong>submit()</strong> 方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<hr>
<h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><ul>
<li><strong>shutdown或shutdownNow方法的执行原理：</strong><br>遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</li>
<li><strong>shutdown或shutdownNow方法的区别：</strong></li>
</ul>
<ol>
<li>shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表。</li>
<li>shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</li>
</ol>
<hr>
<h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><ol>
<li>当线程池创建后，初始为 running 状态</li>
<li>调用 shutdown 方法后，处 shutdown 状态，此时不再接受新的任务，等待已有的任务执行完毕</li>
<li>调用 shutdownnow 方法后，进入 stop 状态，不再接受新的任务，并且会尝试终止正在执行的任务。</li>
<li>当处于 shotdown 或 stop 状态，并且所有工作线程已经销毁，任务缓存队列已清空，线程池被设为 terminated 状态。<h2 id="合理使用线程池"><a href="#合理使用线程池" class="headerlink" title="合理使用线程池"></a>合理使用线程池</h2></li>
</ol>
<ul>
<li><strong>高并发、任务执行时间短的业务怎样使用线程池？</strong><br>  高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换</li>
<li><strong>并发不高、任务执行时间长的业务怎样使用线程池？</strong><ol>
<li>假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目，让CPU处理更多的业务</li>
<li>假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</li>
</ol>
</li>
<li><strong>并发高、业务执行时间长的业务怎样使用线程池？</strong><br>并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计。<ol>
<li>看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考</li>
<li>最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Java Concurrent</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从Paxos到Zookeeper 第二章：一致性协议</title>
    <url>/2020/05/10/Distributed%20System/%E4%BB%8EPaxos%E5%88%B0Zookeeper%20%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>在分布式系统中，每一个机器节点能够明确知道自己在进行事务操作中的结果的成败，但是无法直接获取到其他分布式节点的操作结果。因此，但一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的 ACID 的特性，就需要引入一个称为“协调者”（Coordinator）的组件来统一调度所有分布式节点的执行逻辑，这些被调度的节点被称为“参与者”（Participant）。协调者负责调度参与者的行为，并最终决定参与者是否要把事务真正进行提交。基于这个思想，衍生了二阶段提交和三阶段提交两种协议。</p>
<h2 id="2PC-Two-Phase-Commit"><a href="#2PC-Two-Phase-Commit" class="headerlink" title="2PC(Two-Phase Commit)"></a>2PC(Two-Phase Commit)</h2><p><strong>阶段一：提交事务请求</strong> （投票阶段：即各参与者投票表明是否要继续执行接下来的事务提交操作）</p>
<ol>
<li><p>事务询问</p>
<p>协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p>
</li>
<li><p>执行事务</p>
<p>各参与者节点执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。</p>
</li>
<li><p>各参与者向协调者反馈事务询问的响应</p>
<p>如果参与者成功执行了事务操作，那么就反馈给协调者 Yes 响应，表示事务可以执行</p>
</li>
</ol>
<p><strong>阶段二：执行事务提交</strong></p>
<ol>
<li><p>执行事务提交：所有的参与者反馈的都是 Yes 响应</p>
<ul>
<li>发送提交请求： 协调者向所有参与者发送 Commit 请求。</li>
<li>事务提交：参与者收到 Commit 请求后，会正式的执行事务提交操作，并在完成提交之后释放在整个事务期间占用的事务资源。</li>
<li>反馈事务提交结果：参与者在事务提交之后，向协调者发送 ACK 消息。</li>
<li>完成事务：协调者收到所有参与者反馈的 ACK 消息后，完成事务。</li>
</ul>
</li>
<li><p>中断事务：如果任何一个参与者向协调者发送了 No 响应，或者在等待超时之后，协调者尚无法收到所有参与者的反馈响应，那么就会中断事务。</p>
<ul>
<li>发送回滚请求：协调者向所有参与者发送 Rollback 请求。</li>
<li>事务回滚：参与者在收到 Rollback 请求后，会利用其在阶段一中记录的 Undo 信息来执行事务回滚操作，并在完成回滚后释放在整个事务期间占用的事务资源。</li>
<li>反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送 ACK 消息。</li>
<li>中断事务：协调者收到所有参与者反馈的 ACK 消息后，完成事务中断</li>
</ul>
</li>
</ol>
<hr>
<ul>
<li><strong>优点</strong>：原理简单，实现方便</li>
<li><strong>缺点</strong>：同步阻塞，单点问题，脑裂，太过保守<ul>
<li>同步阻塞：2PC 的执行过程中，所有参与该事务操作的逻辑都处于阻塞状态。也就是说，各个参与者在等待其他参与者响应的过程中，将无法进行其他任何操作。</li>
<li>单点问题：如果协调者崩了，那么其他参与者将会一直处于锁定事务资源的状态中，而无法继续完成事务操作。</li>
<li>数据不一致：2PC 的阶段二，即执行事务提交的时候，当协调者向所有的参与者发送 Commit 请求后，由于种种原因（局部网络异常，协调者尚未发送完所有 Commit 自身发生崩溃）导致最终只有部分参与者收到了 Commit 请求。那么收到 Commit 请求的参与者就会进行事务的提交，而其他没有收到 Commit 的参与者则无法进行事务提交。于是整个分布式系统出现了数据不一致的现象。</li>
<li>太过保守：如果在协调者指示参与者进行事务提交询问的过程中，参与者出现故障而导致协调者始终无法获取到所有参与者的相应信息的话，这时协调者只能依靠自身的超时机制来判断是否需要中断事务，这样的策略太过保守。 也就是 2PC 协议没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="3PC-Three-Phase-Commit"><a href="#3PC-Three-Phase-Commit" class="headerlink" title="3PC(Three-Phase Commit)"></a>3PC(Three-Phase Commit)</h2><p>是 2PC 的改进版，将二阶段提交协议的“提交事务请求”过程一分为二，形成了由 CanCommit、PreCommit 和 do Commit 三个阶段组成的事务处理协议。</p>
<p><strong>阶段一：CanCommit</strong></p>
<ol>
<li><p>事务询问：协调者向所有参与者发送一个包含事务内容的 CanCommit 请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p>
</li>
<li><p>各参与者向协调者反馈事务询问的响应：参与者在接收到来自协调者的 CanCommit请求后，正常情况下，如果其自身认为可以顺利执行事务，那么就会反馈 Yes 响应，并进入预备状态，否则反馈 No 响应。</p>
</li>
</ol>
<p><strong>阶段二：PreCommit</strong></p>
<p>在阶段二中，协调者会根据参与者的反馈情况来决定是否可以进行事务的 PreCommit 操作，正常情况下，包含两种情况</p>
<ul>
<li><p>执行事务预提交</p>
<p>假如协调者从所有的参与者获得的反馈都是 Yes ，那么就会执行事务的预提交</p>
<ol>
<li>发送预提交请求：协调者向所有参与者节点发出 PreCommit 的请求，并进入 Prepared 阶段。</li>
<li>事务预提交：参与者收到  PreCommit 请求后，会执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。</li>
<li>各参与者向协调者反馈事务执行的响应：如果参与者成功执行了事务操作，那么就反馈给协调者 Ack 响应，同时等待最终的指令：提交(commit) 或者 终止(abort).</li>
</ol>
</li>
<li><p>中断事务</p>
<p>假如任意一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响应，那么就会中断事务。</p>
<ol>
<li>发送中断请求：协调者向所有参与者节点发送 abort 请求。</li>
<li>中断事务：无论是收到来自协调者的 abort 请求，或者是在等待协调者请求的过程中出现超时，参与者都会中断事务。</li>
</ol>
</li>
</ul>
<p><strong>阶段三： doCommit</strong></p>
<p>该阶段会执行真正的事务提交，会存在以下两种情况</p>
<ul>
<li><p>执行提交</p>
<ol>
<li>发送提交请求：假设协调者处于正常工作状态，并且收到了来自所有参与者的 Ack 响应，那么它将从“预提交”状态转换到“提交”状态，并向所有的参与者发出 doCommit 请求。</li>
<li>事务提交：参与者收到 doCommit 请求后，会正式的执行事务提交操作，并在完成提交之后释放在整个事务期间占用的事务资源。</li>
<li>反馈事务提交结果：参与者在事务提交之后，向协调者发送 ACK 消息。</li>
<li>完成事务：协调者收到所有参与者反馈的 ACK 消息后，完成事务。</li>
</ol>
</li>
<li><p>中断事务</p>
<p>进入这一阶段，假设协调者处于正常工作状态，并且有任意一个参与者向协调者反馈了 No 响应，或者在等待超时之后，协调者尚无法收到所有参与者的反馈响应，那么就会中断事务。</p>
<ol>
<li>发送中断请求：协调者向所有参与者节点发送 abort 请求。</li>
<li>事务回滚：参与者在收到 abort 请求后，会利用其在阶段二中记录的 Undo 信息来执行事务回滚操作，并在完成回滚后释放在整个事务期间占用的事务资源。</li>
<li>反馈事务回滚结果：参与者在完成事务回滚之后，向协调者发送 ACK 消息。</li>
<li>中断事务：协调者收到所有参与者反馈的 ACK 消息后，完成事务中断。</li>
</ol>
</li>
</ul>
<hr>
<p>一旦进入阶段三，可能会出现以下两种故障：</p>
<ul>
<li>协调者出现问题</li>
<li>协调者和参与者之间的网络出现故障</li>
</ul>
<p>无论出现哪种情况，最终都会导致参与者无法收到来自协调者的 doCommit 或是 abort 请求，针对这样的异常情况，参与者都会在等待超时之后，继续进行事务提交。</p>
<hr>
<ul>
<li><strong>优点：</strong>相对于 2PC ，3PC 最大的优点是减低了参与者的阻塞范围，并且能够在出现单点故障后继续达成一致。</li>
<li><strong>缺点：</strong>参与者在收到 PreCommit 消息后，如果出现了网络分区，此时协调者所在的节点无法与参与者进行网络通信，这种情况下，参与者依然会进行事务的提交，这样会出现数据的不一致。</li>
</ul>
<hr>
<h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><p><a href="https://mp.weixin.qq.com/s/aJoXSQo9-zmukN2RsiZ3_g" target="_blank" rel="noopener">微信PaxosStore：深入浅出Paxos算法协议</a></p>
<p><a href="https://mp.weixin.qq.com/s/6VWUA5EDV2UIq4NqmQYWUA" target="_blank" rel="noopener">微信自研生产级paxos类库PhxPaxos实现原理介绍</a></p>
<p> <strong>Proposer 生成提案</strong></p>
<ol>
<li><p>Proposer 选择一个新的提案编号 Mn，然后向某个  Acceptor 集合的成员发送请求，要求该集合中 Acceptor 作出如下回应：</p>
<ul>
<li>向 Proposer 承诺，保证不再批准任何编号小于 Mn 的提案</li>
<li>如果 Acceptor 已经批准过任何提案，那么其就向 Proposer 反馈当前该 Acceptor 已经批准的编号小于 Mn 但为最大编号的那个提案的值。</li>
</ul>
</li>
</ol>
<p>   我们将请求编号为 Mn 的提案的 Prepare 请求。</p>
<ol start="2">
<li>如果 Proposer 收到了来自半数以上的 Acceptor 的响应结果，那么它就可以产生编号为 Mn，value 的值为 Vn 的提案，这里的 Vn 是所有响应中编号最大的提案的 Value 值。（半数以上的 Acceptor 都没有批准过任何提案，即响应中不包含任何的提案，那么 Vn 的值可以由 Proposer 任意选择）。</li>
</ol>
<p>在确定提案以后，Proposer 就会将该提案再次发给某个 Acceptor 集合，并期望获得他们的批准，称为 Accept 请求。</p>
<p><strong>Acceptor 批准提案</strong></p>
<ul>
<li>Prepare 请求：Acceptor 可以在任何时候响应一个 Prepare 请求。</li>
<li>Accept 请求：在不违背 Acceptor 现有承诺的前提下，可以任意响应 Accept 请求。</li>
</ul>
<p>一个 Acceptor 只要尚未响应过任何编号大于 Mn 的 Prepare 请求，那么它就可以接受这个编号为 Mn 的提案。</p>
]]></content>
      <categories>
        <category>从Paxos到Zookeeper</category>
      </categories>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>从Paxos到Zookeeper 第四章：Zookeeper 与 Paxos</title>
    <url>/2020/05/10/Distributed%20System/%E4%BB%8EPaxos%E5%88%B0Zookeeper%20%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9AZookeeper%20%E4%B8%8E%20Paxos/</url>
    <content><![CDATA[<h2 id="Zookeeper基本概念"><a href="#Zookeeper基本概念" class="headerlink" title="Zookeeper基本概念"></a>Zookeeper基本概念</h2><p>Zookeeper 是一个典型的分布式数据一致性的解决方案，分布式应用程序可以基于它实现诸如数据发布/订阅，负载均衡，命名服务，分布式协调/通知，集群管理，Master 选举，分布式锁和分布式队列等功能。</p>
<ul>
<li>集群角色<ul>
<li>Leader：为客户端提供读和写服务。</li>
<li>Follower：提供读服务</li>
<li>Observer：提供读服务，但是不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，可以在不影响写性能的情况下提升集群的读性能。</li>
</ul>
</li>
<li>会话<ul>
<li>客户端与 Zookeeper 的连接是一个 TCP 的长连接。ZK 对外提供服务的端口号为 2181。</li>
</ul>
</li>
<li>ZNode<ul>
<li>ZNode 指的是数据模型中的数据单元，称之为数据节点。ZK 的所有数据存储在内存当中，数据模型是一棵树。</li>
<li>ZNode 可以分为持久性或临时性节点</li>
</ul>
</li>
<li>版本<ul>
<li>每个ZNode，Zookeeper都会维护一个 Stat 的数据结构，Stat 记录了该 ZNode 的三个数据版本。version(当前ZNode 的版本)，cversion(当前ZNode子节点的版本)和aversion(当前ZNode的ACL版本)。</li>
</ul>
</li>
<li>Watcher<ul>
<li>ZK 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZK 服务端会将事件通知到感兴趣的客户端上去</li>
</ul>
</li>
<li>ACL<ul>
<li>Access Control List 来进行权限控制<ol>
<li>CREATE：创建子节点的权限</li>
<li>READ：获取节点数据和子节点列表的权限</li>
<li>WRITE：更新节点数据的权限</li>
<li>DELETE：删除子节点的权限</li>
<li>ADMIN：设置节点 ACL 的权限</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="ZAB-协议"><a href="#ZAB-协议" class="headerlink" title="ZAB 协议"></a>ZAB 协议</h1><p>Zookeeper Atomic  Broadcast（ZK原子消息广播协议）</p>
]]></content>
      <categories>
        <category>从Paxos到Zookeeper</category>
      </categories>
      <tags>
        <tag>Distributed System</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 学习笔记</title>
    <url>/2020/05/10/Git/Git%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Git是目前世界上最先进的分布式版本控制系统</p>
<h1 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h1><p><strong>$ git config –global user.name “Your Name”<br>$ git config –global user.email “<a href="mailto:email@example.com">email@example.com</a>“</strong></p>
<hr>
<ul>
<li>初始化一个Git仓库，使用<strong>git init</strong>命令。</li>
<li>添加文件到Git仓库，分两步：<ol>
<li>使用命令<strong>git add <file></strong>，注意，可反复多次使用，添加多个文件；</li>
<li>使用命令<strong>git commit -m <message></strong>，完成。</li>
</ol>
</li>
</ul>
<hr>
<ul>
<li>要随时掌握工作区的状态，使用<strong>git status</strong>命令。</li>
<li>如果git status告诉你有文件被修改过，用<strong>git diff</strong>可以查看修改内容。</li>
</ul>
<hr>
<h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><ul>
<li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，<br>使用命令<strong>git reset –hard commit_id</strong>。</li>
<li>穿梭前，用<strong>git log</strong>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<strong>git reflog</strong>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<hr>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p><strong>暂存区</strong>是Git非常重要的概念<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-hcAUgRih-1587607662307)(en-resource://database/1321:1)]</p>
<hr>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><ol>
<li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<strong>git checkout – file</strong>。</li>
<li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，<br>分两步，第一步用命令<strong>git reset HEAD <file></strong>，就回到了场景1，第二步按场景1操作。</li>
<li>已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</li>
</ol>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><ul>
<li><p>要关联一个远程库，使用命令</p>
</li>
<li><p><em>git remote add origin git@server-name:path/repo-name.git；*</em></p>
</li>
<li><p>关联后，使用命令<strong>git push -u origin master</strong>第一次推送master分支的所有内容；</p>
</li>
<li><p>此后，每次本地提交后，只要有必要，就可以使用命令<strong>git push origin master</strong>推送最新修改；</p>
</li>
</ul>
<hr>
<h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><ul>
<li>git clone <a href="mailto:git@github.com">git@github.com</a>:Winter-XJTU/gitskills.git</li>
</ul>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p>Git鼓励大量使用分支：</p>
<ul>
<li>查看分支：git branch</li>
<li>创建分支：git branch <name></li>
<li>切换分支：git checkout <name></li>
<li>创建+切换分支：git checkout -b <name></li>
<li>合并某分支到当前分支：git merge <name></li>
<li>删除分支：git branch -d <name></li>
</ul>
<hr>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。<br>解决冲突后，再提交，合并完成。<br>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。<br>用<strong>git log –graph</strong>命令可以看到分支合并图。</p>
<ul>
<li>分支策略<br>分支策略在实际开发中，我们应该按照几个基本原则进行分支管理：<br>首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。</li>
</ul>
<p><strong>git merge –no-ff -m “merge with no ff” dev</strong><br>Git分支十分强大，在团队开发中应该充分应用。合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<ul>
<li>bug分支</li>
</ul>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场；在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick <commit>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">168  vim hello.py</span><br><span class="line">170  git add hello.py</span><br><span class="line">171  git commit -m <span class="string">"hello.py"</span></span><br><span class="line">172  git stash</span><br><span class="line">//保留工作现场</span><br><span class="line"></span><br><span class="line">176  git checkout master</span><br><span class="line">177  git checkout -b issue</span><br><span class="line">179  vim readme.txt</span><br><span class="line">180  git add readme.txt</span><br><span class="line">181  git commit -m <span class="string">"fix bug"</span></span><br><span class="line">182  git checkout master</span><br><span class="line">183  git merge --no-ff -m <span class="string">"merge bug fix issue with no ff"</span> issue</span><br><span class="line">//修复bug并且合并到master</span><br><span class="line"></span><br><span class="line">186  git checkout dev</span><br><span class="line">190  git stash list</span><br><span class="line">191  git stash pop</span><br><span class="line">//恢复工作现场</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">201  git cherry-pick 891c0cf</span><br><span class="line">//在master分支上修复的bug，想要合并到当前dev分支</span><br></pre></td></tr></table></figure>





<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>因此，多人协作的工作模式通常是这样：<br>首先，可以试图用git push origin <branch-name>推送自己的修改；<br>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；<br>如果合并有冲突，则解决冲突，并在本地提交；没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p>小结</p>
<p>查看远程库信息，使用git remote -v；<br>本地新建的分支如果不推送到远程，对其他人就是不可见的；<br>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；<br>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；<br>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；<br>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>5.13 ~ 5.18 学习计划</title>
    <url>/2020/05/13/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/5.13%20~%205.18%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h2 id="5-13-5-18-学习计划"><a href="#5-13-5-18-学习计划" class="headerlink" title="5.13 ~ 5.18 学习计划"></a>5.13 ~ 5.18 学习计划</h2><ul>
<li>每天写 LeetCode，复习 200 英语单词</li>
<li>牛客网项目跟着做</li>
<li>Head First Design Pattern</li>
<li>CSAPP 学习</li>
<li>Redis</li>
<li>Zookeeper</li>
<li>高性能MySQL 再看一遍 5 6 章节</li>
<li>美团文章读一篇</li>
<li>计算机网络 SDN 数据链路层 多播 任播</li>
</ul>
<h2 id="上周回顾"><a href="#上周回顾" class="headerlink" title="上周回顾"></a>上周回顾</h2><ul>
<li>上周的学习状态一般般，有效学习时间不多。</li>
<li>现在是基础学的不深入，并且没有实战经验</li>
<li>英语的学习不能落下，重视一下</li>
</ul>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title>简单操作系统概念</title>
    <url>/2020/05/10/Operating%20System/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1. 操作系统概述"></a>1. 操作系统概述</h1><ul>
<li>操作系统的特征</li>
</ul>
<ol>
<li><p><strong>并发</strong>：并发是指两个或多个事件在同一时间间隔内发生。</p>
</li>
<li><p><strong>共享</strong>：即资源共享，是指系统中的资源可供内存中多个并发执行的程序共同使用。</p>
</li>
<li><p>虚拟：是指把一个物理上的实体虚拟成多个逻辑上的对应物。</p>
<ul>
<li>虚拟技术：时分复用技术，空分复用技术</li>
</ul>
</li>
<li><p>异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是操作系统的异步性。</p>
</li>
</ol>
<ul>
<li><strong>内核</strong>（核心态）</li>
</ul>
<ol>
<li>时钟管理：提供系统时间、实现进程切换</li>
<li>中断机制：提高 CPU 的利用率</li>
<li>原语</li>
<li>系统控制的数据结构及处理</li>
</ol>
<ul>
<li><strong>中断</strong>：当中断或者异常发生的时候， 运行用户态的 CPU 会立即进入核心态，通过硬件实现的</li>
<li><strong>系统调用</strong>：是用户在程序中调用操作系统提供的一些子功能。系统中的各种共享资源都是由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（存储分配、进行 I/O 传输、管理文件），都必须通过系统调用的方式向操作系统提出服务请求，并由操作系统代为完成。</li>
</ul>
<h1 id="2-1-进程管理"><a href="#2-1-进程管理" class="headerlink" title="2.1 进程管理"></a>2.1 进程管理</h1><p>进程映像：程序段、相关数据段和 PCB (静态的)</p>
<p>进程：进程是进程映像的运行过程，是系统进行资源分配和调度的一个独立单位。（描述<strong>动态</strong>）</p>
<p>进程状态：创建 就绪 运行 阻塞(等待) 结束</p>
<p>进程之间的通信：</p>
<ol>
<li><p>共享存储</p>
<ol start="2">
<li>消息传递</li>
<li>管道通信</li>
</ol>
</li>
</ol>
<p>线程与进程的区别：调度、拥有资源、并发性、系统开销、地址空间和其他资源、通信方面</p>
<p>线程的实现方式：</p>
<pre><code>1. 用户级线程：将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模型中，用户级线程对操作系统不可见。
* 优点：线程管理是在用户级空间进行的，因而效率比较高
* 缺点：当一个线程在使用内核服务的时候被阻塞，那么整个进程就会被阻塞；多个线程不能并行的运行在多处理机上。
2. 内核级线程：将每个用户级线程映射到一个内核级线程
* 优点：当一个线程被阻塞的时候，另一个线程继续执行，并发能力强
* 缺点：每创建一个用户级线程都需要创建一个内核级线程与之对应，创建线程的开销比较大，会影响到用户程序的性能。</code></pre><p><img src="https://github.com/Wayne-98/image/blob/master/Operating%20System/Process.png?raw=true" alt=""></p>
<h1 id="2-2-处理机调度"><a href="#2-2-处理机调度" class="headerlink" title="2.2 处理机调度"></a>2.2 处理机调度</h1><ul>
<li>调度的层次（三级调度）</li>
</ul>
<ol>
<li>作业调度：内存与辅存之间的调度，每个作业只调入和调出一次。</li>
<li>中级调度(内存调度)：引入是为了提高内存的利用率和系统的吞吐量。将暂时不能运行的进程，调至外存等待，把此时的进程状态称为挂起态。</li>
<li>进程调度：按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</li>
</ol>
<p>作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。</p>
<ul>
<li>调度的时机、切换与过程</li>
</ul>
<p>不能进程进程调度与切换的几种情况：</p>
<ol>
<li><p>处理中断的过程中</p>
<ol start="2">
<li>进程在操作系统内核临界区中</li>
<li>其他需要完全屏蔽中断的原子操作过程中</li>
</ol>
</li>
</ol>
<p>应当进行进程调度与切换的情况有：</p>
<ol>
<li><p>发生引起调度条件，并且当前进程无法继续执行下去，可以马上进行调度与切换。(非剥夺调度)</p>
<ol start="2">
<li>当中断处理结束或自陷处理结束后，返回被中断进程的用户态执行现场前。若置上请求调度标志，即可马上进行进程的调度与切换(剥夺式调度)</li>
</ol>
</li>
</ol>
<ul>
<li>调度的基本准则</li>
</ul>
<ol>
<li>CPU 利用率 2. 系统吞吐量 3. 周转时间 4. 等待时间 5. 响应时间</li>
</ol>
<ul>
<li>典型的调度算法</li>
</ul>
<ol>
<li>先来先服务 </li>
<li>短作业优先 </li>
<li>优先级调度 </li>
<li>高响应比优先调度 （响应比 = （等待时间 + 要求服务时间） / 要求服务时间）</li>
<li>时间片轮转调度</li>
<li>多级反馈队列调度 </li>
</ol>
<p><img src="https://github.com/Wayne-98/image/blob/master/Operating%20System/%E8%B0%83%E5%BA%A6.png?raw=true" alt=""></p>
<h2 id="2-3-进程同步"><a href="#2-3-进程同步" class="headerlink" title="2.3 进程同步"></a>2.3 进程同步</h2><ul>
<li>同步和互斥</li>
</ul>
<ol>
<li><p>同步：直接制约关系，指为完成某个任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递消息所产生的制约关系。进程间的直接制约关系，源于它们之间的合作。</p>
</li>
<li><p>互斥：简介制约关系，当一个进程进入临界区使用资源的时候，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许去访问此临界资源。</p>
</li>
</ol>
<ul>
<li>生产者消费者、读者写者、哲学家进餐</li>
</ul>
<p><img src="https://github.com/Wayne-98/image/blob/master/Operating%20System/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5.png?raw=true" alt=""></p>
<h2 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4 死锁"></a>2.4 死锁</h2><ul>
<li><p>死锁：多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将无法向前推进。</p>
</li>
<li><p>死锁产生的必要条件：</p>
<ol>
<li>互斥</li>
<li>不可剥夺</li>
<li>请求和保持</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。</li>
</ol>
</li>
<li><p>死锁的处理策略：</p>
<ol>
<li><p>预防死锁：破坏 4 个条件其中之一。</p>
</li>
<li><p>避免死锁：银行家</p>
</li>
<li><p>死锁的检测以及解除</p>
</li>
</ol>
</li>
<li><p>死锁预防</p>
<ol>
<li>破坏互斥：不可行</li>
<li>破坏不可剥夺：不可行</li>
<li>破坏请求和保持：一次分配所有资源，浪费资源，申请不到所有资源可能会出现“饥饿”现象</li>
<li>破坏循环等待：给资源编序号，按序申请。</li>
</ol>
</li>
<li><p>死锁避免：</p>
<ol>
<li>系统安全状态：系统能够按照某种进程推进顺序，为每个进程分配其所需资源，使每个进程多可以顺利的完成。</li>
<li>银行家算法：<ul>
<li>可用资源矢量</li>
<li>最大需求矩阵</li>
<li>分配矩阵</li>
<li>需求矩阵</li>
</ul>
</li>
</ol>
</li>
<li><p>死锁的检测与解除</p>
<ol>
<li>资源分配图</li>
</ol>
<p><img src="https://github.com/Wayne-98/image/blob/master/Operating%20System/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png?raw=true" alt=""></p>
<ol start="2">
<li>死锁定理：S 为死锁的条件是当且仅当 S 状态的资源分配图是不可完全简化的，该条件为死锁定理</li>
<li>死锁解除：<ol>
<li>资源剥夺法：挂起某些死锁进程，抢占它的资源</li>
<li>资源撤销法：按照进程的优先级和撤销进程的代价的高低，强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源</li>
<li>进程回退法：让一个或多个进程回退到足以回避死锁的地步，进程自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li>
</ol>
</li>
</ol>
<p><img src="https://github.com/Wayne-98/image/blob/master/Operating%20System/%E6%AD%BB%E9%94%81.png?raw=true" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>4.28 ~ 5.5 学习计划</title>
    <url>/2020/05/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/4.28%20~%205.5%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h2 id="4-28-5-5-学习计划"><a href="#4-28-5-5-学习计划" class="headerlink" title="4.28 ~ 5.5 学习计划"></a>4.28 ~ 5.5 学习计划</h2><ul>
<li>每天写 LeetCode</li>
<li>JVM 第三版 第三部分以及第四部分 学习笔记重新整理 &amp; 学习</li>
<li>Java 并发编程 复习一遍</li>
<li>高性能MySQL 第五章第六章 学习笔记整理 &amp; 学习</li>
<li>美团文章：JVM调优 MySQL慢优化</li>
<li>计算机网络 IP 数据链路 学习 整理笔记</li>
</ul>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title>Socket I/O</title>
    <url>/2020/05/10/Scoket/socket%20IO/</url>
    <content><![CDATA[<p>One basic concept of Linux (actually Unix) is the rule that everything in Unix/Linux is a file. Each process has a table of file descriptors that point to files, sockets, devices and other operating system objects.<br>    linux系统中，一切皆文件。，每一个进程都有一个FD表，指向了与该进程有关的文件，套接字，设备或者其他操作系统对象。<br>Typical system that works with many IO sources has an initializaion phase and then enter some kind of standby mode – wait for any client to send request and response it<br>典型系统中有许多IO资源具有初始化阶段，然后进入某种待机模式——等待任意一个客户端发送请求并对其进行响应。<br>Simple solution is to create a thread (or process) for each client , block on read until a request is sent and write a response. This is working ok with a small amount of clients but if we want to scale it to hundred of clients, creating a thread for each client is a bad idea<br>简单的解决方案是为每一个客户，创建一个线程，客户请求的时候进行响应，其他时候处于阻塞状态。</p>
<hr>
<p>sfd = socket();    // socket 系统调用 得到一个文件描述符代表这个socket</p>
<p>bind(sfd…)    // 绑定到一个端口号上</p>
<p>listen(sfd)     // 开启监听状态</p>
<p>accept(sfd)     // 接收客户端的连接 (阻塞) </p>
<p>read recvfrom </p>
<p>调用recv 的时候，操作系统会把该进程阻塞。当网络数据到达网卡的时候，网卡会把数据放到内存，然后中断通知CPU，CPU 执行中断程序，把网络数据写入到对应的socket的接受缓冲区中(端口号)，在唤醒阻塞的进程来读数据。</p>
<ul>
<li>如何如何同时监视多个socket的数据？</li>
</ul>
<p>每次有一个 client 新的连接，该线程就 clone 一个新的线程来执行。</p>
<hr>
<h1 id="IO-Multiplexing"><a href="#IO-Multiplexing" class="headerlink" title="IO Multiplexing"></a>IO Multiplexing</h1><p>The solution is to use a kernel mechanism for polling over a set of file descriptors. There are 3 options you can use in Linux:<br>IO的多路复用解决方案是利于操作系统的内核机制来轮询一组文件描述符。</p>
<p>Multiplexing 指的其实是在单个线程通过记录跟踪每一个Sock(I/O流)的状态来同时管理多个I/O流. </p>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<p>All the above methods serve the same idea, create a set of file descriptors , tell the kernel what would you like to do with each file descriptor (read, write, ..) and use one thread to block on one function call until at least one file descriptor requested operation available</p>
<p>服务端需要管理多个客户端连接，而recv只能监视单个socket，这种矛盾下，人们开始寻找监视多个socket的方法。</p>
<ol>
<li><p><strong>select</strong> : 假如能够预先传入一个socket列表，<strong>如果列表中的socket都没有数据，挂起进程，直到有一个socket收到数据，唤醒进程</strong>。</p>
<ul>
<li>用法：先准备一个数组（下面代码中的fds），让fds存放着所有需要监视的socket。然后调用select，如果fds中的所有socket都没有数据，select会阻塞，直到有一个socket接收到数据，select返回，唤醒进程。用户可以遍历fds，通过FD_ISSET判断具体哪个socket收到数据，然后做出处理。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">bind(s, ...)</span><br><span class="line"><span class="built_in">listen</span>(s, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fds[] =  存放需要监听的socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> n = select(..., fds, ...)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; fds.count; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET(fds[i], ...))&#123;</span><br><span class="line">            <span class="comment">//fds[i]的数据处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>* **select的流程**：select的实现思路很直接。假如程序同时监视如下图的sock1、sock2和sock3三个socket，那么在调用select之后，操作系统把进程A分别加入这三个socket的等待队列中。</code></pre><p><img src="" alt=""></p>
</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/63179839" target="_blank" rel="noopener">如果这篇文章说不清epoll的本质，那就过来掐死我吧！ （1）</a></p>
]]></content>
      <categories>
        <category>I/O</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>需要提升的点</title>
    <url>/2020/05/10/%E9%9D%A2%E8%AF%95/%E9%9C%80%E8%A6%81%E6%8F%90%E5%8D%87%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<p>Collections.sort() 原理：归并</p>
<p>图的一些算法，需要复习一下</p>
<p>JVM 调优 参数</p>
<p>设计模式： 单例模式（懒汉饿汉） 工厂方法模式  观察者模式   责任链模式</p>
<p>红黑树</p>
<p>ThreadLocal</p>
<p><strong>B 树和 B+树的区别</strong>：</p>
<ul>
<li>B 树，每个节点都存储 key 和 data，所有节点组成这棵树，并且叶子节点指针为 nul，叶子结点不包含任何关键字信息。</li>
<li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(而 B 树的非终节点也包含需要查找的有效信息)</li>
</ul>
<p><strong>为什么说 B+比 B 树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<ul>
<li>B+的磁盘读写代价更低。B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。</li>
<li>B+-tree 的查询效率更加稳定<br>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>5.5 ~ 5.12 学习计划</title>
    <url>/2020/05/10/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/5.5%20~%205.12%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h2 id="5-5-5-12-学习计划"><a href="#5-5-5-12-学习计划" class="headerlink" title="5.5 ~ 5.12 学习计划"></a>5.5 ~ 5.12 学习计划</h2><ul>
<li>每天写 LeetCode，复习 200 英语单词</li>
<li>JVM 复习一遍笔记</li>
<li>Java 并发 复习一遍笔记</li>
<li>高性能MySQL 再看一遍 5 6 章节</li>
<li>美团文章 JVM 调优</li>
<li>计算机网络 IP 数据链路 多播 数据控制层</li>
</ul>
]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
  </entry>
  <entry>
    <title>高性能MySQL读书笔记第十一章：扩展</title>
    <url>/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="向上扩展"><a href="#向上扩展" class="headerlink" title="向上扩展"></a>向上扩展</h1><p>加强服务器性能</p>
<h1 id="向外扩展"><a href="#向外扩展" class="headerlink" title="向外扩展"></a>向外扩展</h1><ol>
<li>按功能拆分</li>
<li>数据分片：通用且成功</li>
</ol>
]]></content>
      <categories>
        <category>高性能MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能MySQL读书笔记第一章：MySQL架构</title>
    <url>/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9AMySQL%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="MySQL逻辑架构"><a href="#MySQL逻辑架构" class="headerlink" title="MySQL逻辑架构"></a>MySQL逻辑架构</h2><ul>
<li><strong>连接管理、授权认证与安全</strong><br>  每个客户端连接都会在服务器进程中拥有一个线程<br>  认证基于用户名、原始主机信息和密码</li>
<li><strong>优化与执行</strong><br>MySQL 会解析查询，并创建内部数据结构，然后对其进行各种优化，包括重写查询、决定表的读取顺序以及选择合适的索引等。</li>
</ul>
<hr>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ul>
<li><strong>并发控制的两个层面：</strong><br>  服务器层和存储引擎层</li>
<li><strong>读写锁</strong><br>  读锁是共享的，相互不堵塞的<br>  写锁是排他的，一个写锁会堵塞其他读锁和写锁</li>
<li><strong>锁粒度</strong><br>  表锁：最基本的锁策略，开销最小的策略，（一般是在服务器层实现）<br>  行锁：支持最大程度的并发处理，同时也带来了最大的锁开销，行级锁只在存储引擎实现</li>
</ul>
<hr>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务就是一个原子性的 SQL 查询或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。</p>
<ul>
<li><p><strong>ACID</strong></p>
<ol>
<li>Atomicity 原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对一个事务来说，不可能只执行其中的一部分操作。</li>
<li>Consistency 一致性：数据库总是从一个一致性状态转换到另外一个一致性状态。</li>
<li>Isolation 隔离性：一个事务所做的修改在最终提交以前，对其他事务是不可见的。</li>
<li>Durability 持续性：一旦事务提交，其所做的修改就会永久保存到数据库中。</li>
</ol>
</li>
<li><p><strong>隔离级别</strong></p>
<ol>
<li>READ UNCOMMITTED (未提交读)<ul>
<li>在未提交读级别，事务中的修改，即使没有提交，对其他事务也是可见的</li>
<li>事务可以读取未提交的数据，被称为脏读</li>
</ul>
</li>
<li>READ COMMITTED (提交读)<ul>
<li>提交读满足隔离性的定义。一个事务开始时，只能“看见”已经提交的事务所做的修改</li>
<li>也称作不可重复读，一个事务内执行两次同样的查询，可能会得到不一样的结果</li>
</ul>
</li>
<li>REPEATABLE READ (可重复读)（是 MySQL 默认事务隔离级别）<ul>
<li>解决了脏读的问题，该级别保证了在同一个事务中多次读取同样记录的结果是一致的</li>
<li>幻读：当某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的时候就会产生幻行。多版本并发控制 MVCC 解决了幻读的问题</li>
</ul>
</li>
<li>SERIALIZABLE (可串行化)<ul>
<li>强制事务串行执行</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>死锁</strong><br>  死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。<br>  InnoDB目前处理死锁的方法是将持有最少行级排他锁的事务进行回滚</p>
</li>
<li><p><strong>事务日志</strong></p>
<ol>
<li>可以帮助提高事务的效率</li>
<li>使用事务日志，存储引擎在修改表数据的时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</li>
<li>事务日志采取的是追加的方式，因此写日志的操作是磁盘上一小块区域的顺序 I/O ,而不是像随机 I/O 需要在磁盘的多个地方移动磁头</li>
<li>事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘</li>
</ol>
</li>
<li><p><strong>MySQL中的事务</strong></p>
<ol>
<li>自动提交：如果不显式的开始一个事务，则每个查询都会被当成一个事务执行操作</li>
<li>在事务中混合使用存储引擎：MySQL 服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。</li>
<li>隐式和显式锁定：InnoDB 采用的是两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行 commit 或者 rollback 的时候才会释放，并且所有的锁是在同一时刻被释放。</li>
</ol>
</li>
</ul>
<hr>
<h2 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h2><ul>
<li><p>可以认为 MVCC 是行级锁的一个变种，但是它在很多情况下避免的加锁操作，因此开销更低。虽然实现的机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p>
</li>
<li><p>MVCC 的实现，是通过保存数据在某个时间点上的快照实现的。</p>
<ul>
<li>事务快照是用来存储数据库的事务运行情况，用来做可见性判断</li>
<li>一个事务快照的创建过程可以概括为：<ol>
<li>查看当前所有的未提交并活跃的事务，存储在数组中</li>
<li>选取未提交并活跃的事务中最小的XID，记录在快照的xmin中</li>
<li>选取所有已提交事务中最大的XID，加1后记录在xmax中</li>
</ol>
</li>
<li>快照生成时机的不同, 造成了RC,RR两种隔离级别的不同可见性<ol>
<li>repeatable read 级别, 事务在 begin/start transaction 之后的第一条 select 读操作后, 会创建一个快照(read view), 将当前系统中活跃的其他事务记录记录起来;</li>
<li>read committed 级别, 事务中每条 select 语句都会创建一个快照(read view);</li>
</ol>
</li>
</ul>
</li>
<li><p>InnoDB 的 MVCC，InnoDB存储引擎在数据库每行数据的后面添加了三个字段来实现的。一个字段保存了行的创建时间，一个保存了行的过期(删除)时间。存储并不是实际时间值，而是系统版本号。每开始一个事务，系统版本号都会自动递增。还有一个是回滚指针(DB_ROLL_PTR)字段: 指写入回滚段(rollback segment)的 undo log record (撤销日志记录)。</p>
<ol>
<li>SELECT：<ul>
<li>InnoDB只查找版本早于当前事务版本的数据行。这样可以确保事务读取的行要么是在事务开始前就已经存在的，要么是事务自身插入或修改过的</li>
<li>行的删除版本号要么未定义，要么大于当前事务版本号。这可以确保事务读到的行，在事务开始之前未被删除</li>
</ul>
</li>
<li>INSERT<br> InnoDB为新插入的每一行保存当前系统版本号作为行版本号</li>
<li>DELETE<br> InnoDB为删除的每一行保存当前系统版本号作为行删除标识</li>
<li>UPDATE<br> InnoDB为插入一行新数据，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识</li>
</ol>
</li>
<li><p>MVCC只在可重复读和提交读两个隔离级别下工作</p>
<ol>
<li>未提交读总是读取最新的数据行，而不是符合当前事务版本的数据行。</li>
<li>SERIALIZABLE 则会对所有读取的行都加锁。</li>
</ol>
</li>
<li><p>Undo-log</p>
<ol>
<li>Undo log 是 InnoDB MVCC 事务特性的重要组成部分。当我们对记录做了变更操作时就会产生 undo记录，Undo 记录默认被记录到系统表空间(ibdata)中，但从5.6开始，也可以使用独立的Undo 表空间。</li>
<li>Undo记录中存储的是老版本数据，当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作（例如bug#69812）。</li>
<li>大多数对数据的变更操作包括INSERT/DELETE/UPDATE，其中INSERT操作在事务提交前只对当前事务可见，因此产生的Undo日志可以在事务提交后直接删除（谁会对刚插入的数据有可见性需求呢！！），而对于UPDATE/DELETE则需要维护多版本信息，在InnoDB里，UPDATE和DELETE操作产生的Undo日志被归成一类，即update_undo</li>
<li>另外, 在回滚段中的undo logs分为: insert undo log 和 update undo log<ul>
<li>insert undo log : 事务对insert新记录时产生的undolog, 只在事务回滚时需要, 并且在事务提交后就可以立即丢弃。</li>
<li>update undo log : 事务对记录进行delete和update操作时产生的undo log, 不仅在事务回滚时需要, 一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><ul>
<li>InnoDB<ol>
<li>InnoDB的数据存储在表空间中，表空间是由InnoDB管理的黑盒子，由一系列的数据文件组成。InnoDB可以将每个表的数据和索引放在单独的文件中。</li>
<li>InnoDB采用MVCC来支持高并发，默认的隔离级别是可重复读，并且通过间隙锁(next-key locking)策略防止幻读的出现。间隙锁是的InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入<ul>
<li>InnoDB支持行锁（锁定字段含有索引的情况下，否则走表锁），但锁定方式并非简单的锁定指定行上的索引，而是分为3种锁定算法：<br>1）记录锁（Record Locks）：锁定指定行的索引项<br>2）Gap Locks：锁定某一个范围内的索引，但不包括记录本身<br>3）间隙锁定（Next-Key Locks）：锁定一个范围内的索引，并且锁定记录本身   Next-Key Locks = Record Locks + Gap Locks<br>A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record</li>
</ul>
</li>
<li>InnoDB表是基于聚簇索引来实现的，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列。因此若表上的索引较多的话，主键应当尽可能的小。</li>
</ol>
</li>
<li>MyISAM<ol>
<li>MySQL5.1及之前的版本，是默认存储引擎。MyISAM提供了大量的特性，包括全文索引，压缩，空间函数等</li>
<li>MyISAM不支持事务和行级锁，并且崩溃后无法安全恢复</li>
<li>存储：MyISAM将表存储在两个文件中：数据文件和索引文件。表可以包括动态或静态行</li>
<li>特性<ul>
<li>加锁和并发：对整张表加锁；在表有读取查询的同时，也可以往表中插入新的记录，称为并发插入</li>
<li>修复：check table mytable; repair table mytable</li>
<li>索引：即使是BLOB和TEXT等长字段，基于前500个字符创建索引；支持全文索引，是一种基于分词创建的索引</li>
<li>延迟更新索引键：在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘</li>
</ul>
</li>
<li>压缩表：压缩表是不能修改的，可以极大的减少磁盘空间占用，因此也可以减少磁盘I/O，从而提升查询性能。支持索引，索引也是只读的</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>高性能MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能MySQL读书笔记第五章：创建高性能的索引</title>
    <url>/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h1><p>MySQL的索引是在存储引擎层实现的</p>
<h2 id="磁盘IO与预读"><a href="#磁盘IO与预读" class="headerlink" title="磁盘IO与预读"></a>磁盘IO与预读</h2><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为<strong>寻道时间</strong>、<strong>旋转延迟</strong>、<strong>传输时间</strong>三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在<strong>5ms</strong>以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，旋转延迟就是1/120/2 = <strong>4.17ms</strong>；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。</p>
<p>考虑到磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，<strong>当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内</strong>，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为<strong>4k</strong>或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，这个理论对于索引的数据结构设计非常有帮助。</p>
<p>3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</p>
<h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><ol>
<li>B+Tree索引</li>
</ol>
<ul>
<li><p>B+Tree索引有不同的<strong>实现方式</strong>，各有优劣。</p>
<ul>
<li>MyISAM使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储</li>
<li>MyISAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行</li>
</ul>
</li>
<li><p>可以使用B+Tree索引的类型</p>
<ul>
<li>B+Tree索引适合于全键值、键值范围或键前缀查找(根据最左前缀的查找)<br>  <strong>B+Tree索引的有效查询类型</strong>：<ul>
<li>全值匹配</li>
<li><strong>匹配最左前缀</strong></li>
<li>匹配列前缀</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另一列</li>
<li>只访问索引的查询</li>
<li>如果orderby子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求</li>
</ul>
</li>
</ul>
</li>
<li><p>B+Tree索引的一些<strong>限制</strong></p>
<ul>
<li>如果不是从索引的最左列开始查找，则无法使用索引</li>
<li>不能跳过索引中的列（比如说我查询第一列和第三列，则索引只能使用第一列）</li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</li>
</ul>
</li>
</ul>
<h1 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h1><ul>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变为顺序I/O</li>
</ul>
<h1 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h1><h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p>指索引列不能是表达式的一部分，也不能是函数的参数</p>
<h2 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h2><ul>
<li>索引很长的字符串，需要使用前缀索引，这样可以大大减少索引空间，从而提升索引效率。但是会降低索引的选择性。（BLOB，TEXT必须使用前缀索引）</li>
<li>索引的选择性是指，不重复的索引值和数据表记录总数的比值。</li>
<li>MySQL无法使用前缀索引做 order by和 group by，也无法使用前缀索引做覆盖扫描。</li>
</ul>
<h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>为每一个列创建单独的索引，或者按照错误的顺序创建多列索引，是错误的。</p>
<h2 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h2><ul>
<li>当不需要考虑排序和分组的时候，将选择性最高的列放到前面通常是很好的。这时索引的作用是优化where条件的查找</li>
<li>将选择性最高的列放在索引的最前列，在某些场景可能有帮助，但通常不如避免随机I/O和排序那么重要，考虑问题需要全面。</li>
</ul>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。<br>数据行实际存放在索引的叶子页中，“聚簇”表示数据行和相邻的键值紧凑的存储在一起。</p>
<h3 id="聚簇索引的优点"><a href="#聚簇索引的优点" class="headerlink" title="聚簇索引的优点"></a>聚簇索引的优点</h3><ul>
<li>可以把相关的数据保存在一起</li>
<li>因为聚簇索引把索引和数据保存在同一个B+Tree中，所以数据访问更快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li>
<li>使用主键值当作指针会让二级索引占用更多的空间，换来的好处是，InnoDB在移动行的时候无须更新二级索引中这个“指针”</li>
</ul>
<h3 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h3><ul>
<li>聚簇索引最大限度的提高了 I/O 密集型应用的提升，如果数据全部在内存中，则访问的顺序就没有那么重要了，聚簇索引的优势也就没了。</li>
<li>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到 InnoDB 表中速度最快的方式。如果不是，插入完成后最好使用 OPTIMIZE TABLE 命令重新组织一下表。</li>
<li>更新聚簇索引的代价很高，因为会强制 InnoDB 将每个被更新的行移动到新的位置</li>
<li>基于聚簇索引的表在插入新行或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。<ul>
<li>当行的主键值要求必须将这一行插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，这就是一项页分裂的操作。页分裂会导致占用更多的磁盘空间</li>
</ul>
</li>
<li>聚簇索引可能会导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候</li>
<li>二级索引(非聚簇索引)可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</li>
<li>二级索引访问需要两次索引查找，而不是一次<ul>
<li>二级索引叶子结点保存的不是指向行物理位置的指针，而是行的主键值</li>
<li>存储引擎需要找到二级索引的叶子结点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行  </li>
</ul>
</li>
</ul>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>如果一个索引包含所有需要查询的值，我们就称之为覆盖索引。</p>
<ul>
<li>覆盖索引的优点：<ol>
<li>索引条目通常远小于数据行的大小，如果只需要读取索引，MySQL就会极大地减少数据访问量。</li>
<li>因为索引是按照列值顺序存储的，所以对于 I/O 密集型的范围查询会比随机磁盘读取每一行的数据的 I/O 要少得多。</li>
<li>因为 InnoDB 的聚簇索引，覆盖索引可以避免回表查询。</li>
</ol>
</li>
</ul>
<p>当发起一个被索引覆盖的查询时，在 explain 的 Extra 列可以看到 “Using index” 的信息。</p>
<h3 id="使用索引扫描来排序"><a href="#使用索引扫描来排序" class="headerlink" title="使用索引扫描来排序"></a>使用索引扫描来排序</h3><p>EXPLAIN 出来的列的 type 列的值为 “index” ，则说明 MySQL 使用了索引扫描来做排序。</p>
<p>MySQL使用索引来对结果做排序的一些限制：</p>
<ol>
<li><p>只有当索引列的顺序和 ORDER BY 子句的顺序完全一致，并且所有列的排序方向都一样时</p>
<ol start="2">
<li>如果需要关联多张表，则只有当 ORDER BY 子句引用的字段全部为第一个表时</li>
<li>其他查找型的限制(最左前缀优先等等)</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>高性能MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能MySQL读书笔记第六章：查询性能优化</title>
    <url>/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="为什么查询速度会慢？"><a href="#为什么查询速度会慢？" class="headerlink" title="为什么查询速度会慢？"></a>为什么查询速度会慢？</h2><ul>
<li><p>查询的生命周期</p>
<p>查询的生命周期，从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。执行是查询生命周期最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等等。</p>
</li>
</ul>
<h2 id="慢查询基础：优化数据访问"><a href="#慢查询基础：优化数据访问" class="headerlink" title="慢查询基础：优化数据访问"></a>慢查询基础：优化数据访问</h2><ul>
<li>分析步骤</li>
</ul>
<ol>
<li><p>确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也是可能访问了太多的列</p>
</li>
<li><p>确认MySQL服务器层是否在分析大量超过需要的数据行</p>
</li>
</ol>
<h3 id="是否向数据库请求了不需要的数据"><a href="#是否向数据库请求了不需要的数据" class="headerlink" title="是否向数据库请求了不需要的数据"></a>是否向数据库请求了不需要的数据</h3><ol>
<li>查询不需要的记录（加上limit）</li>
<li>多表关联时返回全部列（查询涉及三张表的时候，使用select *）</li>
<li>总是取出全部列（无法使用索引覆盖扫描，慎用select*）</li>
<li>重复查询相同的数据（缓存）</li>
</ol>
<h3 id="MySQL是否在扫描额外的记录"><a href="#MySQL是否在扫描额外的记录" class="headerlink" title="MySQL是否在扫描额外的记录"></a>MySQL是否在扫描额外的记录</h3><ul>
<li><strong>衡量查询开销的三个指标：</strong></li>
</ul>
<ol>
<li><p>响应时间：</p>
<ul>
<li>服务时间是指数据库处理这个查询花了多少时间</li>
<li>排队时间是指服务器因为等待某些资源而没有真正执行查询的时间。可能是等I/O操作完成，等行锁</li>
</ul>
</li>
<li><p>扫描的行数：</p>
</li>
<li><p>返回的行数：</p>
</li>
</ol>
<p>这三个指标都会存放在MySQL的慢日志中，所以检查慢日志记录是找出扫描行数过多的查询的好办法。</p>
<ul>
<li><strong>访问类型：</strong></li>
</ul>
<p>全表扫描，索引扫描，范围扫描，唯一索引查询，常数引用</p>
<ul>
<li><strong>MySQL 应用 where ：</strong></li>
</ul>
<ol>
<li>在索引中使用 where 条件来过滤不匹配的记录。在存储引擎层完成的。</li>
<li>使用索引扫描(在 Extra 列中出现了 Using Index )来返回记录，直接从索引中过滤不需要的记录并返回命中结果。这是在 MySQL 服务器层完成的，但无须回表查询记录</li>
<li>在数据表中返回数据，然后过滤不满足条件的记录(在 Extra 列中出现 Using Where)。这是在 MySQL 服务器层完成，MySQL 需要先从数据表读出记录然后过滤</li>
</ol>
<h2 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h2><ul>
<li><p><strong>一个复杂的查询还是多个简单的查询</strong></p>
</li>
<li><p><strong>切分查询：</strong>大查询切分成小查询，每个查询功能完全一样，每次只完成一小部分</p>
</li>
<li><p><strong>分解关联查询：</strong></p>
</li>
</ul>
<ol>
<li><p>对每一个表进行一次单表查询，然后将结果在应用程序中进行关联</p>
</li>
<li><p>让缓存的效率更高  </p>
</li>
<li><p>将查询分解后，执行单个查询可以减少锁的竞争</p>
</li>
<li><p>在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展</p>
</li>
</ol>
<h2 id="查询执行的基础"><a href="#查询执行的基础" class="headerlink" title="查询执行的基础"></a>查询执行的基础</h2><ol>
<li><p>客服端发送一条查询给服务器</p>
</li>
<li><p>服务器先检查查询缓存，如果命中缓存，则立即返回</p>
</li>
<li><p>服务器端进行SQL解析，预处理，再由优化器生成对应的执行计划</p>
</li>
<li><p>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询</p>
</li>
<li><p>返回结果给客户端</p>
</li>
</ol>
<h3 id="MySQL客户端-服务端通信协议：半双工"><a href="#MySQL客户端-服务端通信协议：半双工" class="headerlink" title="MySQL客户端/服务端通信协议：半双工"></a>MySQL客户端/服务端通信协议：半双工</h3><h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><h3 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h3><ol>
<li><p>语法解析器和预处理：生成“解析树”并验证解析树是否合法，验证权限</p>
</li>
<li><p>查询优化器：基于成本的优化器</p>
</li>
<li><p>数据和索引统计信息：统计信息在存储引擎层，服务器层在执行查询优化的时候需要调用api</p>
</li>
<li><p>MySQL如何执行关联查询：嵌套循环关联操作</p>
<ul>
<li>MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。然后根据各个表匹配的行，返回查询中需要的列。<ul>
<li>如果是左外连接，取出单条数据遍历下一个表的时候，如果没有匹配，则输出当前行+NULL</li>
<li>右连接改正等价的左外连接</li>
</ul>
</li>
</ul>
</li>
<li><p>执行计划：生成一颗查询的指令树</p>
</li>
<li><p>关联查询优化器：</p>
</li>
<li><p>排序优化：</p>
<ul>
<li><p>如果需要排序的数据量小于“排序缓冲区”，MySQL使用内存进行“快排”。如果内存不够，MySQL先将数据分块，每个独立的块使用快排然后刷到磁盘上，最后将各个排好序的块合并。</p>
</li>
<li><p>排序算法：</p>
<ul>
<li><p>两次传输排序：读取行指针和需要排序的字段，对其进行排序，然后根据排序结果读取所需要的数据行。优点是排序的时候存储尽可能少的数据，缺点是第二次数据传输的时候又大量的随机I/O</p>
</li>
<li><p>单次传输排序：先读取查询所需要的所有的列，然后再根据给定列进行排序，最后直接返回结果</p>
</li>
</ul>
</li>
<li><p>关联查询的时候如果需要排序：</p>
<ul>
<li>orderBy 子句中的所有列全部来自关联的第一个表，那么 MySQL 在关联处理第一个表时就进行文件排序。Extra：Using filesort</li>
<li>除此之外，MySQL 都会将关联的结果存放在一个临时表中，在所有的关联都结束的时候，再进行文件排序。Extra：Using temporary；Using filesort</li>
<li>有limit，也会对全量数据排序，然后返回较少的数据（5.6版本之后，对这个有优化，不再是全量数据排序）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h3><ul>
<li>解析和优化阶段，MySQL生成对应的执行计划(数据结构)</li>
<li>查询中的每个表有一个handler的实例表示，存储引擎的接口称为handler API</li>
</ul>
<h3 id="返回结果给客户端：TCP"><a href="#返回结果给客户端：TCP" class="headerlink" title="返回结果给客户端：TCP"></a>返回结果给客户端：TCP</h3>]]></content>
      <categories>
        <category>高性能MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>关系数据理论</title>
    <url>/2020/05/10/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="不规范的模式存在的问题"><a href="#不规范的模式存在的问题" class="headerlink" title="不规范的模式存在的问题"></a>不规范的模式存在的问题</h1><ol>
<li>数据冗余</li>
<li>更新异常</li>
<li>插入异常</li>
<li>删除异常</li>
</ol>
<h1 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>定义：设 R(U) 是属性集 U 上的关系模式，X, Y 是 U 的子集。若对于 R(U) 的任意一个可能的关系r, r中不可能存在两个元组在 X 上的属性值相等，而在 Y 上的属性值不相等，则称 <strong>X 函数决定于 Y 或 Y 函数依赖于 X</strong>, 记作 X –&gt; Y</p>
<p>X 函数决定于 Y, 但 Y ∉ X，则称 X 函数决定于 Y 是非平凡的函数依赖。</p>
<p>X 函数决定于 Y, 但 Y ∈ X，则称X 函数决定于 Y 是平凡的函数依赖。(必然成立)</p>
<p>在 R(U) 中，如果 X 函数决定于 Y, 并且对于 X 的任意一个真子集 X’, 都有 X‘ 不能函数决定于 Y, 则称 Y 对 X <strong>完全函数依赖</strong>。</p>
<p>在 R(U)中，如果 X 函数决定于 Y (Y ∉ X)，Y 不函数决定于 X，Y 函数决定于 Z，Z ∉ Y 则称 Z 对 X 传递函数依赖。 </p>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>第一范式：二维表中每一个分量必须是不可分的数据项。</p>
<hr>
<p><strong>第二范式</strong>：若 R ∈ 1 NF, 并且每一个非主属性完全函数依赖于任何一个候选键。</p>
<p>例如 S-L-C(<u>Sno</u>, Sdept, Sloc, <u>Cno</u>, Grade)</p>
<p>函数依赖有</p>
<p>(Sno, Cno) –&gt; Grande 完全函数依赖</p>
<p>Sno –&gt; Sdept</p>
<p>Sno –&gt; Sloc</p>
<p>Sdept –&gt; Sloc</p>
<p>(Sno, Cno) –&gt; Sdept 部分函数依赖</p>
<p>(Sno, Cno) –&gt; Sloc 部分函数依赖</p>
<p>则 S-L-C 不属于第二范式，因为非主属性 Sdept, Sloc 并不完全函数依赖于键。</p>
<p>因此可能产生的问题：</p>
<ol>
<li><p>插入异常：如果此学生还未选课，则不能插入。因为键值一部分为空。</p>
</li>
<li><p>删除异常：如果一个学生只选了一门课，则他退课的时候，所有关于该生的信息都删除了。</p>
</li>
<li><p>修改复杂：如果一个学生转系了，则需要更新所有的 Sdept, Sloc。</p>
</li>
</ol>
<p>进行模式分解：SC(<u>Sno, Cno</u>, Grade) 和 SL(<u>Sno</u>, Sdept, Sloc)</p>
<hr>
<p><strong>第三范式</strong>：若 R 属于第三范式，则每一个非主属性既不传递依赖于键，也不部分依赖于键。</p>
<p>例如 SL(<u>Sno</u>, Sdept, Sloc), 其中 Sloc 传递依赖于 Sno，因此SL不属于第三范式。</p>
<p>继续模式分解：SD(Sno, Sdept) 和 DL(Sdept, Sloc)</p>
]]></content>
      <categories>
        <category>数据库系统概论</category>
      </categories>
  </entry>
  <entry>
    <title>高性能MySQL读书笔记第十章：复制</title>
    <url>/2020/05/10/Database/MySQL/%E9%AB%98%E6%80%A7%E8%83%BDMySQL%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%9A%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h2 id="复制概述"><a href="#复制概述" class="headerlink" title="复制概述"></a>复制概述</h2><p>基于行的复制和基于语句的复制，都是通过在主库上记录二进制日志，在备库重放日志的方式来实现异步的数据复制。</p>
<h3 id="复制解决的问题"><a href="#复制解决的问题" class="headerlink" title="复制解决的问题"></a>复制解决的问题</h3><ol>
<li>数据分布</li>
<li>负载均衡</li>
<li>备份</li>
<li>高可用性和故障切换</li>
<li>MySQL升级测试</li>
</ol>
<h3 id="复制如何工作"><a href="#复制如何工作" class="headerlink" title="复制如何工作"></a>复制如何工作</h3><ul>
<li>在主库上把数据更改记录到二进制日志中</li>
</ul>
<p>在每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。</p>
<ul>
<li>备库将主库上的日志复制到自己的中继日志中</li>
</ul>
<p>首先，备库会启动一个 I/O 线程，该线程和主库建立一个普通的客户端连接</p>
<p>然后在主库中建立启动一个特殊的二进制转储线程，该线程会读取主库上二进制日志中的事件。（wait，notify）</p>
<ul>
<li>备库读取中继日志中的事件，将其重放到备库数据之上</li>
</ul>
<p>这种复制架构实现了事件的获取和重返事件的解耦，允许这两个过程异步进行。也就是 I/O 线程能够独立于 SQL 线程之外工作。</p>
<p>主库上并发运行的查询到备库上只能串行化执行，因为只有一个 SQL 线程来重放中继日志中的事件</p>
]]></content>
      <categories>
        <category>高性能MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>并发控制</title>
    <url>/2020/05/10/Database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<ul>
<li>封锁协议：</li>
</ul>
<ol>
<li>一级封锁协议：事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。（解决了丢失修改）</li>
<li>二级封锁协议：在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁。（解决了 读“脏”数据）</li>
<li>三级封锁协议：在一级封锁协议的基础上增加事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放。（解决了不可重复读）</li>
</ol>
<ul>
<li>活锁：类似于操作系统“饿死进程”的情况，解决方案 先来先服务</li>
<li>死锁：</li>
</ul>
<ul>
<li><p>并发调度的可串行性：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，称这种调度策略为可串行化调度。</p>
<p>可串行化是并发事务正确调度的准则。</p>
</li>
</ul>
<ul>
<li>两段锁协议：所有事务必须分两个阶段对数据项进行加锁和解锁<ul>
<li>在对任何数据进行读、写之前，首先要申请并获得对该数据的封锁</li>
<li>在释放一个封锁之后，事务不再申请和获得任何其他封锁。</li>
</ul>
</li>
</ul>
<p>事务遵守两段锁协议是可串行化调度的充分不必要条件。</p>
]]></content>
      <categories>
        <category>数据库系统概论</category>
      </categories>
  </entry>
  <entry>
    <title>KMP Algorithm</title>
    <url>/2020/05/10/Algorithms/April/KMP%20Algorithm/</url>
    <content><![CDATA[<p>字符串的前缀：除最后一个字符以外，字符串的所有头部子串。</p>
<p>字符串的后缀：除第一个字符以外，字符串的所有尾部子串。</p>
<p>部分匹配值：字符串的前缀和后缀的最长相等前后缀长度。</p>
<ul>
<li>‘a’ 的前缀和后缀都为空集，最长相等前后缀长度为0</li>
<li>‘aba’ 的前缀为 {a, ab}, 后缀为{a, ba}, 最长相等前后缀长度为1</li>
</ul>
<p>移动位数 = 已匹配的字符数 - 对应的部分匹配值</p>
<p>如下图所示，当 c 与 b 不匹配时，已匹配 ‘abca’ 的前缀 a 和后缀 a 为最长的公共元素。已知前缀 a 与 b、c 均不同，与后缀 a 相同，故无须比较，直接将子串移动“已匹配的字符数 - 对应的部分匹配值”，用子串前缀后面的元素与主串匹配失败的元素开始比较即可。</p>
<p><img src="https://github.com/Wayne-98/image/blob/master/Algorithms/KMP%20next.png?raw=true" alt=""></p>
<p>next数组的求解方法</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>子丰哥刷题经验</title>
    <url>/2020/05/10/Algorithms/April/%E5%AD%90%E4%B8%B0%E5%93%A5%E5%88%B7%E9%A2%98%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<p>可以多反问自己<br>就是为什么没做出来之类的问题</p>
<ul>
<li>是思路困难</li>
<li>还是实现困难<br>如果是思路困难就想 是因为不知道什么 才导致自己没想出来<br>或者去练这个tag<br>如果是实现困难<br>那说明练的还不够多..</li>
</ul>
<ul>
<li>多总结</li>
<li>前期做题保质量</li>
<li>不太贪图数量 数量没啥用的</li>
</ul>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法复习</title>
    <url>/2020/05/10/Algorithms/April/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = r.nextInt(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        quickSort(a, 0, a.length - 1);</span></span><br><span class="line">        mergeSort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergeSort(nums, left, mid);</span><br><span class="line">        mergeSort(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(nums, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] t = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> L = left, m = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= mid &amp;&amp; m &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[L] &lt; nums[m]) t[index++] = nums[L++];</span><br><span class="line">            <span class="keyword">else</span> t[index++] = nums[m++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= mid) t[index++] = nums[L++];</span><br><span class="line">        <span class="keyword">while</span> (m &lt;= right) t[index++] = nums[m++];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length; i++) &#123;</span><br><span class="line">            nums[left + i] = t[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> partition = partition(nums, left, right);</span><br><span class="line">        quickSort(nums, left, partition - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, partition + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> t = r.nextInt(right - left);</span><br><span class="line">        swap(nums, left, left + t);</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left];</span><br><span class="line">        <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] &gt;= pivot) R--;</span><br><span class="line">            nums[L] = nums[R];</span><br><span class="line">            <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] &lt;= pivot) L++;</span><br><span class="line">            nums[R] = nums[L];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[L] = pivot;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(nums, j, j - <span class="number">1</span>);</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> dk = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; len / dk) &#123;</span><br><span class="line">            h = dk * h + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; nums[j] &lt; nums[j - h]; j -= h) &#123;</span><br><span class="line">                    swap(nums, j, j - h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h /= dk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        buildMaxHeap(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            adjustDown(nums, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustDown(nums, i, nums.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k * <span class="number">2</span>; i &lt; len; i *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len - <span class="number">1</span> &amp;&amp; nums[i + <span class="number">1</span>] &gt; nums[i]) i++;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = nums[i];</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[k] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binaryInsertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = nums[i];</span><br><span class="line">            <span class="keyword">int</span> L = <span class="number">0</span>, R = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &gt; t) R = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> L = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt; R; j--)</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[R + <span class="number">1</span>] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; nums[j + <span class="number">1</span>]; j--)</span><br><span class="line">                swap(nums, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = nums[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; t; j--)</span><br><span class="line">                nums[j + <span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[j + <span class="number">1</span>] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer复习</title>
    <url>/2020/05/13/Algorithms/May/%E5%89%91%E6%8C%87Offer%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ol>
<li><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/" target="_blank" rel="noopener">用两个栈实现队列</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack1;</span><br><span class="line">    Deque&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if(stack1.size() &gt; 0) &#123;</span></span><br><span class="line">        <span class="comment">//    while(stack1.size() &gt; 0)</span></span><br><span class="line">        <span class="comment">//        stack2.push(stack1.pop());</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">// 不需要每次判断 s1 是否有元素，只让 s1 负责进栈就好</span></span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(stack1.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(stack1.size() &gt; <span class="number">0</span>)</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/" target="_blank" rel="noopener">包含min函数的栈</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack;</span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(minStack.isEmpty() || x &lt;= minStack.peek())</span><br><span class="line">            minStack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(t == minStack.peek()) minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">滑动窗口的最大值</a></li>
</ol>
<ul>
<li>用一个单调递减的双端队列（单调递减是数组的值递减，队列里记录的是数组的下标）</li>
<li>首先判断队列头的下标是否过期</li>
<li>然后判断窗口是否形成</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(q.size() &gt; <span class="number">0</span> &amp;&amp; nums[q.peekLast()] &lt;= nums[i]) q.pollLast();</span><br><span class="line">            q.offerLast(i);</span><br><span class="line">            <span class="keyword">if</span>(q.peekFirst() == (i - k)) q.pollFirst();</span><br><span class="line">            <span class="keyword">if</span>((i - k + <span class="number">1</span>) &gt;= <span class="number">0</span>) res[index++] = nums[q.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/" target="_blank" rel="noopener">队列的最大值</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; list;</span><br><span class="line">    LinkedList&lt;Integer&gt; maxList;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        maxList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(maxList.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> maxList.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        list.offerLast(value);</span><br><span class="line">        <span class="keyword">while</span>(maxList.size() &gt; <span class="number">0</span> &amp;&amp; value &gt; maxList.peekLast())</span><br><span class="line">            maxList.pollLast();</span><br><span class="line">        maxList.offerLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = list.pollFirst();</span><br><span class="line">        <span class="keyword">if</span>(t == maxList.peekFirst()) maxList.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ol>
<li><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">最小的k个数</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.length == <span class="number">0</span> || k == <span class="number">0</span> ||  k &gt; arr.length) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            maxHeap.offer(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; maxHeap.peek()) &#123;</span><br><span class="line">                maxHeap.poll();</span><br><span class="line">                maxHeap.offer(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            res[i] = maxHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/" target="_blank" rel="noopener">数据流中的中位数</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 最小堆保存大的值，最大堆保存小的值</span></span><br><span class="line">     <span class="comment">// 那么每次取中位数，偶数情况下就是两个堆的堆顶值的和 / 2 ;</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MedianFinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>((count &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123; <span class="comment">// 奇数放在最小堆中 </span></span><br><span class="line">            <span class="comment">// 放入最小堆前，要检查当前 num 的值是否小于最大堆的堆顶</span></span><br><span class="line">            <span class="keyword">if</span>(maxHeap.size() &gt; <span class="number">0</span> &amp;&amp; num &lt; maxHeap.peek()) &#123;</span><br><span class="line">                maxHeap.offer(num);</span><br><span class="line">                num = maxHeap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(minHeap.size() &gt; <span class="number">0</span> &amp;&amp; num &gt; minHeap.peek()) &#123;</span><br><span class="line">                minHeap.offer(num);</span><br><span class="line">                num = minHeap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((count &amp; <span class="number">1</span>) == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">double</span>)minHeap.peek();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (minHeap.peek() + maxHeap.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ol>
<li><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/" target="_blank" rel="noopener">把数组排成最小的数</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(strs, (o1, o2) -&gt; (o1+o2).compareTo(o2 + o1));</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">""</span>, strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>手写快排实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String[] strs = <span class="keyword">new</span> String[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(strs);</span><br><span class="line">        <span class="keyword">return</span> String.join(<span class="string">""</span>, strs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        sort(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String[] strs, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;<span class="comment">// 大于等于</span></span><br><span class="line">        <span class="keyword">int</span> pivot = partition(strs, low, high);</span><br><span class="line">        sort(strs, low, pivot - <span class="number">1</span>);</span><br><span class="line">        sort(strs, pivot + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(String[] strs, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = low, R = high;</span><br><span class="line">        String pivot = strs[L];</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">while</span>(L &lt; R &amp;&amp; (strs[R] + pivot).compareTo(pivot + strs[R]) &gt;= <span class="number">0</span>) R--;</span><br><span class="line">            strs[L] = strs[R];</span><br><span class="line">            <span class="keyword">while</span>(L &lt; R &amp;&amp; (strs[L] + pivot).compareTo(pivot + strs[L]) &lt;= <span class="number">0</span>) L++;</span><br><span class="line">            strs[R] = strs[L];</span><br><span class="line">        &#125;</span><br><span class="line">        strs[L] = pivot;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ol>
<li><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/" target="_blank" rel="noopener">二进制中1的个数</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; <span class="number">1</span>) != <span class="number">0</span>) res++;</span><br><span class="line">            n = (n &gt;&gt;&gt; <span class="number">1</span>);<span class="comment">// 注意此处需要用 &gt;&gt;&gt; 而不是 &gt;&gt; ，无符号右移，前面全部补 0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>(n−1) 解析：</strong> 二进制数字 <em>n</em> 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1 。</li>
<li><strong>n&amp;(n−1) 解析：</strong> 二进制数字 <em>n</em> 最右边的 1 变成 0 ，其余不变。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            n = (n &amp; (n - <span class="number">1</span>));</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中出现次数超过一半的数字</a></li>
</ol>
<ul>
<li>迷惑，为什么 LeetCode 分类到位运算了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == res) count++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(--count == <span class="number">0</span>) &#123;</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                    res = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>图论算法复习</title>
    <url>/2020/05/10/Algorithms/May/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h1><p>图的定义：图 G 由顶点集 V 和边集 E 组成，记为 G = (V, E), 其中 V(G) 表示图 G 中顶点的有限非空集；E(G) 表示图中顶点之间的关系(边)集合。</p>
<p>连通：在无向图中，若从顶点 v 到顶点 w 之间有路径存在，则称 v 和 w 是连通的。</p>
<p>连通分量：无向图中的极大连通子图称为连通分量。</p>
<p>生成树：连通图的生成树是包含图中所有顶点的一个极小连通子图。若图中订点数为 n，则它的生成树含有 n - 1 条边。对于生成树而言，去掉它的一条边，则会变成非连通图，若加上一条边，则会形成一条回路。</p>
<p>顶点的度：图中每个顶点的度被定义为以该顶点为端点的边的数目。</p>
<h1 id="图的存储及基本操作"><a href="#图的存储及基本操作" class="headerlink" title="图的存储及基本操作"></a>图的存储及基本操作</h1><ul>
<li><p>邻接矩阵法</p>
</li>
<li><p>邻接表法</p>
</li>
</ul>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><ul>
<li>BFS</li>
</ul>
<p>BFS 的时间复杂度：</p>
<ol>
<li>如果图是邻接表存储的。每个顶点需要访问一次，每个顶点的邻接点也需要搜索一次。O(V) + O(E)</li>
<li>如果图是邻接矩阵存储的。搜索一个顶点的邻接点需要O(V). 所以时间复杂度是O(V²)</li>
</ol>
<p><img src="" alt=""></p>
<ul>
<li>DFS</li>
</ul>
<h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h1><ul>
<li>最小生成树</li>
</ul>
<ol>
<li><p>Prim</p>
<ul>
<li>初始化：向空树 T = (Vt, Et) 中添加图 G = {V, E} 的任一顶点 u0，使 Vt = {u0}, Et = ∅</li>
<li>循环（重复操作直至 Vt  =  V）: 从图 G 中选出满足 {(u, v) | u ∈ Vt, v ∈ V - Vt} 且具有最小权值的边 (u, v) , 并置 Vt = Vt ∪ {v}, Et = Et ∪ {u, v}。</li>
</ul>
<p><img src="" alt=""></p>
</li>
</ol>
<p>Prim 算法的时间复杂度是O(V²)，不依赖于 E ，适合求解边稠密的图的最小生成树。</p>
<ol start="2">
<li><p>Kruskal</p>
<ul>
<li>初始化：Vt = V, Et = ∅。即每一个顶点构成一棵独立的树，T 此时是一个仅含 V 个顶点的森林。</li>
<li>循环（重复操作直至 T 是一棵树）：按 G 的边的权值递增顺序依次从 E - Et 中选择一条边，若这条边加入 T 后不构成回路，则将其加入 Et，否则舍弃，直到 Et 中含有 n - 1 条边。</li>
</ul>
<p><img src="" alt=""></p>
</li>
</ol>
<p>Kruskal 算法的时间复杂度是 O(E log E)</p>
<ul>
<li>最短路径</li>
</ul>
<p>两点之间的最短路径也包含了路径上其他顶点间的最短路径。</p>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>4月刷题记录</title>
    <url>/2020/05/10/Algorithms/April/4%E6%9C%88%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="4月刷题记录"><a href="#4月刷题记录" class="headerlink" title="4月刷题记录"></a>4月刷题记录</h1><h2 id="4月11日"><a href="#4月11日" class="headerlink" title="4月11日"></a>4月11日</h2><p><strong>1. <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">连续子数组的最大和</a></strong></p>
<ul>
<li>dp问题<br>很容易就看出需要用dp来解，但是没有想出来状态转移方程。因为没有考虑到最后一步的解和前一步的解，他们之间的关系</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] &lt;= <span class="number">0</span> ? nums[i] : nums[i] + dp[i - <span class="number">1</span>];</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. <a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">两数相加</a></strong></p>
<ul>
<li>链表</li>
<li>初始想法<br>拿到题目先想到遍历链表取出值，然后得到和，在new一个新链表返回。但是int会溢出</li>
<li>别人的解<br>因为链表记录的数字是反序的，正好和10进制相加进位相同，所以直接相加并记录进位就可以</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode p1 = l1, p2 = l2;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode p = newHead;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = (p1.val + p2.val + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (p1.val + p2.val + carry) / <span class="number">10</span>;</span><br><span class="line">            p.next = <span class="keyword">new</span> ListNode(t);</span><br><span class="line">            p = p.next;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = (p1.val + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (p1.val + carry) / <span class="number">10</span>;</span><br><span class="line">            p.next = <span class="keyword">new</span> ListNode(t);</span><br><span class="line">            p = p.next;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = (p2.val + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (p2.val + carry) / <span class="number">10</span>;</span><br><span class="line">            p.next = <span class="keyword">new</span> ListNode(t);</span><br><span class="line">            p = p.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">            p.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">无重复字符的最长子串</a></strong></p>
<ul>
<li>滑动窗口<br>  每次前进一位向前看有没有重复字符，选择方式有：遍历，用一个Set记录，用HashMap，key记录用来记录字符有没有重复，value用来保存下标，如果重复直接更新下标值就可以</li>
<li>之前做过所以知道用HashMap来存储下标索引</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> s.length();</span><br><span class="line">        Map&lt;Character, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        m.put(s.charAt(<span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>, res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.containsKey(s.charAt(right))) left = Math.max(left, m.get(s.charAt(right)));</span><br><span class="line">            m.put(s.charAt(right), right + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">            res = Math.max(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="4月12日"><a href="#4月12日" class="headerlink" title="4月12日"></a>4月12日</h2><ol>
<li><strong><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></strong></li>
</ol>
<ul>
<li>二分查找，找左右端点问题，之前做过，复习一下。顺利写出<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> L = findLeft(nums,target);</span><br><span class="line">        <span class="keyword">if</span>(L == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> R = findRight(nums,target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;L,R&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLeft</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L +((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L == nums.length || nums[L] != target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRight</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L +((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(R == -<span class="number">1</span> || nums[R] != target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ol start="2">
<li><strong><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">寻找两个有序数组的中位数</a></strong></li>
</ol>
<ul>
<li>二分查找<ul>
<li>大概思想看懂了，很多细节真看不懂。日后再看看吧，花了很多时间</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">最长回文子串</a></strong></li>
</ol>
<ul>
<li><p>中心扩展法</p>
<ul>
<li><p>拿到题没有想法，看解析看了这种解法比较容易接受。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expand(c,i,i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expand(c,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1,len2);</span><br><span class="line">            <span class="keyword">if</span>(len &gt; (right - left + <span class="number">1</span>)) &#123;</span><br><span class="line">                left = i - (len - <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line">                right = i + len / <span class="number">2</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left,right + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt; -<span class="number">1</span> &amp;&amp; right &lt; c.length &amp;&amp; c[left] == c[right])&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<pre><code>***</code></pre><h2 id="4月13日"><a href="#4月13日" class="headerlink" title="4月13日"></a>4月13日</h2><ol>
<li><strong><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">盛最多水的容器</a></strong></li>
</ol>
<ul>
<li>看解析<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">            res = Math.max(res, Math.min(height[L], height[R]) * (R - L));</span><br><span class="line">            <span class="keyword">if</span>(height[L] &lt; height[R]) L++;</span><br><span class="line">            <span class="keyword">else</span> R--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ol start="2">
<li><strong><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a></strong></li>
</ol>
<ul>
<li>看解析<ul>
<li><strong><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和</a></strong></li>
<li>拿到题想到暴力解法，但是没想到如何优化。这种需要考虑数组下标的，很好的优化方法是利用哈希表存储下标。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[index] &gt; <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">int</span> left = index + <span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[index] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[index] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res.add(Arrays.asList(nums[index],nums[left],nums[right]));</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    left++;right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">while</span>(index &lt; nums.length &amp;&amp; nums[index] == nums[index-<span class="number">1</span>]) index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">电话号码的字母组合</a></strong></li>
</ol>
<ul>
<li>字符串</li>
<li>回溯<br>  暴力dfs搜索</li>
</ul>
<hr>
<h2 id="4月14日"><a href="#4月14日" class="headerlink" title="4月14日"></a>4月14日</h2><ol>
<li><strong><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">有效的括号</a></strong></li>
</ol>
<ul>
<li>考研的时候做过，AC</li>
</ul>
<ol start="2">
<li><strong><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">合并两个有序链表</a></strong></li>
</ol>
<ul>
<li>考研的时候做过，AC</li>
</ul>
<ol start="3">
<li><strong><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和</a></strong></li>
</ol>
<ul>
<li>dp解法之前写过，AC</li>
<li>分治法没咋看懂，不看了</li>
<li>贪心算法(再看一下吧)</li>
</ul>
<ol start="4">
<li><strong><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">爬楼梯</a></strong></li>
</ol>
<ul>
<li>斐波那契数列</li>
<li>dp</li>
</ul>
<ol start="5">
<li><strong><a href=""></a></strong><h2 id="4月15"><a href="#4月15" class="headerlink" title="4月15"></a>4月15</h2></li>
<li><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">至少有K个重复字符的最长子串</a></li>
</ol>
<ul>
<li>拿到题目没有思路，看了大佬的分治法看懂了。</li>
</ul>
<ol start="2">
<li><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">最长公共前缀</a></li>
</ol>
<ul>
<li>暴力解法，优化的答案没咋看懂，而且优化的答案时间复杂度也不低</li>
</ul>
<ol start="3">
<li><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">字符串的排列</a></li>
</ol>
<ul>
<li>问题转化能力，将题目的抽象转化为算法容易实现的点</li>
<li>滑动窗口<h2 id="4月16"><a href="#4月16" class="headerlink" title="4月16"></a>4月16</h2></li>
</ul>
<ol>
<li><a href="https://leetcode-cn.com/problems/multiply-strings/submissions/" target="_blank" rel="noopener">字符串相乘</a></li>
</ol>
<ul>
<li>模拟乘法<br><img src="en-resource://database/1323:1" alt="6a3cc30cec8ae4c92137eaacce74582d.png"></li>
</ul>
<ol start="2">
<li><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">翻转字符串里的单词</a></li>
</ol>
<ul>
<li>正则表达式，调API AC</li>
</ul>
<ol start="3">
<li><a href="https://leetcode-cn.com/problems/simplify-path/" target="_blank" rel="noopener">简化路径</a></li>
</ol>
<ul>
<li>每一次出现“..”都要考虑上一次的内容，所以可以采用栈这个数据结构存储上次的结果</li>
<li>直接从后往前遍历，然后用一个count记录“..”的出现次数</li>
</ul>
<ol start="4">
<li><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">复原IP地址</a></li>
</ol>
<ul>
<li>回溯</li>
</ul>
<h2 id="4月17"><a href="#4月17" class="headerlink" title="4月17"></a>4月17</h2><ul>
<li>复习<br>[]在排序数组中查找元素的第一个和最后一个位置<br>[]三数之和 两数之和<br>[]电话号码的字母组合<br>[]至少有K个重复字符的最长子串<br>[]字符串相乘<br>[]复原IP地址</li>
</ul>
<h2 id="4月18"><a href="#4月18" class="headerlink" title="4月18"></a>4月18</h2><ol>
<li><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">复原IP地址</a><ul>
<li>重新写了一次</li>
</ul>
</li>
<li><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">排序链表</a><ul>
<li>思路是对的，实现的细节和数组归并还是有差别。需要好好感悟一下<ol start="3">
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">反转链表</a></li>
</ol>
</li>
<li>AC</li>
</ul>
</li>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a><ul>
<li>之前写过，但是有细节没有把握好</li>
</ul>
</li>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表</a><ul>
<li>还是有挺多细节要注意</li>
</ul>
</li>
<li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">环形链表 II</a><ul>
<li>AC(细节要注意)<h2 id="4月19"><a href="#4月19" class="headerlink" title="4月19"></a>4月19</h2></li>
</ul>
</li>
<li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个排序链表</a></li>
</ol>
<ul>
<li>拿到手的思路是两两排序，看了大佬的归并解法，理解并实现</li>
</ul>
<ol start="2">
<li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">二叉树的最近公共祖先</a></li>
</ol>
<ul>
<li>AC</li>
</ul>
<ol start="3">
<li><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/submissions/" target="_blank" rel="noopener">二叉树的锯齿形层次遍历</a></li>
</ol>
<ul>
<li>AC</li>
</ul>
<ol start="4">
<li><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></li>
</ol>
<ul>
<li>中序遍历保存二叉搜索树的值，访问</li>
<li>在前序遍历方法中加上参数</li>
</ul>
<ol start="5">
<li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/" target="_blank" rel="noopener">二叉树的前序遍历</a></li>
</ol>
<ul>
<li>非递归</li>
</ul>
<ol start="6">
<li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></li>
<li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/" target="_blank" rel="noopener">二叉树的后序遍历</a><h2 id="4月20"><a href="#4月20" class="headerlink" title="4月20"></a>4月20</h2></li>
<li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">字符串转整数</a></li>
</ol>
<ul>
<li>太多细节</li>
</ul>
<h2 id="4月21"><a href="#4月21" class="headerlink" title="4月21"></a>4月21</h2><ol>
<li><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值</a></li>
<li><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值 II</a></li>
<li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></li>
<li><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></li>
</ol>
<ul>
<li>非递归又写了一下</li>
</ul>
<ol start="5">
<li><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">完全二叉树的节点个数</a></li>
</ol>
<ul>
<li>很巧妙的解法：二分查找</li>
</ul>
<h2 id="4月23日上午"><a href="#4月23日上午" class="headerlink" title="4月23日上午"></a>4月23日上午</h2><ol>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">买卖股票的最佳时机</a></li>
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></li>
<li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank" rel="noopener">数组中重复的数字</a></li>
<li><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/" target="_blank" rel="noopener">旋转数组的最小数字</a></li>
<li><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">矩阵中的路径</a></li>
</ol>
<h2 id="4月24日"><a href="#4月24日" class="headerlink" title="4月24日"></a>4月24日</h2><ol>
<li><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">数组中的逆序对</a></p>
<ul>
<li>AC</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span>[] t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        t = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        sort(nums);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        sort(nums,left,mid);</span><br><span class="line">        sort(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        merge(nums,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = left, R = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> index = left;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= mid &amp;&amp; R &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[L] &lt;= nums[R]) t[index++] = nums[L++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                t[index++] = nums[R++];</span><br><span class="line">                count += (mid - L + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= mid) t[index++] = nums[L++];</span><br><span class="line">        <span class="keyword">while</span>(R &lt;= right) t[index++] = nums[R++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)&#123;</span><br><span class="line">            nums[i] = t[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">排序链表</a></p>
<ul>
<li>每日一题是数组归并，所以想起来之前自己写的一道链表归并</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sort(head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode <span class="title">sort</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode t = getMid(head);</span><br><span class="line">        ListNode mid = t.next;</span><br><span class="line">        t.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode left = sort(head);</span><br><span class="line">        ListNode right = sort(mid);</span><br><span class="line">        <span class="keyword">return</span> merge(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//返回的是mid节点的前一个节点</span></span><br><span class="line">    <span class="comment">//是为了方便置链表的尾节点为空</span></span><br><span class="line">    <span class="function">ListNode <span class="title">getMid</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode t = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            t = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode <span class="title">merge</span><span class="params">(ListNode p1, ListNode p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="keyword">null</span>) <span class="keyword">return</span> p2;</span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="keyword">null</span>) <span class="keyword">return</span> p1;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode p = newHead;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span> &amp;&amp; p2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1.val &lt; p2.val)&#123;</span><br><span class="line">                p.next = p1;</span><br><span class="line">                p = p.next;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p.next = p2;</span><br><span class="line">                p = p.next;</span><br><span class="line">                p2 = p2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">             p.next = p1;</span><br><span class="line">                p = p.next;</span><br><span class="line">                p1 = p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            p.next = p2;</span><br><span class="line">            p = p.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p><a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">括号生成</a></p>
<ul>
<li><p>拿到题目后，第一想法是暴力枚举所有可能的序列，然后用 isValid 函数判定，但是总是有个 bug，也没搞明白为什么，放弃</p>
</li>
<li><p>括号匹配，可以转化问题为 –&gt; 左括号的数目和右括号的数目 –&gt; 左括号可以使用的数目要大于0 –&gt; 每次使用一个右括号，那么必须先使用一次左括号 –&gt; 左括号可以使用的数目恒小于右括号可以使用的数目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        dfs(n,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 当前左括号还有几个可以使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 同上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span>; <span class="comment">// 左括号可以使用的个数严格小于右括号可以使用的个数</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            path.append(<span class="string">"("</span>);</span><br><span class="line">            dfs(left - <span class="number">1</span>, right);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            path.append(<span class="string">")"</span>);</span><br><span class="line">            dfs(left,right-<span class="number">1</span>);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个排序链表</a></p>
<ul>
<li>归并排序 AC</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(lists,<span class="number">0</span>,lists.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode <span class="title">mergeSort</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        ListNode L =  mergeSort(lists, left, mid);</span><br><span class="line">        ListNode R =  mergeSort(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(L,R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并两个有序链表的API</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">            ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">            ListNode p = newHead;</span><br><span class="line">            <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">                    p.next = l1;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.next = l2;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.next = l1;</span><br><span class="line">                p = p.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.next = l2;</span><br><span class="line">                p = p.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> newHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看题解还可以使用堆解决，所以复习一下堆排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手写堆排序</span></span><br><span class="line"><span class="keyword">package</span> LeetCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] n = &#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">20</span>, <span class="number">19</span>&#125;;</span><br><span class="line">        heapSort(n);</span><br><span class="line">        System.out.println(Arrays.toString(n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        buildMaxHeap(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">            swap(nums, i, <span class="number">1</span>);</span><br><span class="line">            adjustDown(nums, <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            adjustDown(nums, i, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        nums[<span class="number">0</span>] = nums[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k * <span class="number">2</span>; i &lt; len; i *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len - <span class="number">1</span> &amp;&amp; nums[i] &lt; nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= nums[<span class="number">0</span>]) <span class="keyword">break</span>;<span class="comment">//每次比较的时候，都是与哨兵比较</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = nums[i];</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[k] = nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank" rel="noopener">最小的k个数</a></p>
<ul>
<li>手写最小堆 AC</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        buildMinHeap(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; arr.length - <span class="number">1</span> - k; i--) &#123;</span><br><span class="line">            res[index++] = arr[<span class="number">0</span>];</span><br><span class="line">            swap(arr, i, <span class="number">0</span>);</span><br><span class="line">            adjustDown(arr, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildMinHeap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            adjustDown(nums, i, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k * <span class="number">2</span>; i &lt; len; i *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; len - <span class="number">1</span> &amp;&amp; nums[i] &gt; nums[i + <span class="number">1</span>]) i++;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = nums[i];</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[k] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h2 id="4月25日"><a href="#4月25日" class="headerlink" title="4月25日"></a>4月25日</h2><ol>
<li><p><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></p>
<ul>
<li>想到了之前在牛客写的一道题，用字典序求字符串的全排列。里面有这个算法，复习了一下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//  生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。</span></span><br><span class="line">    <span class="comment">//  这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从右向左找到第一个 比右边的数小的 记该数字为nums[i]</span></span><br><span class="line">    <span class="comment">//从右向左找到第一个 该数字比 array[i] 大的数字</span></span><br><span class="line">    <span class="comment">//交换这两个数字，然后将i右边的reverse得到下一个排列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = array.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span> &amp;&amp; array[i] &gt;= array[i + <span class="number">1</span>]; i--) ; <span class="comment">//从右向左找到第一个 比右边的数小的</span></span><br><span class="line">        <span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;<span class="comment">//如果找不到比右边的数字小的，则该数组是递减的，直接返回数组的reverse</span></span><br><span class="line">            reverse(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> j = array.length - <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &lt;= array[i]; j--) ; <span class="comment">//从右向左找到第一个 该数字比 array[i] 大的数字</span></span><br><span class="line">        swap(array,i,j);</span><br><span class="line">        reverse(array, i + <span class="number">1</span>, array.length - <span class="number">1</span>);<span class="comment">//交换i j,并将i右边的数组reverse</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = nums[L];</span><br><span class="line">            nums[L] = nums[R];</span><br><span class="line">            nums[R] = t;</span><br><span class="line">            L++;R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/" target="_blank" rel="noopener">字符串的排列</a></li>
</ol>
<ul>
<li>顺带用上一题的方法写了这一题，速度比暴力dfs快很多。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;s&#125;;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">        Arrays.sort(c);</span><br><span class="line">        res.add(<span class="keyword">new</span> String(c));</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            String next = nextString(c);</span><br><span class="line">            <span class="keyword">if</span>(next.equals(<span class="string">"finish"</span>))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.add(<span class="keyword">new</span> String(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">nextString</span><span class="params">(<span class="keyword">char</span>[] c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = c.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &gt;= <span class="number">0</span> &amp;&amp; c[j] &gt;= c[j+<span class="number">1</span>]; j--) ; <span class="comment">//找到第一个 比右边的小的</span></span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span>) <span class="keyword">return</span> <span class="string">"finish"</span>;</span><br><span class="line">        <span class="keyword">int</span> i = c.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i &gt;= <span class="number">0</span> &amp;&amp; c[i] &lt;= c[j]; i--) ;</span><br><span class="line">        swap(c,i,j);</span><br><span class="line">        reverse(c,j+<span class="number">1</span>,c.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> t = c[i];</span><br><span class="line">        c[i] = c[j];</span><br><span class="line">        c[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">            swap(c,L,R);</span><br><span class="line">            L++; R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></p>
<p><a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">全排列 II</a></p>
</li>
</ol>
<ul>
<li>用字典序求全排列的算法解（有重复数字并不影响）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));</span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        res.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = next(nums);</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                res.add(Arrays.stream(nums).boxed().collect(Collectors.toList()));</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt;= nums[j+<span class="number">1</span>]; j--) ; <span class="comment">//找到第一个 比右边的小的</span></span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums[j]; i--) ;</span><br><span class="line">        swap(nums,i,j);</span><br><span class="line">        reverse(nums,j+<span class="number">1</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = c[i];</span><br><span class="line">        c[i] = c[j];</span><br><span class="line">        c[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] c, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">            swap(c,L,R);</span><br><span class="line">            L++; R--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4月26日"><a href="#4月26日" class="headerlink" title="4月26日"></a>4月26日</h2><ol>
<li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个排序链表</a></li>
</ol>
<ul>
<li>每日一题，复习一下 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(lists,<span class="number">0</span>,lists.length -<span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &gt;= R) <span class="keyword">return</span> lists[L];</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        ListNode left = merge(lists,L,mid);</span><br><span class="line">        ListNode right = merge(lists, mid + <span class="number">1</span>, R);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">            <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">            ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">            ListNode p = newHead;</span><br><span class="line">            <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">                    p.next = l1;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    l1 = l1.next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.next = l2;</span><br><span class="line">                    p = p.next;</span><br><span class="line">                    l2 = l2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.next = l1;</span><br><span class="line">                p = p.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                p.next = l2;</span><br><span class="line">                p = p.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> newHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU缓存机制</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快速查找，快速删除，快速插入，有顺序</span></span><br><span class="line">    DoubleList cache;<span class="comment">// 双向链表</span></span><br><span class="line">    Map&lt;Integer, Node&gt; map;<span class="comment">// 哈希表用于实现快速查找</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">        <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val = map.get(key).val;</span><br><span class="line">        put(key,val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key,value);</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key)) &#123;</span><br><span class="line">            cache.remove(map.get(key));</span><br><span class="line">            cache.addFirst(node);</span><br><span class="line">            map.put(key,node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(cache.getSize() == capacity) &#123;</span><br><span class="line">                Node last = cache.removeLast();</span><br><span class="line">                map.remove(last.key);</span><br><span class="line">            &#125;</span><br><span class="line">            cache.addFirst(node);</span><br><span class="line">            map.put(key,node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key,val;</span><br><span class="line">        Node pre, next;</span><br><span class="line">        Node(<span class="keyword">int</span> key, <span class="keyword">int</span> val)&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Node head, tail;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">this</span>.tail = <span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            head.next = tail;</span><br><span class="line">            tail.pre = head;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">            node.pre = head;</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            head.next.pre = node;</span><br><span class="line">            head.next = node;</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tail.pre == head) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Node last = tail.pre;</span><br><span class="line">            last.pre.next = tail;</span><br><span class="line">            tail.pre = last.pre;</span><br><span class="line">            size--;</span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用一个保持递减的队列，保存之前浏览过的记录。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || nums.length &lt; k) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 用一个保持递减的队列，保存之前浏览过的记录。</span></span><br><span class="line">        LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 保证单调</span></span><br><span class="line">            <span class="keyword">while</span>(q.size() &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; nums[q.peekLast()]) q.pollLast();</span><br><span class="line">            q.offerLast(i);</span><br><span class="line">            <span class="comment">// 如果当前窗口划过队列头中保存的最大值，poll</span></span><br><span class="line">            <span class="keyword">if</span>(q.peekFirst() == (i - k)) q.pollFirst();</span><br><span class="line">            <span class="comment">// 如果窗口已经形成，添加到res中</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= (k - <span class="number">1</span>)) res[index++] = nums[q.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4月27号"><a href="#4月27号" class="headerlink" title="4月27号"></a>4月27号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">搜索旋转排序数组</a></li>
</ol>
<ul>
<li>之前写过，但是重新写又有很多小细节没有把握好</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> reversePoint = findreversePoint(nums);</span><br><span class="line">        <span class="keyword">int</span> L = binarySearch(nums,<span class="number">0</span>,reversePoint - <span class="number">1</span>, target);</span><br><span class="line">        <span class="keyword">if</span>(L != -<span class="number">1</span>) <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums,reversePoint,len - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)  R = mid - <span class="number">1</span>;<span class="comment">// 所要找的target在mid左边</span></span><br><span class="line">            <span class="keyword">else</span> L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findreversePoint</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[L] &lt; nums[R]) <span class="keyword">return</span> L;<span class="comment">// 如果此刻已经是升序，则L已经找到位置，retrun</span></span><br><span class="line">            <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[R]) R = mid;<span class="comment">// 因为我们需要找最小值，当right = mid - 1,就有可能错过最小值，直接到左边升序数组中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[L]) L = mid + <span class="number">1</span>;<span class="comment">//如果我们不小心到右边升序数组中，那么每计算一次mid，right 就有左移，直到left</span></span><br><span class="line">            <span class="keyword">else</span> L++;<span class="comment">// 如果有重复元素，则会到这个逻辑中，直接让向前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">寻找旋转排序数组中的最小值 II</a></li>
</ol>
<ul>
<li>第一题的细节出错在这道题上，重新写了一遍</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[L] &lt; nums[R]) <span class="keyword">return</span> nums[L];<span class="comment">// 如果此刻已经是升序，则L已经找到位置，retrun</span></span><br><span class="line">            <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[R]) R = mid;<span class="comment">// 因为我们需要找最小值，当right = mid - 1,就有可能错过最小值，直接到左边升序数组中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; nums[L]) L = mid + <span class="number">1</span>;<span class="comment">//如果我们不小心到右边升序数组中，那么每计算一次mid，right 就有左移，直到left</span></span><br><span class="line">            <span class="keyword">else</span> L++;<span class="comment">// 如果有重复元素，则会到这个逻辑中，直接让向前移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[L];</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4月28号"><a href="#4月28号" class="headerlink" title="4月28号"></a>4月28号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">数组中数字出现的次数</a></li>
</ol>
<ul>
<li>很简单，很快AC</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> all = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            all ^= num; <span class="comment">// 数组全部数字异或的结果，也就是两个不同的数字的异或的结果</span></span><br><span class="line">        <span class="keyword">int</span> bit = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((bit &amp; all) == <span class="number">0</span>)</span><br><span class="line">            bit &lt;&lt;= <span class="number">1</span>;<span class="comment">//用bit找到两个数字异或的结果里，第一位不为零的，也就是两个不同的数字，在这一位上不同</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>((num &amp; bit) != <span class="number">0</span>)</span><br><span class="line">                a ^= num;<span class="comment">// bit区分开要找的两个数字不同的，然后分组，用a,b异或得到结果</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a,b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> symmetric(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">symmetric</span><span class="params">(TreeNode A, TreeNode B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> &amp;&amp; B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> symmetric(A.left, B.right) &amp;&amp; symmetric(A.right, B.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">二叉树的层序遍历</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size(); <span class="comment">// 记录当前层数的节点数量，然后全部出对，同时把下一层的节点全部加入</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode temp = q.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>) q.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>) q.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">二叉树的层次遍历 II</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最小深度</a></p>
</li>
</ol>
<ul>
<li>最大深度和最小深度有一个很大的区别，最大深度能够保证最后一个节点绝对是叶子节点，而最小深度不行。因为最小深度的时候，如果一个节点左右孩子节点只有一个为空，则他会返回空的那个，而不是继续向下寻找</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.left);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span> &amp;&amp; root.left == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.min(minDepth(root.left), minDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(maxDepth(root.left), maxDepth(root.right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(s.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            TreeNode t = s.pop();</span><br><span class="line">            res.add(t.val);</span><br><span class="line">            <span class="keyword">if</span>(t.right != <span class="keyword">null</span>) s.push(t.right);</span><br><span class="line">            <span class="keyword">if</span>(t.left != <span class="keyword">null</span>) s.push(t.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">路径总和</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; nodeStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; valueStack = <span class="keyword">new</span> Stack&lt;&gt;(); </span><br><span class="line">        nodeStack.push(root);</span><br><span class="line">        valueStack.push(sum -= root.val);</span><br><span class="line">        <span class="keyword">while</span>(!nodeStack.isEmpty()) &#123;</span><br><span class="line">            TreeNode t = nodeStack.pop();</span><br><span class="line">            <span class="keyword">int</span> temp = valueStack.pop();</span><br><span class="line">            <span class="comment">// 如果为叶子结点，并且此时valueStack栈顶的值为零</span></span><br><span class="line">            <span class="keyword">if</span>(t.left == <span class="keyword">null</span> &amp;&amp; t.right == <span class="keyword">null</span> &amp;&amp; temp == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(t.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nodeStack.push(t.right);</span><br><span class="line">                valueStack.push(temp - t.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(t.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                nodeStack.push(t.left);</span><br><span class="line">                valueStack.push(temp - t.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> sum == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum) || hasPathSum(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">二叉树展开为链表</a></li>
</ol>
<ul>
<li>展开后的链表相当于先序遍历的结果，为了修改指针的时候，不丢失值，采用 right left root 的后序遍历方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        flatten(root.right);</span><br><span class="line">        flatten(root.left);</span><br><span class="line">        root.right = pre;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        pre = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">二叉树的后序遍历</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        TreeNode lastVisit = root; </span><br><span class="line">        <span class="keyword">while</span>(s.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode t = s.peek();</span><br><span class="line">            <span class="keyword">if</span>(t.left != <span class="keyword">null</span> &amp;&amp; t.left != lastVisit &amp;&amp; t.right != lastVisit) s.push(t.left);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t.right != <span class="keyword">null</span> &amp;&amp; t.right != lastVisit) s.push(t.right);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode visit = s.pop();</span><br><span class="line">                res.add(visit.val);</span><br><span class="line">                lastVisit = visit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4月29"><a href="#4月29" class="headerlink" title="4月29"></a>4月29</h2><ol>
<li><a href="https://leetcode-cn.com/problems/find-in-mountain-array/" target="_blank" rel="noopener">山脉数组中查找目标值</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = mountainArr.length();</span><br><span class="line">        <span class="keyword">int</span> mountainPoint = findMountainPoint(mountainArr);</span><br><span class="line">        <span class="keyword">int</span> L = binarySearchLeft(mountainArr,<span class="number">0</span>,mountainPoint, target);</span><br><span class="line">        <span class="keyword">if</span>(L != -<span class="number">1</span>) <span class="keyword">return</span> L;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> binarySearchRight(mountainArr, mountainPoint, len - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearchLeft</span><span class="params">(MountainArray mountainArr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(mountainArr.get(mid) == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mountainArr.get(mid) &gt; target) R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">binarySearchRight</span><span class="params">(MountainArray mountainArr, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(mountainArr.get(mid) == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mountainArr.get(mid) &gt; target) L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 仔细审题，这题是peek 不是 reverse</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMountainPoint</span><span class="params">(MountainArray mountainArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = mountainArr.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (mountainArr.get(mid) &lt; mountainArr.get(mid + <span class="number">1</span>))</span><br><span class="line">                L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> R = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>敏感词过滤算法</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensitiveService</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> end;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Character, TrieNode&gt; subNodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(Character key, TrieNode node)</span> </span>&#123;</span><br><span class="line">            subNodes.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">TrieNode <span class="title">getSubNode</span><span class="params">(Character key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> subNodes.get(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setKeyWordEnd</span><span class="params">(<span class="keyword">boolean</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isKeyWordEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWords</span><span class="params">(String lineText)</span> </span>&#123;<span class="comment">// 构造前缀树</span></span><br><span class="line">        TrieNode tempNode = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineText.length(); i++) &#123;</span><br><span class="line">            Character c = lineText.charAt(i);</span><br><span class="line">            TrieNode node = tempNode.getSubNode(c);</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                tempNode.addSubNode(c, node);</span><br><span class="line">            &#125;</span><br><span class="line">            tempNode = node;</span><br><span class="line">            <span class="keyword">if</span> (i == lineText.length() - <span class="number">1</span>)</span><br><span class="line">                tempNode.setKeyWordEnd(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filter</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(text)) <span class="keyword">return</span> text;</span><br><span class="line"></span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String replace = <span class="string">"***"</span>;</span><br><span class="line">        TrieNode tempNode = root;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (position &lt; text.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = text.charAt(position);</span><br><span class="line">            <span class="keyword">if</span> (isSymbol(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tempNode == root) &#123;<span class="comment">// 如果是刚开始查找，而不是混入敏感词之间的</span></span><br><span class="line">                    res.append(c);</span><br><span class="line">                    ++begin;</span><br><span class="line">                &#125;</span><br><span class="line">                ++position;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tempNode = tempNode.getSubNode(c);</span><br><span class="line">            <span class="keyword">if</span> (tempNode == <span class="keyword">null</span>) &#123;<span class="comment">// 如果没有找到，则不是敏感词。begin++</span></span><br><span class="line">                res.append(text.charAt(begin));</span><br><span class="line">                position = begin + <span class="number">1</span>;</span><br><span class="line">                begin = position;</span><br><span class="line">                tempNode = root;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tempNode.isKeyWordEnd()) &#123;<span class="comment">// 找到了，而且标记为敏感词</span></span><br><span class="line">                res.append(replace);</span><br><span class="line">                position = position + <span class="number">1</span>;</span><br><span class="line">                begin = position;</span><br><span class="line">                tempNode = root;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++position;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(text.substring(begin));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymbol</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ic = (<span class="keyword">int</span>) c;</span><br><span class="line">        <span class="comment">// 东亚文字</span></span><br><span class="line">        <span class="keyword">return</span> !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (ic &lt; <span class="number">0x2E80</span> || ic &gt; <span class="number">0x9FFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 语句</title>
    <url>/2020/05/10/Database/SQL/sql%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取 Employee 表中第 n 高的薪水（Salary）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> getNthHighestSalary(N <span class="built_in">INT</span>) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">set</span> n = N - <span class="number">1</span>;</span><br><span class="line">  RETURN (</span><br><span class="line">      <span class="comment"># Write your MySQL query statement below.</span></span><br><span class="line">            <span class="keyword">select</span> <span class="keyword">ifnull</span>( <span class="comment"># 如果第一个值为 null，则返回第二个值</span></span><br><span class="line">            (</span><br><span class="line">              <span class="keyword">select</span> <span class="keyword">distinct</span> salary </span><br><span class="line">              <span class="keyword">from</span> employee </span><br><span class="line">              <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">               <span class="keyword">limit</span> n, <span class="number">1</span> <span class="comment"># 从第 n 行开始，返回一行数据</span></span><br><span class="line">            ), <span class="literal">null</span>)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Score, </span><br><span class="line">       <span class="keyword">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) <span class="keyword">as</span> <span class="string">'Rank'</span></span><br><span class="line"><span class="keyword">from</span> Scores;</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> Email</span><br><span class="line"><span class="keyword">from</span> person</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> Email</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(Email) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">'Name'</span> <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> Customers a <span class="keyword">left</span> <span class="keyword">join</span> Orders b <span class="keyword">on</span> a.id = b.CustomerId <span class="keyword">where</span> b.id <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment"># 要判断一个数是否等于NULL只能用 IS NULL 或者 IS NOT NULL 来判断</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">Name</span> <span class="keyword">as</span> Customers</span><br><span class="line"><span class="keyword">from</span> Customers</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> CustomerId </span><br><span class="line">    <span class="keyword">from</span> orders</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> p1</span><br><span class="line"><span class="keyword">from</span> (person p1 <span class="keyword">left</span> <span class="keyword">join</span> person p2 <span class="keyword">on</span> p1.email = p2.email )</span><br><span class="line"><span class="keyword">where</span> p1.id &gt; p2.id;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>5月刷题记录</title>
    <url>/2020/05/10/Algorithms/May/5%E6%9C%88%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="5月2号"><a href="#5月2号" class="headerlink" title="5月2号"></a>5月2号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从前序与中序遍历序列构造二叉树</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || in.length == <span class="number">0</span> || pre.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(pre,<span class="number">1</span>,i+<span class="number">1</span>), Arrays.copyOfRange(in,<span class="number">0</span>,i));</span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(pre,i+<span class="number">1</span>,pre.length), Arrays.copyOfRange(in, i+<span class="number">1</span>, in.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解法运行速度慢，可能是每次递归的时候都会copy一个新数组，想要优化一下，写了半天没写出来</li>
</ul>
<ol start="2">
<li><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">回文链表</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// if() return false;</span></span><br><span class="line">        ListNode mid = findMid(head);</span><br><span class="line">        ListNode reverse = reverseList(mid);</span><br><span class="line">        <span class="keyword">while</span>(head != mid) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head.val != reverse.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            head = head.next;</span><br><span class="line">            reverse = reverse.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode t = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            t = head.next;</span><br><span class="line">            head.next = newHead.next;</span><br><span class="line">            newHead.next = head;</span><br><span class="line">            head = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode <span class="title">findMid</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5月3号"><a href="#5月3号" class="headerlink" title="5月3号"></a>5月3号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/" target="_blank" rel="noopener">重建二叉树</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(pre, <span class="number">1</span>, i + <span class="number">1</span>), Arrays.copyOfRange(in, <span class="number">0</span>, i));</span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(pre, i + <span class="number">1</span>, pre.length), Arrays.copyOfRange(in, i + <span class="number">1</span>, in.length));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/" target="_blank" rel="noopener">矩阵中的路径</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] v;</span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        v = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        c = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[row][col] || board[row][col] != c[len]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == c.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">        v[row][col] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(row &gt; <span class="number">0</span> &amp;&amp; dfs(board, row - <span class="number">1</span>, col, len + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(row &lt; board.length - <span class="number">1</span> &amp;&amp; dfs(board, row + <span class="number">1</span>, col, len + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(col &gt; <span class="number">0</span> &amp;&amp; dfs(board, row, col - <span class="number">1</span>, len + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(col &lt; board[<span class="number">0</span>].length - <span class="number">1</span> &amp;&amp; dfs(board, row, col + <span class="number">1</span>, len + <span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        v[row][col] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/" target="_blank" rel="noopener">机器人的运动范围</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] v;</span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        v = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        threshold = k;</span><br><span class="line">        <span class="keyword">return</span> dfs(m,n,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(row &lt; rows &amp;&amp; col &lt;cols &amp;&amp; sum(row) + sum(col) &lt;= threshold &amp;&amp; !v[row][col])&#123;</span><br><span class="line">            v[row][col] = <span class="keyword">true</span>;</span><br><span class="line">            count = <span class="number">1</span> + dfs(rows, cols, row + <span class="number">1</span>, col) + dfs(rows, cols, row, col + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sum += (n % <span class="number">10</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>还需要再复习一下</li>
</ul>
<h2 id="5月4号"><a href="#5月4号" class="headerlink" title="5月4号"></a>5月4号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">最长回文子串</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expand(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expand(s, i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(len &gt; (right - left + <span class="number">1</span>)) &#123;</span><br><span class="line">                left = i - (len - <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">// 注意此处是 len - 1</span></span><br><span class="line">                right = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expand</span><span class="params">(String s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &lt; s.length() &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">            i--; j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j - i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">字符串转换整数 (atoi)</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; str.length() &amp;&amp; str.charAt(index) == <span class="string">' '</span>) index++;</span><br><span class="line">        <span class="keyword">if</span>(index == str.length()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> positive = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">char</span> fristChar = str.charAt(index);</span><br><span class="line">        <span class="keyword">if</span>(!isNum(fristChar)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fristChar != <span class="string">'+'</span> &amp;&amp; fristChar != <span class="string">'-'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            positive = (fristChar != <span class="string">'-'</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> limit = positive ? -Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; str.length() &amp;&amp; isNum(str.charAt(index))) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = str.charAt(index++) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">// 如果 res * 10 - t 越界, 那么 res * 10 - t &lt; limit</span></span><br><span class="line">            <span class="keyword">if</span>(res &lt; (limit + t) / <span class="number">10</span>) <span class="keyword">return</span> positive ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            res = res * <span class="number">10</span> - t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> positive ? -res : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNum</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = c - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= <span class="number">0</span> &amp;&amp; t &lt;= <span class="number">9</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5月5号"><a href="#5月5号" class="headerlink" title="5月5号"></a>5月5号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和</a></li>
</ol>
<ul>
<li>典型的回溯法解题，需要考虑去重</li>
<li>回溯法的应用：当需要对所有的结果进行暴力搜索，也就是对决策树进行遍历，适当的时候进行剪枝</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; []</span><br><span class="line">def backtrack(路径, 选择列表):</span><br><span class="line">    if 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        return</span><br><span class="line"></span><br><span class="line">    for 选择 in 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(candidates.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(list, candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剪枝方法：使用了一个 index 记录当前的访问位置，每次回溯的时候保证不会往后走，只会往前走。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;Integer&gt; list, <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">                list.add(candidates[i]);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 因为组合中可以由重复的数字出现：223 7， 所以每次回溯的时候继续从当前位置走</span></span><br><span class="line">                backtrack(list, candidates, target - candidates[i], i);</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 剪枝方法：维护一个非递减的列表，所以既满足了组合中可以出现重复数字，并且不会出现每次组合重复的情况</span></span><br><span class="line"><span class="comment">// 例如 223 232 322 都可以是 7 的组合，但是限制了非递减 所以结果只有 322</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// void backtrack(List&lt;Integer&gt; list, int[] candidates, int target ) &#123;</span></span><br><span class="line">    <span class="comment">//     if(target == 0) &#123;</span></span><br><span class="line">    <span class="comment">//         res.add(new ArrayList(list));</span></span><br><span class="line">    <span class="comment">//         return;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     if(target &gt; 0) &#123;</span></span><br><span class="line">    <span class="comment">//         for(int i = 0; i &lt; candidates.length; i++) &#123;</span></span><br><span class="line">    <span class="comment">//             if(!list.isEmpty() &amp;&amp; candidates[i] &gt; list.get(list.size() - 1)) continue;</span></span><br><span class="line">    <span class="comment">//             list.add(candidates[i]);</span></span><br><span class="line">    <span class="comment">//             dfs(list, candidates, target - candidates[i]);</span></span><br><span class="line">    <span class="comment">//             list.remove(list.size() - 1);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">下一个排列</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// // 例如839647521是数字1～9的一个排列。从它生成下一个排列的步骤如下： </span></span><br><span class="line"><span class="comment">// // 自右至左找出排列中第一个比右边数字小的数字4     839647521</span></span><br><span class="line"><span class="comment">// // 在该数字后自右向左找到第一个比4大的数字5       839647521</span></span><br><span class="line"><span class="comment">// // 将5与4交换                                839657421</span></span><br><span class="line"><span class="comment">// // 将7421倒转                                839651247</span></span><br><span class="line"><span class="comment">// // 所以839647521的下一个排列是                 839651247。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> j = nums.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt;= nums[j + <span class="number">1</span>]) j--;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span>) &#123;</span><br><span class="line">            reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; j &amp;&amp; nums[i] &lt;= nums[j]) i--;</span><br><span class="line">        swap(nums, i, j);</span><br><span class="line">        reverse(nums, j + <span class="number">1</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">            swap(nums, L++, R--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">验证二叉搜索树</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root, pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(s.size() &gt; <span class="number">0</span> || cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.pop();</span><br><span class="line">            <span class="comment">// 中序遍历是一个单调递增的序列</span></span><br><span class="line">            <span class="keyword">if</span>(pre != <span class="keyword">null</span> &amp;&amp; pre.val &gt;= cur.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次记录 up down 即父节点和子节点</span></span><br><span class="line">    <span class="comment">// public boolean isValidBST(TreeNode root) &#123;</span></span><br><span class="line">    <span class="comment">//     if(root == null) return true;</span></span><br><span class="line">    <span class="comment">//     return help(root, Long.MAX_VALUE,Long.MIN_VALUE);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// private boolean help(TreeNode root, long up, long down) &#123;</span></span><br><span class="line">    <span class="comment">//     if(root != null) &#123;</span></span><br><span class="line">    <span class="comment">//         if(root.val &gt;= up) return false;</span></span><br><span class="line">    <span class="comment">//         if(root.val &lt;= down) return false;</span></span><br><span class="line">    <span class="comment">//         return help(root.left, root.val, down) &amp;&amp; help(root.right, up, root.val);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">二叉树的后序遍历</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化的时候不能为null 否则之后的判断不合理</span></span><br><span class="line">        <span class="comment">// 但是让pre = root 也不合理，因为此时上次访问的节点不是root !!!待解决</span></span><br><span class="line">        TreeNode pre = root; </span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span>(s.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode t = s.peek();</span><br><span class="line">            <span class="comment">// 当pre为空的时候，有一个节点其右节点为空，那么此时 pre == t.right</span></span><br><span class="line">            <span class="keyword">if</span>(t.left != <span class="keyword">null</span> &amp;&amp; pre != t.left &amp;&amp; pre != t.right) &#123; </span><br><span class="line">                s.push(t.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(t.right != <span class="keyword">null</span> &amp;&amp; pre != t.right) &#123; </span><br><span class="line">                s.push(t.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode cur = s.pop();</span><br><span class="line">                pre = cur;</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">二叉树的前序遍历</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root; </span><br><span class="line">        <span class="keyword">while</span>(s.size() &gt; <span class="number">0</span> || cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.pop();</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span></span><br><span class="line">    <span class="comment">//     List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     if(root == null) return res;</span></span><br><span class="line">    <span class="comment">//     Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     s.push(root);</span></span><br><span class="line">    <span class="comment">//     while(s.size() &gt; 0) &#123;</span></span><br><span class="line">    <span class="comment">//         TreeNode cur = s.pop();</span></span><br><span class="line">    <span class="comment">//         res.add(cur.val);</span></span><br><span class="line">    <span class="comment">//         if(cur.right != null) s.push(cur.right);</span></span><br><span class="line">    <span class="comment">//         if(cur.left != null) s.push(cur.left);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5月6号"><a href="#5月6号" class="headerlink" title="5月6号"></a>5月6号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/n-queens/" target="_blank" rel="noopener">N皇后</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">char</span>[][] board = <span class="keyword">new</span> <span class="keyword">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>[] ch : board) Arrays.fill(ch, <span class="string">'.'</span>);</span><br><span class="line">        backtrack(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == board.length) &#123;</span><br><span class="line">            res.add(charsToString(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; board[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isValid(board, row, col)) &#123;</span><br><span class="line">                board[row][col] = <span class="string">'Q'</span>;</span><br><span class="line">                backtrack(board, row + <span class="number">1</span>);</span><br><span class="line">                board[row][col] = <span class="string">'.'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>[] c : board)</span><br><span class="line">            <span class="keyword">if</span>(c[col] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--)</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; board[i].length; i--, j++)</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">'Q'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">charsToString</span><span class="params">(<span class="keyword">char</span>[][] c)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span>[] ch : c) &#123;</span><br><span class="line">            l.add(String.valueOf(ch));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">全排列</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] v;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">        v = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!v[i]) &#123;</span><br><span class="line">                v[i] = <span class="keyword">true</span>;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                backtrack(nums);</span><br><span class="line">                path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">                v[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/lru-cache/" target="_blank" rel="noopener">LRU缓存机制</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Node&gt; m;</span><br><span class="line">    DoubleList cache;</span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache = <span class="keyword">new</span> DoubleList();</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = m.get(key).value;</span><br><span class="line">            put(key,val);</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">        <span class="keyword">if</span>(m.containsKey(key)) &#123;</span><br><span class="line">            cache.remove(m.get(key));</span><br><span class="line">            cache.addFirst(node);</span><br><span class="line">            m.put(key, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(cache.size == capacity) &#123;</span><br><span class="line">                Node last = cache.removeLast();</span><br><span class="line">                m.remove(last.key);</span><br><span class="line">            &#125;</span><br><span class="line">            cache.addFirst(node);</span><br><span class="line">            m.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">        Node head;</span><br><span class="line">        Node tail;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.head = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">this</span>.tail = <span class="keyword">new</span> Node(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            head.next = tail;</span><br><span class="line">            tail.pre = head;</span><br><span class="line">            <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            size++;</span><br><span class="line">            node.pre = head;</span><br><span class="line">            node.next = head.next;</span><br><span class="line">            head.next.pre = node;</span><br><span class="line">            head.next = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            size--;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Node <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(tail.pre == head) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            Node last = tail.pre;</span><br><span class="line">            remove(last);</span><br><span class="line">            <span class="keyword">return</span> last;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        Node pre;</span><br><span class="line">        Node next;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="noopener">旋转图像</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 第一个 for 用来控制每次的方块大小，因为是 n * n 的，所以用两个变量就okk</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>, end = matrix[<span class="number">0</span>].length - <span class="number">1</span>; start &lt; end; start++, end--) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 第二个 for 用来交换本次方块的值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> s = start, e = end; s &lt; end; s++, e--) &#123;</span><br><span class="line">                temp = matrix[start][s];</span><br><span class="line">                matrix[start][s] = matrix[e][start];</span><br><span class="line">                matrix[e][start] = matrix[end][e];</span><br><span class="line">                matrix[end][e] = matrix[s][end];</span><br><span class="line">                matrix[s][end] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/" target="_blank" rel="noopener">不用加减乘除做加法</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = a ^ b;</span><br><span class="line">            b = ((a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            a = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或：相同则为0 不同则为1，相当于 两个数的不进位和</span></span><br><span class="line"><span class="comment">// &amp; &lt;&lt; 1：相当于两个数和的进位</span></span><br></pre></td></tr></table></figure>

<h2 id="5月7号"><a href="#5月7号" class="headerlink" title="5月7号"></a>5月7号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">从中序与后序遍历序列构造二叉树</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.length == <span class="number">0</span> || postorder.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[postorder.length - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i] == root.val) &#123;</span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(inorder, <span class="number">0</span>, i), Arrays.copyOfRange(postorder, <span class="number">0</span>, i));</span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(inorder, i + <span class="number">1</span>, inorder.length), Arrays.copyOfRange(postorder, i, postorder.length - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">//     return build(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private TreeNode build(int[] in, int inL, int inR, int[] post, int postL, int postR) &#123;</span></span><br><span class="line">    <span class="comment">//     if(inL &gt; inR || postL &gt; postR) return null;</span></span><br><span class="line">    <span class="comment">//     TreeNode root = new TreeNode(post[postR]);</span></span><br><span class="line">    <span class="comment">//     int i = 0;</span></span><br><span class="line">    <span class="comment">//     while(in[inL + i] != root.val) i++;</span></span><br><span class="line">    <span class="comment">//     root.left = build(in, inL, inL + i - 1, post, postL, postL + i - 1);</span></span><br><span class="line">    <span class="comment">//     root.right = build(in, inL + i + 1, inR, post, postL + i, postR - 1);</span></span><br><span class="line">    <span class="comment">//     return root;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">将有序数组转换为二叉搜索树</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toBST(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode <span class="title">toBST</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left = toBST(nums, left, mid);</span><br><span class="line">        root.right = toBST(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5月8号"><a href="#5月8号" class="headerlink" title="5月8号"></a>5月8号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">相同的树</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.val != q.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">平衡二叉树</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> help(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">help</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = help(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = help(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果左右子树的高度差小于2，那么返回 当前节点的高度，否则剪枝输出 -1</span></span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> ? Math.max(left, right) + <span class="number">1</span>: -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">//     public boolean isBalanced(TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">//         // 如果遍历到叶子节点以下，则返回真</span></span><br><span class="line"><span class="comment">//         if(root == null) return true;   </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         // 对每个遍历的节点，查看其左右子树的高度差是否大于1</span></span><br><span class="line"><span class="comment">//         if(Math.abs(high(root.left) - high(root.right)) &gt; 1) return false;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         // 前序遍历每一个节点</span></span><br><span class="line"><span class="comment">//         return isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     private int high(TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">//         if(root == null) return 0;</span></span><br><span class="line"><span class="comment">//         return Math.max(high(root.left), high(root.right)) + 1;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最小深度</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right == <span class="keyword">null</span> &amp;&amp; root.left != <span class="keyword">null</span>) <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left), minDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为最小深度，并不像最大深度那样，每次都遍历到最底部，因为可能左子树为空，右子树不空，那么此时就会直接返回左子树的高度 0 + 1，而不是右子树的高度。这样不能全部遍历到整棵树，所以也无法求得全局最小深度</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a href="https://leetcode-cn.com/problems/path-sum/" target="_blank" rel="noopener">路径总和</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum != root.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == root.val) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// if(root.left == null &amp;&amp; root.right == null) return sum == root.val;</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><a href="https://leetcode-cn.com/problems/path-sum-ii/" target="_blank" rel="noopener">路径总和 II</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backtrack(root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; sum == root.val) &#123;</span><br><span class="line">            path.add(root.val);</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        backtrack(root.left, sum - root.val);</span><br><span class="line">        <span class="comment">// path.remove(path.size() - 1);</span></span><br><span class="line">        <span class="comment">// path.add(root.val);</span></span><br><span class="line">        backtrack(root.right, sum - root.val);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">填充每个节点的下一个右侧节点指针</a></p>
<p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">填充每个节点的下一个右侧节点指针 II</a></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;Node&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Node t = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(i == size - <span class="number">1</span>) &#123; <span class="comment">// 此处，不能用队列的size判断，因为下面还会添加Node</span></span><br><span class="line">                    t.next = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t.next = q.peekFirst();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>) q.offer(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>) q.offer(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">求根到叶子节点数字之和</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> path = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> sum;</span><br><span class="line">        backtrack(root);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        path = path * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) sum += path;</span><br><span class="line">        backtrack(root.left);</span><br><span class="line">        backtrack(root.right);</span><br><span class="line">        path = (path - root.val) / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">二叉搜索树迭代器</a></li>
</ol>
<ul>
<li>这一题要转换思路，题目看起来很麻烦，其实就是很简单的非递归中序遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        left(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">left</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> the next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode t = stack.pop();</span><br><span class="line">        left(t.right);</span><br><span class="line">        <span class="keyword">return</span> t.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.size() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>[实现 Trie (前缀树)](<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode temp = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            TrieNode node = temp.getSubNode(c);</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                temp.addSubNode(c, node);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = node;</span><br><span class="line">            <span class="keyword">if</span>(i == word.length() - <span class="number">1</span>)</span><br><span class="line">                temp.setEnd(<span class="keyword">true</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode temp = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">           TrieNode node = temp.getSubNode(word.charAt(i));</span><br><span class="line">           <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           temp = node;</span><br><span class="line">           <span class="keyword">if</span>(i == word.length() - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> temp.getEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode temp = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">           TrieNode node = temp.getSubNode(prefix.charAt(i));</span><br><span class="line">           <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           temp = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Character,TrieNode&gt; subNodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(Character key, TrieNode value)</span> </span>&#123;</span><br><span class="line">        subNodes.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TrieNode <span class="title">getSubNode</span><span class="params">(Character key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subNodes.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">(<span class="keyword">boolean</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5月9号"><a href="#5月9号" class="headerlink" title="5月9号"></a>5月9号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">二叉树的右视图</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size(); </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode t = q.poll();</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>) q.offer(t.left);</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>) q.offer(t.right);</span><br><span class="line">                <span class="keyword">if</span>(i == size - <span class="number">1</span>)</span><br><span class="line">                    res.add(t.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode t = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = t;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">二叉搜索树的最近公共祖先</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root == p || root == q || (p.val &lt; root.val &amp;&amp; q.val &gt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &lt; root.val)) <span class="keyword">return</span> root;</span><br><span class="line">            <span class="keyword">if</span>(p.val &gt; root.val &amp;&amp; q.val &gt; root.val) root = root.right;</span><br><span class="line">            <span class="keyword">else</span> root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a href="https://leetcode-cn.com/problems/binary-tree-paths/" target="_blank" rel="noopener">二叉树的所有路径</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backtrack(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            path.add(root.val + <span class="string">""</span>);</span><br><span class="line">            res.add(String.join(<span class="string">"-&gt;"</span>,path));</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(root.val + <span class="string">""</span>);</span><br><span class="line">        backtrack(root.left);</span><br><span class="line">        backtrack(root.right);</span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">二叉搜索树中第K小的元素</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span> || cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(++i == k)</span><br><span class="line">                <span class="keyword">return</span> cur.val;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">二叉树的序列化与反序列化</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        sb.append(root.val + <span class="string">","</span>);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode temp = queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(temp.left);</span><br><span class="line">                sb.append(temp.left.val + <span class="string">","</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">"null,"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(temp.right);</span><br><span class="line">                sb.append(temp.right.val + <span class="string">","</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(<span class="string">"null,"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">""</span>.equals(data)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] strs = data.split(<span class="string">","</span>);</span><br><span class="line">        TreeNode root = generateTreeNode(strs[<span class="number">0</span>]);</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode t = queue.poll();</span><br><span class="line">            t.left = generateTreeNode(strs[index++]);</span><br><span class="line">            <span class="keyword">if</span>(t.left != <span class="keyword">null</span>) queue.offer(t.left);</span><br><span class="line">            t.right = generateTreeNode(strs[index++]);</span><br><span class="line">            <span class="keyword">if</span>(t.right != <span class="keyword">null</span>) queue.offer(t.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">generateTreeNode</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"null"</span>.equals(str))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(Integer.parseInt(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a></li>
</ol>
<ul>
<li>动态规划的 转移方程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>], dp[i - <span class="number">1</span>]);</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">打家劫舍 II</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(get(Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>)), get(Arrays.copyOfRange(nums, <span class="number">1</span>, nums.length)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>], dp[i - <span class="number">1</span>]);</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍 III</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;TreeNode, Integer&gt; memo = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(memo.containsKey(root)) <span class="keyword">return</span> memo.get(root);</span><br><span class="line">        <span class="keyword">int</span> doIt = root.val + </span><br><span class="line">        (root.left == <span class="keyword">null</span> ? <span class="number">0</span> : rob(root.left.left) + rob(root.left.right)) +  </span><br><span class="line">        (root.right == <span class="keyword">null</span> ? <span class="number">0</span> : rob(root.right.left) + rob(root.right.right));</span><br><span class="line">        <span class="keyword">int</span> notDoIt = rob(root.left) + rob(root.right);</span><br><span class="line">        <span class="keyword">int</span> result = Math.max(doIt, notDoIt);</span><br><span class="line">        memo.put(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">买卖股票的最佳时机</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            res = Math.max(res, prices[i] - min);</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">买卖股票的最佳时机 II</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            res += prices[i] - prices[i - <span class="number">1</span>] &lt;= <span class="number">0</span> ? <span class="number">0</span> : prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">买卖股票的最佳时机 III</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">int</span>[] reverseDp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], prices[i] - min);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = prices[prices.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = prices.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            max = Math.max(max, prices[i]);</span><br><span class="line">            reverseDp[i] = Math.max(reverseDp[i + <span class="number">1</span>], max - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = dp[prices.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res = Math.max(res, dp[i] + reverseDp[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5月10号"><a href="#5月10号" class="headerlink" title="5月10号"></a>5月10号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">左叶子之和</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode t = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(t.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(t.left);</span><br><span class="line">                    <span class="keyword">if</span>(t.left.left == <span class="keyword">null</span> &amp;&amp; t.left.right == <span class="keyword">null</span>) count += t.left.val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(t.right != <span class="keyword">null</span>) queue.offer(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/path-sum-iii/" target="_blank" rel="noopener">路径总和 III</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum;</span><br><span class="line">        preOrder(root);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        backtrack(root);</span><br><span class="line">        preOrder(root.left);</span><br><span class="line">        preOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        sum -= root.val;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span>) count++;</span><br><span class="line">        backtrack(root.left);</span><br><span class="line">        backtrack(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst/" target="_blank" rel="noopener">序列化和反序列化二叉搜索树</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        preOrder(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.deleteCharAt(sb.length() - <span class="number">1</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        sb.append(root.val + <span class="string">","</span>);</span><br><span class="line">        preOrder(root.left, sb);</span><br><span class="line">        preOrder(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">""</span>.equals(data)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        String[] strs = data.split(<span class="string">","</span>);</span><br><span class="line">        <span class="keyword">return</span> rebuild(strs, <span class="number">0</span>, strs.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">rebuild</span><span class="params">(String[] strs, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(strs[low]));</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = low + <span class="number">1</span>; i &lt;= high; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Integer.parseInt(strs[i]) &gt; root.val)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = rebuild(strs, low + <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">        root.right = rebuild(strs, i, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noopener">先序遍历构造二叉搜索树</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstFromPreorder</span><span class="params">(<span class="keyword">int</span>[] preorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rebuild(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low &gt; high) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[low]);</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = low + <span class="number">1</span>; i &lt;= high; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[i] &gt; root.val)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left = rebuild(pre, low + <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">        root.right = rebuild(pre, i, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">N叉树的层序遍历</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        LinkedList&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Node t = queue.poll();</span><br><span class="line">                list.add(t.val);</span><br><span class="line">                <span class="keyword">for</span>(Node node : t.children)</span><br><span class="line">                    <span class="keyword">if</span>(node != <span class="keyword">null</span>)</span><br><span class="line">                        queue.offer(node);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/" target="_blank" rel="noopener">N叉树的前序遍历</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node cur = stack.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = cur.children.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span>(cur.children.get(i) != <span class="keyword">null</span>)</span><br><span class="line">                    stack.push(cur.children.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        help(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root.children.size(); i++) &#123;</span><br><span class="line">            help(root.children.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/" target="_blank" rel="noopener">N叉树的后序遍历</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        help(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root.children.size(); i++) &#123;</span><br><span class="line">            help(root.children.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorder</span><span class="params">(Node root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;Node&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node cur = stack.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            <span class="keyword">for</span>(Node node : cur.children) &#123;</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="keyword">null</span>)</span><br><span class="line">                    stack.push(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/" target="_blank" rel="noopener">根据前序和后序遍历构造二叉树</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//利用前序遍历来构建Tree，然后通过后续遍历来检验当前树是否构建完毕。</span></span><br><span class="line">    <span class="keyword">int</span> preIndex = <span class="number">0</span>, postIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">constructFromPrePost</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] post)</span> </span>&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[preIndex++]);</span><br><span class="line">        <span class="keyword">if</span>(post[postIndex] != root.val) root.left = constructFromPrePost(pre, post);</span><br><span class="line">        <span class="keyword">if</span>(post[postIndex] != root.val) root.right = constructFromPrePost(pre, post);</span><br><span class="line">        postIndex++;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">删除二叉搜索树中的节点</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归的一个非常重要的点就是：不去管函数的内部细节是如何处理的，我们只看其函数作用以及输入与输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数作用：删除搜索二叉树中的key对应的节点，并保证二叉搜索树的性质不变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输入：二叉搜索树的根节点root和一个值key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：新二叉搜索的根节点的引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//那么我们的前两步就可以直接表示为：</span></span><br><span class="line"><span class="comment">//root.left = deleteNode(root.left,key);</span></span><br><span class="line"><span class="comment">//root.right = deleteNode(root.right,key);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于第三步来说，有的小伙伴可能也会直接去套用，直接写成：</span></span><br><span class="line"><span class="comment">//root = deleteNode(root,key);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是这里的问题就是，deleteNode的作用就是删除二叉树的某个节点，都已经删除了，怎么又能把返回的对象再赋给他自己呢，所以对于第三步就不能这样简单的去调用了。需要自己实现</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deleteNode</span><span class="params">(TreeNode root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; key) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="keyword">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.right == <span class="keyword">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode node = root.right;</span><br><span class="line">                <span class="keyword">while</span>(node.left != <span class="keyword">null</span>) node = node.left;</span><br><span class="line">                node.left = root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5月11号"><a href="#5月11号" class="headerlink" title="5月11号"></a>5月11号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">课程表</a></li>
</ol>
<ul>
<li>问题转化能力，课表选课有选修课依赖关系，拓扑排序可以解决</li>
<li>拓扑排序的实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// indegree 记录所有课程的入度</span></span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 二维数组记录图的有向图邻接表</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacent = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)</span><br><span class="line">            adjacent.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] adj : prerequisites) &#123;</span><br><span class="line">            indegree[adj[<span class="number">0</span>]]++;</span><br><span class="line">            adjacent.get(adj[<span class="number">1</span>]).add(adj[<span class="number">0</span>]);<span class="comment">// 有向图</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 队列用来记录入度为 0 的节点，入度为 0 ，则可以出队列</span></span><br><span class="line">        LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">                queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> curOut = queue.poll();</span><br><span class="line">            numCourses--;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当前出队的节点，讲它所有的邻接边消去，同时更新入度为 0 的节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> curOutAdj : adjacent.get(curOut)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(--indegree[curOutAdj] == <span class="number">0</span>)</span><br><span class="line">                    queue.add(curOutAdj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">排序链表</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergesort(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode <span class="title">mergesort</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode midPre =  findMidPre(head);</span><br><span class="line">        ListNode mid = midPre.next;</span><br><span class="line">        midPre.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode left = mergesort(head);</span><br><span class="line">        ListNode right = mergesort(mid);</span><br><span class="line">        <span class="keyword">return</span> merge(left,right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode <span class="title">findMidPre</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head, fast = head, slowPre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slowPre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowPre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode <span class="title">merge</span><span class="params">(ListNode A, ListNode B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) <span class="keyword">return</span> A == <span class="keyword">null</span> ? B : A;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode p = newHead;</span><br><span class="line">        <span class="keyword">while</span>(A != <span class="keyword">null</span> &amp;&amp; B != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A.val &lt; B.val) &#123;</span><br><span class="line">                p.next = A;</span><br><span class="line">                p = p.next;</span><br><span class="line">                A = A.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p.next = B;</span><br><span class="line">                p = p.next;</span><br><span class="line">                B = B.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = A == <span class="keyword">null</span> ? B : A;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">合并K个排序链表</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode <span class="title">merge</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &gt; R) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(L &gt;= R) <span class="keyword">return</span> lists[L];</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        ListNode left = merge(lists, L, mid);</span><br><span class="line">        ListNode right = merge(lists, mid+<span class="number">1</span>, R); <span class="comment">// 归并的细节</span></span><br><span class="line">        <span class="keyword">return</span> mergeTwoList(left, right); <span class="comment">// 合并两个有序链表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/" target="_blank" rel="noopener">数组中的逆序对</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span>[] t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        t = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        mergesort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(L &gt;= R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        mergesort(nums, L, mid);</span><br><span class="line">        mergesort(nums, mid + <span class="number">1</span>, R);</span><br><span class="line">        merge(nums, L, mid, R);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> L, <span class="keyword">int</span> mid, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>, left = L, m = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= mid &amp;&amp; m &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left] &lt;= nums[m]) t[index++] = nums[left++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                t[index++] = nums[m++];</span><br><span class="line">                count += (mid - left + <span class="number">1</span>);	<span class="comment">// 终于想明白了，mid = (L + R) / 2,所以要 + 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= mid) t[index++] = nums[left++];</span><br><span class="line">        <span class="keyword">while</span>(m &lt;= R) t[index++] = nums[m++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L; i &lt;= R; i++) &#123;</span><br><span class="line">            nums[i] = t[i - L];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><a href="https://leetcode-cn.com/problems/restore-ip-addresses/" target="_blank" rel="noopener">复原IP地址</a></li>
</ol>
<ul>
<li>每次回溯，路径上记录的是一个segment，需要对 segment 进行检查是否符合 ip 地址的格式</li>
<li>当 路径上有 4个 segment 就要return，如果此时 len 到了 string 的 length，则是所求结果，add进</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; cur = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        backtrack(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String s, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size() == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(len == s.length())</span><br><span class="line">                res.add(String.join(<span class="string">"."</span>, cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(len + i &gt; s.length()) <span class="keyword">return</span>;</span><br><span class="line">            String seg = s.substring(len, len + i);</span><br><span class="line">            <span class="keyword">if</span>((i &gt; <span class="number">1</span> &amp;&amp; seg.startsWith(<span class="string">"0"</span>)) || (i == <span class="number">3</span> &amp;&amp; Integer.parseInt(seg) &gt; <span class="number">255</span>)) <span class="keyword">return</span>;</span><br><span class="line">            cur.add(seg);</span><br><span class="line">            backtrack(s, len + i);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5月12号"><a href="#5月12号" class="headerlink" title="5月12号"></a>5月12号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">跳跃游戏</a></li>
</ol>
<ul>
<li>如果一个位置能够到达，那么这个位置左侧所有位置都能到达。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxDistance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; maxDistance) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            maxDistance = Math.max(maxDistance, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">字母异位词分组</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String str : strs) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line">            Arrays.sort(c);</span><br><span class="line">            String key = String.valueOf(c);</span><br><span class="line">            <span class="keyword">if</span>(!m.containsKey(key))m.put(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            m.get(key).add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(m.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(String str : strs) &#123;</span><br><span class="line">            Arrays.fill(count, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ch : chars) count[ch - <span class="string">'a'</span>]++;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c : count) sb.append(<span class="string">"."</span> + c);</span><br><span class="line">            String key = sb.toString();</span><br><span class="line">            <span class="keyword">if</span>(!m.containsKey(key))m.put(key, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            m.get(key).add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(m.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/word-search/" target="_blank" rel="noopener">单词搜索</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] v;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        v = <span class="keyword">new</span> <span class="keyword">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; board.length; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; board[row].length; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, row, col, board.length, board[<span class="number">0</span>].length, <span class="number">0</span>, word)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> len, String target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[row][col] || len &gt; target.length() || board[row][col] != target.charAt(len)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == target.length() - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        v[row][col] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(row &gt; <span class="number">0</span> &amp;&amp; dfs(board, row - <span class="number">1</span>, col, rows, cols, len + <span class="number">1</span>, target)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(row &lt; rows - <span class="number">1</span> &amp;&amp; dfs(board, row + <span class="number">1</span>, col, rows, cols, len + <span class="number">1</span>, target)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(col &gt; <span class="number">0</span> &amp;&amp; dfs(board, row, col - <span class="number">1</span>, rows, cols, len + <span class="number">1</span>, target)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(col &lt; cols - <span class="number">1</span> &amp;&amp; dfs(board, row, col + <span class="number">1</span>, rows, cols, len + <span class="number">1</span>, target)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        v[row][col] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a href="https://leetcode-cn.com/problems/merge-intervals/" target="_blank" rel="noopener">合并区间</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        Arrays.sort(intervals, (v1, v2) -&gt; v1[<span class="number">0</span>] - v2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index == -<span class="number">1</span> || interval[<span class="number">0</span>] &gt; res[index][<span class="number">1</span>])</span><br><span class="line">                res[++index] = interval;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res[index][<span class="number">1</span>] = Math.max(res[index][<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank" rel="noopener">颜色分类</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>, p2 = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur &lt;= p2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[cur] == <span class="number">0</span>) swap(nums, p0++, cur++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[cur] == <span class="number">2</span>) swap(nums, p2--, cur);</span><br><span class="line">            <span class="keyword">else</span> cur++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public void sortColors(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     int count0 = 0;</span></span><br><span class="line">    <span class="comment">//     int count1 = 0;</span></span><br><span class="line">    <span class="comment">//     for(int num : nums)</span></span><br><span class="line">    <span class="comment">//         if(num == 0) count0++;</span></span><br><span class="line">    <span class="comment">//         else if(num == 1) count1++;</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length; i++) &#123;</span></span><br><span class="line">    <span class="comment">//         if(i &lt; count0) nums[i] = 0;</span></span><br><span class="line">    <span class="comment">//         else if(i &gt;= count0 &amp;&amp; i &lt; count0 + count1) nums[i] = 1;</span></span><br><span class="line">    <span class="comment">//         else nums[i] = 2;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">子集</a></li>
</ol>
<ul>
<li>位运算解法，通过pow(2, n) 次运算，达到所有的子集。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; nums.length); i++) &#123;</span><br><span class="line">            </span><br><span class="line">            List&lt;Integer&gt; sub = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(((i &gt;&gt; j) &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">                    sub.add(nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res.add(sub);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>回溯法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   List&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       backtrack(nums, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">       res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &lt; nums.length; i++) &#123;</span><br><span class="line">           path.add(nums[i]);</span><br><span class="line">           backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">           path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>无序数组的中位数</li>
</ol>
<ul>
<li>快速排序的partition, 每次判断返回的index是否等于mid</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = random.nextInt(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( i != mid) &#123;</span><br><span class="line">            i = partition(a,left,right);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; mid) left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; mid) right = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(a));</span><br><span class="line">        System.out.println(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[L];</span><br><span class="line">        <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[R] &gt;= pivot) R--;</span><br><span class="line">            nums[L] = nums[R];</span><br><span class="line">            <span class="keyword">while</span> (L &lt; R &amp;&amp; nums[L] &lt;= pivot) L++;</span><br><span class="line">            nums[R] = nums[L];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[L] = pivot;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="5月13号"><a href="#5月13号" class="headerlink" title="5月13号"></a>5月13号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">单词拆分</a></li>
</ol>
<ul>
<li>第一想法是用字典树解决问题，但是测试用例不能全过</li>
</ul>
<blockquote>
<p>输入：</p>
<p>“aaaaaaa”<br>[“aaaa”,”aaa”]</p>
<p>输出： fasle</p>
<p>预期结果：true</p>
</blockquote>
<ul>
<li>上面的主要原因在于，每次字典树遍历到aaa 的时候就会重新从根节点开始查找，aaa aaa a所以最后 遍历指针不是root 节点，所以输出为false</li>
</ul>
<blockquote>
<p>输入：</p>
<p>“aaaaaaa”<br>[“aaaa”,”aa”]</p>
<p>输出：true</p>
<p>预期：false</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> end;</span><br><span class="line">        <span class="keyword">private</span> Map&lt;Character, TrieNode&gt; subNodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(Character key, TrieNode node)</span> </span>&#123;</span><br><span class="line">            subNodes.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">TrieNode <span class="title">getSubNode</span><span class="params">(Character key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> subNodes.get(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setKeyWordEnd</span><span class="params">(<span class="keyword">boolean</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">isKeyWordEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWords</span><span class="params">(String lineText)</span> </span>&#123;<span class="comment">// 构造前缀树</span></span><br><span class="line">        TrieNode tempNode = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lineText.length(); i++) &#123;</span><br><span class="line">            Character c = lineText.charAt(i);</span><br><span class="line">            TrieNode node = tempNode.getSubNode(c);</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                tempNode.addSubNode(c, node);</span><br><span class="line">            &#125;</span><br><span class="line">            tempNode = node;</span><br><span class="line">            <span class="keyword">if</span> (i == lineText.length() - <span class="number">1</span>)</span><br><span class="line">                tempNode.setKeyWordEnd(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(String str : wordDict)</span><br><span class="line">            addWords(str);</span><br><span class="line">        <span class="keyword">return</span> filter(s); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">        TrieNode temp = root;</span><br><span class="line">        <span class="keyword">while</span>(position &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(position);</span><br><span class="line">            temp = temp.getSubNode(c);</span><br><span class="line">            <span class="keyword">if</span>(temp == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp.end) temp = root;</span><br><span class="line">            position++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> position == len &amp;&amp; temp == root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>针对上面的问题，问题出在 filter 函数上，解决方案是用一个数组记忆字符串上每个位置的查找情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (memo[left] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[left] &gt; <span class="number">0</span>;<span class="comment">// 递归返回</span></span><br><span class="line">        <span class="keyword">int</span> position = left;</span><br><span class="line">        TrieNode temp = root;</span><br><span class="line">        <span class="keyword">while</span> (position &lt; right) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(position);</span><br><span class="line">            temp = temp.getSubNode(c);</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp.end &amp;&amp; filter(s, position + <span class="number">1</span>, right)) &#123;</span><br><span class="line">                memo[left] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            position++;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[left] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另外一种思路，动态规划</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// dp[i] 代表字符串s的前i个字符能否拆分成wordDict</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(wordDict);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; set.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="noopener">跳跃游戏</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxDistance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; maxDistance) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            maxDistance = Math.max(maxDistance, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子数组</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>], maxDp = nums[<span class="number">0</span>], minDp = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = maxDp;</span><br><span class="line">            maxDp = max(nums[i], maxDp * nums[i], minDp * nums[i]);</span><br><span class="line">            minDp = min(nums[i], minDp * nums[i], t * nums[i]);</span><br><span class="line">            res = Math.max(maxDp, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.max(a, b), c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(a, b), c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener"> 最短无序连续子数组</a></li>
</ol>
<ul>
<li>不仅仅需要找到乱序的数组，并且要检查乱序数组两侧的数值，有没有在此乱序数组的值之间的数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] &lt;= nums[l + <span class="number">1</span>]) l++;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] &gt;= nums[r - <span class="number">1</span>]) r--;</span><br><span class="line">        <span class="keyword">if</span>(l == r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">            min = Math.min(nums[i], min);</span><br><span class="line">            max = Math.max(nums[i], max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= l; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; min)&#123;</span><br><span class="line">                l = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= r; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; max) &#123;</span><br><span class="line">                r = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/" target="_blank" rel="noopener">构建乘积数组</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        left[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        right[len - <span class="number">1</span>] = nums[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] * nums[i];</span><br><span class="line">            right[len - i - <span class="number">1</span>] = right[len - i] * nums[len - i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        res[<span class="number">0</span>] = right[<span class="number">1</span>];</span><br><span class="line">        res[len - <span class="number">1</span>] = left[len - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res[i] = left[i - <span class="number">1</span>] * right[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5月14号"><a href="#5月14号" class="headerlink" title="5月14号"></a>5月14号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">相交链表</a></li>
</ol>
<p><img src="https://github.com/Wayne-98/image/blob/master/Algorithms/May/%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png?raw=true" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        ListNode a = headA, b = headB;</span><br><span class="line">        <span class="keyword">while</span>(a != b) &#123;</span><br><span class="line">            a = (a != <span class="keyword">null</span>) ? a.next : headB;</span><br><span class="line">            b = (b != <span class="keyword">null</span>) ? b.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的解法是错误的，因为每次遍历到空的时候，应该回到另一个链表的表头，而不是运动着的headB;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class Solution&#123;</span></span><br><span class="line"><span class="comment">    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;</span></span><br><span class="line"><span class="comment">    	while(headA != headB) &#123;</span></span><br><span class="line"><span class="comment">            headA = (headA != null) ? headA.next : headB;</span></span><br><span class="line"><span class="comment">            headB = (headB != null) ? headB.next : headA;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return headA;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素</a></li>
</ol>
<ul>
<li>打仗的思想，我方先上一个人，对方来就干掉一个人，最后活下来的那个人就是超过半数的。当然有可能有趁机最后溜上去的，题目说明一定会有半数的，所以没有检查。如果出现没有半数的这种情况，最后检查一下就okk</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == res) count++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(--count == <span class="number">0</span>) &#123;</span><br><span class="line">                    res = nums[i];</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/majority-element-ii/" target="_blank" rel="noopener">求众数 II</a></li>
</ol>
<ul>
<li>上一题的升级版，用投票想法来解决问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> candidate1 = nums[<span class="number">0</span>], count1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> candidate2 = nums[<span class="number">0</span>], count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num == candidate1) &#123;</span><br><span class="line">                count1++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num == candidate2) &#123;</span><br><span class="line">                count2++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 既不等于候选人1，也不等于候选人2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 此刻如果候选人1已经是0了，那么就让当前值做候选人1</span></span><br><span class="line">            <span class="keyword">if</span>(count1 == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate1 = num;</span><br><span class="line">                count1 = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果此刻候选人1不为零，候选人2为零，那么就让当前值做候选人2</span></span><br><span class="line">            <span class="keyword">if</span>(count2 == <span class="number">0</span>) &#123;</span><br><span class="line">                candidate2 = num;</span><br><span class="line">                count2 = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果此刻候选人１,２　都不为０，那么都让他们--;</span></span><br><span class="line">            count1--;count2--;</span><br><span class="line">        &#125;</span><br><span class="line">        count1 = <span class="number">0</span>;</span><br><span class="line">        count2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num == candidate1) count1++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num == candidate2) count2++;<span class="comment">// else if : 如果两个candidate的值相同，不是else if 会导致结果重复。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count1 &gt; nums.length / <span class="number">3</span>) res.add(candidate1);</span><br><span class="line">        <span class="keyword">if</span>(count2 &gt; nums.length / <span class="number">3</span>) res.add(candidate2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">只出现一次的数字</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> all = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">            all ^= num;</span><br><span class="line">        <span class="keyword">return</span> all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第K个最大元素</a></li>
</ol>
<ul>
<li>思路1，用一个最小堆遍历一遍数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k &gt; nums.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;((o1, o2) -&gt; o2 - o1);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认是最小堆</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) minHeap.offer(nums[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; minHeap.peek()) &#123;</span><br><span class="line">            minHeap.poll();</span><br><span class="line">            minHeap.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// while(minHeap.size() != 1) minHeap.poll();</span></span><br><span class="line">    <span class="keyword">return</span> minHeap.peek();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>思路2，快排partition，定位置为 nums.length - k</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k &gt; nums.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index != nums.length - k) &#123;</span><br><span class="line">            index = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span>(index &gt; nums.length - k) right = index - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index &lt; nums.length - k) left = index + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = left, R = right;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[L];</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">while</span>(L &lt; R &amp;&amp; nums[R] &gt;= pivot) R--;</span><br><span class="line">            nums[L] = nums[R];</span><br><span class="line">            <span class="keyword">while</span>(L &lt; R &amp;&amp; nums[L] &lt;= pivot) L++;</span><br><span class="line">            nums[R] = nums[L];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[L] = pivot;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>手写个最小堆来</p>
</li>
<li><p>用文本编辑器，手写一个最小堆一次 AC 的感觉真开心啊 O(∩_∩)O~~</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k &gt; nums.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] minHeap = <span class="keyword">new</span> <span class="keyword">int</span>[k+<span class="number">1</span>];<span class="comment">// 0处为哨兵，让代码更简洁</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) minHeap[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">    buildMinHeap(minHeap);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; minHeap[<span class="number">1</span>]) &#123;</span><br><span class="line">            minHeap[<span class="number">1</span>] = nums[i];</span><br><span class="line">            adjustDown(minHeap, <span class="number">1</span>, minHeap.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minHeap[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMinHeap</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">        adjustDown(nums, i, nums.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    nums[<span class="number">0</span>] = nums[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = k * <span class="number">2</span>; i &lt; len; i *= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; len - <span class="number">1</span> &amp;&amp; nums[i + <span class="number">1</span>] &lt; nums[i]) i++;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= nums[<span class="number">0</span>]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[k] = nums[i];</span><br><span class="line">            k = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[k] = nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">回文子串</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            expand(s, i, i);</span><br><span class="line">            expand(s, i, i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">最长回文子序列</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expand(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expand(s, i, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(len &gt; (right - left)) &#123;</span><br><span class="line">                left = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                right = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">岛屿数量</a></li>
</ol>
<ul>
<li>仔细审题，这只是一道简单的 DFS BFS 题目</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] v;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        v = <span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!v[i][j] &amp;&amp; grid[i][j] != <span class="string">'0'</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row &lt; <span class="number">0</span> || row == grid.length || col &lt; <span class="number">0</span> || col == grid[<span class="number">0</span>].length || v[row][col] || grid[row][col] == <span class="string">'0'</span>) <span class="keyword">return</span>;</span><br><span class="line">        v[row][col] = <span class="keyword">true</span>;</span><br><span class="line">        dfs(grid, row - <span class="number">1</span>, col);</span><br><span class="line">        dfs(grid, row + <span class="number">1</span>, col);</span><br><span class="line">        dfs(grid, row, col - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, row, col + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>以下是 BFS 解法，要注意每次入队的时候，要讲此节点标记为已访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] v;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        v = <span class="keyword">new</span> <span class="keyword">boolean</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; grid.length; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; grid[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!v[row][col] &amp;&amp; grid[row][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    LinkedList&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                    q.offer(row);</span><br><span class="line">                    q.offer(col);</span><br><span class="line">                    v[row][col] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">while</span>(q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> currow = q.poll();</span><br><span class="line">                        <span class="keyword">int</span> curcol = q.poll();</span><br><span class="line">                        <span class="keyword">if</span>(check(grid, currow - <span class="number">1</span>, curcol)) &#123;</span><br><span class="line">                            q.offer(currow - <span class="number">1</span>);</span><br><span class="line">                            q.offer(curcol);</span><br><span class="line">                            v[currow - <span class="number">1</span>][curcol] = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(check(grid, currow + <span class="number">1</span>, curcol)) &#123;</span><br><span class="line">                            q.offer(currow + <span class="number">1</span>);</span><br><span class="line">                            q.offer(curcol);</span><br><span class="line">                            v[currow + <span class="number">1</span>][curcol] = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(check(grid, currow, curcol - <span class="number">1</span>)) &#123;</span><br><span class="line">                            q.offer(currow);</span><br><span class="line">                            q.offer(curcol - <span class="number">1</span>);</span><br><span class="line">                            v[currow][curcol - <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(check(grid, currow, curcol + <span class="number">1</span>)) &#123;</span><br><span class="line">                            q.offer(currow);</span><br><span class="line">                            q.offer(curcol + <span class="number">1</span>);</span><br><span class="line">                            v[currow][curcol + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row &lt; <span class="number">0</span> || row == grid.length || col &lt; <span class="number">0</span> || col == grid[<span class="number">0</span>].length || v[row][col] || grid[row][col] == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5月15号"><a href="#5月15号" class="headerlink" title="5月15号"></a>5月15号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">和为K的子数组</a></li>
</ol>
<ul>
<li>暴力遍历解法，对于每个子数组都判断一次是否和为k</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum == k) count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>引入前缀和数组概念</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span>[] prefixSum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">       prefixSum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">           prefixSum[i + <span class="number">1</span>] = prefixSum[i] + nums[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; nums.length; j++) &#123;</span><br><span class="line">               <span class="keyword">if</span>(prefixSum[j + <span class="number">1</span>] - prefixSum[i] == k)</span><br><span class="line">                   count++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>HashMap 优化前缀和数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// key 保存的是前缀和的值</span></span><br><span class="line">        <span class="comment">// val 保存的是前缀和的出现的次数</span></span><br><span class="line">        m.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prefixSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            prefixSum += num;</span><br><span class="line">            <span class="keyword">if</span>(m.containsKey(prefixSum - k)) count += m.get(prefixSum - k);</span><br><span class="line">            <span class="keyword">if</span>(m.containsKey(prefixSum)) &#123;</span><br><span class="line">                <span class="keyword">int</span> val = m.get(prefixSum);</span><br><span class="line">                m.put(prefixSum, val+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                m.put(prefixSum, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = t;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public void moveZeroes(int[] nums) &#123;</span></span><br><span class="line">    <span class="comment">//     int indexOfNotZero = 0;</span></span><br><span class="line">    <span class="comment">//     for(int i = 0; i &lt; nums.length; i++)</span></span><br><span class="line">    <span class="comment">//         if(nums[i] != 0)</span></span><br><span class="line">    <span class="comment">//             nums[indexOfNotZero++] = nums[i];</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     for(int i = indexOfNotZero; i &lt; nums.length; i++)</span></span><br><span class="line">    <span class="comment">//         nums[i] = 0;</span></span><br><span class="line">    <span class="comment">//     return;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/maximal-square/" target="_blank" rel="noopener">最大正方形</a></li>
</ol>
<p><img src="https://pic.leetcode-cn.com/8c4bf78cf6396c40291e40c25d34ef56bd524313c2aa863f3a20c1f004f32ab0-image.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length + <span class="number">1</span>][matrix[<span class="number">0</span>].length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; matrix.length; row++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; matrix[<span class="number">0</span>].length; col++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[row][col] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    dp[row+<span class="number">1</span>][col+<span class="number">1</span>] = Math.min(Math.min(dp[row][col], dp[row+<span class="number">1</span>][col]),dp[row][col+<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max, dp[row+<span class="number">1</span>][col+<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max * max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>dp(i + 1, j + 1) 表示的是 以matr(i, j) 为右下角的最大正方形的边长</li>
<li>这个最大正方形的边长受到其上，左，左上的最大正方形边长的限制</li>
</ul>
<ol start="4">
<li><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++)</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5月16号"><a href="#5月16号" class="headerlink" title="5月16号"></a>5月16号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">K 个一组翻转链表</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        </span><br><span class="line">        ListNode pre = newHead, end = newHead;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(end != <span class="keyword">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k &amp;&amp; end != <span class="keyword">null</span>; i++) end = end.next;</span><br><span class="line">            <span class="keyword">if</span>(end == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            ListNode start = pre.next;<span class="comment">//待翻转子链表的头结点</span></span><br><span class="line">            ListNode next = end.next;<span class="comment">//保存下一个带翻转链表</span></span><br><span class="line">            </span><br><span class="line">            end.next = <span class="keyword">null</span>;</span><br><span class="line">            pre.next = reverseList(start);</span><br><span class="line">            </span><br><span class="line">            start.next = next;<span class="comment">//翻转后，start是最后一个节点，将已翻转的链接和待翻转的链接接上</span></span><br><span class="line">            </span><br><span class="line">            pre = start; <span class="comment">// 更新pre 和 end</span></span><br><span class="line">            end = start; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode p = head, r = p.next;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            r = p.next;</span><br><span class="line">            p.next = newHead.next;</span><br><span class="line">            newHead.next = p;</span><br><span class="line">            p = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">除自身以外数组的乘积</a></li>
</ol>
<ul>
<li>我的解法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        left[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        right[len - <span class="number">1</span>] = nums[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] * nums[i];</span><br><span class="line">            right[len - i - <span class="number">1</span>] = right[len - i] * nums[len - i - <span class="number">1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        res[<span class="number">0</span>] = right[<span class="number">1</span>];</span><br><span class="line">        res[len - <span class="number">1</span>] = left[len - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res[i] = left[i - <span class="number">1</span>] * right[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>大佬的解法，十分巧妙</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            res[i] = k;</span><br><span class="line">            k *= nums[i];<span class="comment">// 此时数组存储的是除去当前元素左边的元素乘积</span></span><br><span class="line">        &#125;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] *= k;</span><br><span class="line">            k *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/" target="_blank" rel="noopener">1～n整数中1出现的次数</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        String s = String.valueOf(n);</span><br><span class="line">        <span class="keyword">int</span> high = s.charAt(<span class="number">0</span>) - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> pow = (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,s.length()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> last = n - high * pow;</span><br><span class="line">        <span class="comment">// 例如 1234 -&gt; 1 ~ 999 1000 ~ 1234</span></span><br><span class="line">        <span class="comment">// f(pow - 1) 999中出现1的个数</span></span><br><span class="line">        <span class="comment">// last + 1 千分位为1的个数</span></span><br><span class="line">        <span class="comment">// f(last) 234中出现1的个数</span></span><br><span class="line">        <span class="keyword">if</span>(high==<span class="number">1</span>) <span class="keyword">return</span> f(pow - <span class="number">1</span>) + f(last) + last + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 例如3234 -&gt; 1 ~ 999 1000 ~ 1999 2000 ~ 2999 3000 ~ 3234</span></span><br><span class="line">        <span class="comment">// 1 ~ 999 f(pow - 1)</span></span><br><span class="line">        <span class="comment">// 1000 ~ 1999 f(pow - 1) + pow</span></span><br><span class="line">        <span class="comment">// 2000 ~ 2000 f(pow - 1)</span></span><br><span class="line">        <span class="comment">// 3000 ~ 3234 f(last)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> high * f(pow - <span class="number">1</span>) + f(last) + pow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列</a></li>
</ol>
<ul>
<li><p>DP 问题</p>
</li>
<li><p><strong>状态定义：</strong>由于一个子序列一定会以一个数进行结尾，所以我们定义<code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的<strong>上升子序列</strong></p>
</li>
<li><p><strong>状态转移：</strong></p>
<ol>
<li>遍历到<code>nums[i]</code>的时候，需要扫描 <code>i</code> 之前的所有的<code>nums</code>值</li>
<li>只要 <code>nums[i]</code> 严格大于在它位置之前的某个数，那么 <code>nums[i]</code> 就可以接在这个数后面形成一个更长的上升子序列；</li>
<li>因此，<code>dp[i]</code> 就等于下标 <code>i</code> 之前<strong>严格</strong>小于 <code>nums[i]</code> 的状态值的最大者 +1。</li>
</ol>
</li>
<li><p><strong>初始状态：</strong>每个数字都可以看做一个上升子序列，所以<code>dp</code>数组初始值全部赋值为1</p>
</li>
<li><p><strong>考虑输出：</strong>需要的是全局的最长子序列，所以是dp数组的最大值。</p>
</li>
<li><p><strong>考虑状态压缩：</strong>遍历到一个新数的时候，之前所有的状态值都得保留，因此无法压缩。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>另一种解法</li>
<li><strong>状态定义：</strong> <code>tail[i]</code> 定义的是长度为 <code>i+1</code> 的最长上升子序列的结尾的最小值</li>
<li><strong>状态转移：</strong><ol>
<li>在遍历数组 <code>nums</code> 的过程中，每来一个新数 <code>num</code>，如果这个数<strong>严格</strong>大于有序数组 <code>tail</code> 的最后一个元素，就把 <code>num</code> 放在有序数组 <code>tail</code> 的后面</li>
<li>否则，在有序数组 <code>tail</code> 中查找第 1 个等于大于 <code>num</code> 的那个数，试图让它变小；</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>初始状态：</strong><code>dp[0] = nums[0]</code>，在只有 1 个元素的情况下，它当然是长度为 1 并且结尾最小的元素。</p>
</li>
<li><p><strong>考虑输出：</strong><code>tail</code>数组的长度</p>
</li>
<li><p><strong>考虑状态压缩：</strong>无法压缩。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] tail = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// tail[i] 定义的是长度为 i+1 的最长上升子序列的最小值</span></span><br><span class="line">        tail[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; tail[res-<span class="number">1</span>]) tail[res++] = nums[i];</span><br><span class="line">            <span class="comment">// 0~res 中找到第一个比 nums[i] 大于等于的数字</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = find(tail, <span class="number">0</span>, res, nums[i]);</span><br><span class="line">                tail[index] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) r = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">最大子序和</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp 数组 dp[i] 定义为遍历到当前 num 时子数组的最大值，那么最后的结果就是 dp 数组的最大值</span></span><br><span class="line">        <span class="comment">// 如果dp[i-1] 小于等于0 那我放弃前面的重新开始，否则加上前面的</span></span><br><span class="line">        <span class="comment">// 初始化dp[0] = nums[0];</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = (dp[i - <span class="number">1</span>] &lt;= <span class="number">0</span>) ? nums[i] : (dp[i - <span class="number">1</span>] + nums[i]);</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            pre = pre &lt;= <span class="number">0</span> ? nums[i] : nums[i] + pre;</span><br><span class="line">            res = Math.max(res, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">寻找重复数</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i] != (i + <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] == nums[nums[i] - <span class="number">1</span>]) <span class="keyword">return</span> nums[i];</span><br><span class="line">                swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">// 不符合题意，因为题目说明原数组是只读的</span></span><br></pre></td></tr></table></figure>

<ul>
<li>用二分法定位在一个区间里的整数(抽屉原理)</li>
<li>抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">1</span>, R = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= mid)</span><br><span class="line">                    count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 小于等于 4 的个数 如果严格大于 4</span></span><br><span class="line">            <span class="comment">// 此时重复元素一定在[1, 4]之间</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; mid) R = mid;</span><br><span class="line">            <span class="keyword">else</span> L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">缺失的第一个正数</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// i 和 nums[i] - 1</span></span><br><span class="line">            <span class="comment">//满足在指定范围内、并且没有放在正确的位置上，才交换</span></span><br><span class="line">            <span class="keyword">while</span>(nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= nums.length &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>])&#123;</span><br><span class="line">                swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != (i+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5月17号"><a href="#5月17号" class="headerlink" title="5月17号"></a>5月17号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">零钱兑换</a></li>
</ol>
<ul>
<li>动态规划问题</li>
<li><strong>状态定义：</strong> <code>dp[i]</code> 表示用硬币凑出金额 i 最少的硬币个数, 那么结果就是 <code>dp[amount]</code></li>
<li><strong>状态转移：</strong><ol>
<li>遍历所有 <code>coin</code>，<code>dp[i] = min(dp[i], 1 + dp[i - coin])</code>, 如果  <code>i - coin &lt; 0</code>， continue，最后检查一下数组中 dp[amout] 是否等于 amout+1 就可以</li>
</ol>
</li>
</ul>
<ul>
<li><strong>初始状态：</strong><code>Arrays.fill(dp, amount+1)</code>表示初始化为每个状态正无穷，方便更新状态。<code>dp[0] = 0</code></li>
<li><strong>考虑输出：</strong>``dp[amount]`</li>
<li><strong>考虑状态压缩：</strong>无法压缩。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i - coin &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            dp[i] = Math.min(dp[i], <span class="number">1</span> + dp[i - coin]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/counting-bits/" target="_blank" rel="noopener">比特位计数</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= num; i++)</span><br><span class="line">            res[i] = numOfBit(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numOfBit</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[num + <span class="number">1</span>];</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">            <span class="comment">// 奇数, i 是在 i - 1 的二进制数上加了个 1。</span></span><br><span class="line">            <span class="comment">// 偶数, i 是 i / 2 左移一位得到的。</span></span><br><span class="line">            res[i] = ((i &amp; <span class="number">1</span>) == <span class="number">0</span>) ? res[i &gt;&gt; <span class="number">1</span>] : res[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">前 K 个高频元素</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(m.containsKey(num)) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = m.get(num);</span><br><span class="line">                m.put(num, t+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                m.put(num, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最小堆是按照堆中数字出现的频率排序的</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; m.get(a) - m.get(b));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : m.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(minHeap.size() &lt; k) minHeap.offer(num);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m.get(num) &gt; m.get(minHeap.peek())) &#123; <span class="comment">// 如果该数字的频率，比最小堆中最小的数字频率要大</span></span><br><span class="line">                    minHeap.poll();</span><br><span class="line">                    minHeap.offer(num);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) res[i] = minHeap.poll();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>桶排序的方案，bucket是数字出现的次数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(m.containsKey(num)) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = m.get(num);</span><br><span class="line">                m.put(num, t+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                m.put(num, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt;[] bucket = <span class="keyword">new</span> List[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : m.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[m.get(num)] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                bucket[m.get(num)] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            bucket[m.get(num)].add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length; i &gt;=<span class="number">0</span> &amp;&amp; index &lt; k; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bucket[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> num : bucket[i]) res[index++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>复习4月11号内容</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">连续子数组的最大和</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            pre = pre &gt;= <span class="number">0</span> ? nums[i] + pre : nums[i];</span><br><span class="line">            res = Math.max(pre, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/" target="_blank" rel="noopener">连续子数组的最大和</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode newHead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode p = newHead;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = (l1.val + l2.val + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (l1.val + l2.val + carry) / <span class="number">10</span>;</span><br><span class="line">            p.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            p = p.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = (l1.val + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (l1.val + carry) / <span class="number">10</span>;</span><br><span class="line">            p.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            p = p.next;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> val = (l2.val + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (l2.val + carry) / <span class="number">10</span>;</span><br><span class="line">            p.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            p = p.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) &#123;</span><br><span class="line">            p.next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">无重复字符的最长子串</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        m.put(s.charAt(<span class="number">0</span>), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line">            <span class="keyword">if</span>(m.containsKey(c)) left = Math.max(left, m.get(c));</span><br><span class="line">            m.put(c, right + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">            res = Math.max(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复习4月12号内容</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">在排序数组中查找元素的第一个和最后一个位置</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = findLeft(nums,target);</span><br><span class="line">        <span class="keyword">int</span> right = findRight(nums,target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLeft</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L == nums.length || nums[L] != target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRight</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) L = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) R = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(R == -<span class="number">1</span> || nums[R] != target) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">寻找两个正序数组的中位数</a><ul>
<li>不会写，有时间在写吧</li>
</ul>
</li>
<li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">最长回文子串</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> len1 = expand(s, i, i);</span><br><span class="line">            <span class="keyword">int</span> len2 = expand(s, i, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(len1, len2);</span><br><span class="line">            <span class="keyword">if</span>(len &gt; (right - left)) &#123;</span><br><span class="line">                left = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                right = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expand</span><span class="params">(String s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt; s.length() &amp;&amp; s.charAt(l) == s.charAt(r))&#123;</span><br><span class="line">            l--;r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r - l - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复习4月13号内容</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">盛最多水的容器</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>, R = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">            res = Math.max(res, Math.min(height[L], height[R]) * (R - L));</span><br><span class="line">            <span class="keyword">if</span>(height[L] &lt; height[R]) L++;</span><br><span class="line">            <span class="keyword">else</span> R--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">三数之和</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">         List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         <span class="keyword">if</span>(nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">         Arrays.sort(nums);</span><br><span class="line">         <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(index &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[index] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">int</span> L = index + <span class="number">1</span>, R = nums.length - <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">while</span>(L &lt; R) &#123;</span><br><span class="line">                 <span class="keyword">if</span>(nums[index] + nums[L] + nums[R] == <span class="number">0</span>) &#123;</span><br><span class="line">                     res.add(Arrays.asList(nums[index], nums[L], nums[R]));</span><br><span class="line">                     <span class="keyword">while</span>(L &lt; R &amp;&amp; nums[L + <span class="number">1</span>] == nums[L]) L++;</span><br><span class="line">                     L++;</span><br><span class="line">                     <span class="keyword">while</span>(L &lt; R &amp;&amp; nums[R - <span class="number">1</span>] == nums[R]) R--;</span><br><span class="line">                     R--;</span><br><span class="line">                 &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[index] + nums[L] + nums[R] &lt; <span class="number">0</span>) L++;</span><br><span class="line">                 <span class="keyword">else</span> R--;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">while</span>(index &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[index + <span class="number">1</span>] == nums[index]) index++;</span><br><span class="line">             index++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">电话号码的字母组合</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    StringBuilder path = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    HashMap&lt;Character, <span class="keyword">char</span>[]&gt; m = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.length() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        m.put(<span class="string">'2'</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;);</span><br><span class="line">        m.put(<span class="string">'3'</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;);</span><br><span class="line">        m.put(<span class="string">'4'</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>&#125;);</span><br><span class="line">        m.put(<span class="string">'5'</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>&#125;);</span><br><span class="line">        m.put(<span class="string">'6'</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>&#125;);</span><br><span class="line">        m.put(<span class="string">'7'</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>&#125;);</span><br><span class="line">        m.put(<span class="string">'8'</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>&#125;);</span><br><span class="line">        m.put(<span class="string">'9'</span>, <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>&#125;);</span><br><span class="line">        backtrack(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String digits, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len == digits.length()) &#123;</span><br><span class="line">            res.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = m.get(digits.charAt(len));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            path.append(c);</span><br><span class="line">            backtrack(digits, len + <span class="number">1</span>);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复习4月14号内容</p>
</li>
</ul>
<h2 id="5月18号"><a href="#5月18号" class="headerlink" title="5月18号"></a>5月18号</h2><ol>
<li><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子数组</a></li>
</ol>
<ul>
<li>类似于和最大子数组的思路，但是每次需要考虑负数，所以多一个mindp来记录</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] maxDp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span>[] minDp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        maxDp[<span class="number">0</span>] = nums[<span class="number">0</span>]; minDp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = maxDp[i - <span class="number">1</span>];</span><br><span class="line">            maxDp[i] = max(maxDp[i - <span class="number">1</span>] * nums[i], minDp[i - <span class="number">1</span>] * nums[i], nums[i]);</span><br><span class="line">            minDp[i] = min(minDp[i - <span class="number">1</span>] * nums[i], nums[i], t * nums[i]);</span><br><span class="line">            res = Math.max(res, maxDp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(a, Math.max(b, c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><a href="https://leetcode-cn.com/problems/decode-string/" target="_blank" rel="noopener">字符串解码</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">decodeString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// sb 用来记录遍历中生成的结果,</span></span><br><span class="line">        <span class="comment">// 每次遇到 [ 就把 times 和 sb 的内容用栈保存</span></span><br><span class="line">        <span class="comment">// 遇到 ] times * sb 加上之前保存的 sb .</span></span><br><span class="line">        Deque&lt;Integer&gt; mutiStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        Deque&lt;String&gt; strStack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                num = num * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>) &#123;</span><br><span class="line">                mutiStack.push(num);</span><br><span class="line">                strStack.push(sb.toString());</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">']'</span>)&#123;</span><br><span class="line">                StringBuilder tempSb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">int</span> times = mutiStack.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; times; j++)</span><br><span class="line">                    tempSb.append(sb.toString());</span><br><span class="line">                sb = <span class="keyword">new</span> StringBuilder(strStack.pop() + tempSb.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">根据身高重建队列</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people, (o1, o2) -&gt; o1[<span class="number">0</span>] == o2[<span class="number">0</span>] ? o1[<span class="number">1</span>] - o2[<span class="number">1</span>] : o2[<span class="number">0</span>] - o1[<span class="number">0</span>]);</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 高个子先站好位，矮个子插入到K位置上，前面肯定有K个高个子，矮个子再插到前面也满足K的要求</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] t : people) res.add(t[<span class="number">1</span>], t);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><a href="https://leetcode-cn.com/problems/friend-circles/" target="_blank" rel="noopener">朋友圈</a></li>
</ol>
<ul>
<li>转化为无向图的连通分量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] v;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(M.length == <span class="number">0</span> || M[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        v = <span class="keyword">new</span> <span class="keyword">boolean</span>[M.length];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> node = <span class="number">0</span>; node &lt; M.length; node++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!v[node]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                v[node] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(M, node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(M[node][i] == <span class="number">1</span> &amp;&amp; !v[i]) &#123;</span><br><span class="line">                v[i] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(M, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">最长连续序列</a></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) set.add(num);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : set) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> curlen = <span class="number">1</span>, curnum = num;</span><br><span class="line">                <span class="keyword">while</span>(set.contains(curnum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    curnum++;</span><br><span class="line">                    curlen++;</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res, curlen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>复习4月15日内容</p>
<ol>
<li><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">至少有K个重复字符的最长子串</a><ul>
<li>从整个字符串的内容，逐渐缩小范围</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">char</span>[] c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.c = s.toCharArray();</span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(R - L + <span class="number">1</span> &lt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] times = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L; i &lt;= R; i++) times[c[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R &amp;&amp; times[c[L] - <span class="string">'a'</span>] &lt; k) L++;</span><br><span class="line">        <span class="keyword">while</span>(L &lt;= R &amp;&amp; times[c[R] - <span class="string">'a'</span>] &lt; k) R--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = L; i &lt;= R; i++)</span><br><span class="line">            <span class="keyword">if</span>(times[c[i] - <span class="string">'a'</span>] &lt; k)</span><br><span class="line">                <span class="keyword">return</span> Math.max(recur(L, i - <span class="number">1</span>), recur(i + <span class="number">1</span>, R));</span><br><span class="line">        <span class="keyword">return</span> R - L + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">最长公共前缀</a></p>
<ul>
<li>解法1，垂直遍历。时间复杂度是 O(N * minLen)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(String str : strs) minLen = Math.min(minLen, str.length());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minLen; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; strs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[j].charAt(i)!= c) <span class="keyword">return</span> strs[j].substring(<span class="number">0</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, minLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解法2，水平遍历，时间复杂度是O(S) S是所有字符串的长度之和</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String prefix = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(bit &lt; Math.min(prefix.length(), strs[i].length()) &amp;&amp; prefix.charAt(bit) == strs[i].charAt(bit)) bit++;</span><br><span class="line">            prefix = prefix.substring(<span class="number">0</span>, bit);</span><br><span class="line">            <span class="keyword">if</span>(prefix.equals(<span class="string">""</span>)) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://leetcode-cn.com/problems/permutation-in-string/" target="_blank" rel="noopener">字符串的排列</a></p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.length() &lt; s1.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] countOfs1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s1.toCharArray()) countOfs1[c - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s1.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; s2.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count(countOfs1, s2, left, right)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            right++; left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] countOfs1, String s2, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] countOfs2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++) countOfs2[s2.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(countOfs1[i] != countOfs2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每次都要重新计算一次 count2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length(), len2 = s2.length();</span><br><span class="line">        <span class="keyword">if</span>(len2 &lt; len1) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] count1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span>[] count2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            count1[s1.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            count2[s2.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len1; i &lt; len2; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sameCount(count1, count2)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            count2[s2.charAt(i - len1) - <span class="string">'a'</span>]--;</span><br><span class="line">            count2[s2.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sameCount(count1, count2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sameCount</span><span class="params">(<span class="keyword">int</span>[] count1, <span class="keyword">int</span>[] count2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) <span class="keyword">if</span>(count2[i] != count1[i]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理方法很巧妙，利用之前算过的，每次更新两遍的值就可以了</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<p>4. </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>自顶向下方法：链路层和局域网</title>
    <url>/2020/05/15/Internet/%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%EF%BC%9A%E9%93%BE%E8%B7%AF%E5%B1%82%E5%92%8C%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    <content><![CDATA[<h2 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h2><h3 id="链路层提供的服务"><a href="#链路层提供的服务" class="headerlink" title="链路层提供的服务"></a>链路层提供的服务</h3><ol>
<li>成帧</li>
<li>链路接入。媒体访问控制（Medium Access Control, MAC）协议规定了帧在链路上传输的规则。对于链路的一端仅有一个发送方、链路的另一端仅有一个接收方的点对点链路，MAC 协议比较简单，即无论何时链路空闲都可以发送帧。如果多个节点共享单个广播链路的时候，存在多路访问问题，MAC 协议用于协调多个节点的帧传输。</li>
<li>可靠交付。例如无线链路，其目的是本地纠正一个差错，而不是通过运输层或应用层协议迫使进行端到端的数据重传。</li>
<li>差错检测和纠正。</li>
</ol>
<h3 id="链路层在何处实现"><a href="#链路层在何处实现" class="headerlink" title="链路层在何处实现"></a>链路层在何处实现</h3><p>链路层的主体部分是在<strong>网络适配器中</strong>（network adapter）实现的，网络适配器有时也称为<strong>网络接口卡</strong>（Network Interface Card, NIC），位于网络适配器核心的是链路层控制器，控制器通常实现了许多链路层服务（成帧，链路接入，差错检测）。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>amanda减脂餐</title>
    <url>/2020/05/13/life/amanda%E5%87%8F%E8%84%82%E9%A4%90/</url>
    <content><![CDATA[<h1 id="amanda-减脂便当"><a href="#amanda-减脂便当" class="headerlink" title="amanda 减脂便当"></a><a href="https://www.bilibili.com/video/BV1EV411C7hu" target="_blank" rel="noopener">amanda 减脂便当</a></h1><p>火腿口蘑毛豆糙米饭（两餐量）：糙米、口蘑、火腿、姜末煮饭，结束十分钟前加毛豆仁。</p>
<p>虾仁奶汁炖菜（两餐量）：1、虾仁汆水捞出；2、黄油、橄榄油，下面粉炒到发黄，加脱脂牛奶，煮成奶酱。3、橄榄油、蒜蓉、大葱、胡萝卜、口蘑。加水炖煮，加魔芋结、山药，下奶酱，下虾仁、毛豆仁、加盐、黑胡椒。（4、加车打芝士。） </p>
<p>剁椒蒸银鳕鱼（一餐量）：1、银鳕鱼加盐、米酒腌制。2、放在大葱上，抹上姜末铺剁椒。香油，蒸熟。</p>
<p>茭白毛豆炒鸡丁（两餐量）：1、鸡胸肉切丁、加盐、白胡椒、米酒、蒜末、姜末、玉米淀粉；2、水沸后关火，下鸡胸肉丁。变色后捞出。3、炒蒜蓉、茭白、毛豆仁、魔芋块。生抽、耗油、糖，鸡胸肉回锅。</p>
<p>盐水鸭腿（两餐量）：1、鸭腿、盐、八角、香叶、花椒、小茴香腌制；2、鸭腿下锅煮熟，加葱段、姜片。凉了以后去皮切块。</p>
<p>茄汁牛肉酱（两餐量）：1、牛肉末炒黄捞出；2、大葱末、蒜蓉、口蘑、胡萝卜、西芹炒香、加番茄、番茄酱、魔芋块。牛肉末回锅加水炖。3、加盐、黑胡椒、脱脂牛奶。</p>
<p>豆腐肉丸（一餐量）：1、猪肉馅、耗油、生抽、老抽、米酒、香油、白胡椒、姜末、盐、水淀粉腌制；2、猪肉末加老豆腐，做成肉丸子，蒸熟或烤熟。</p>
<p>紫苏辣椒酱汁：生抽、清水、木鱼花、柠檬汁、紫苏叶、糖、煮熟后放入过滤放小米椒。</p>
<p>南瓜、山药、土豆、芋头带皮蒸熟后去皮。</p>
<p>魔芋块切小块，大葱、口蘑、胡萝卜、部分切片部分切细丁，番茄切碎、西芹切丁、茭白切小块。</p>
<p>周一：火腿口蘑毛豆糙米饭、虾仁奶汁炖菜、剁椒蒸银鳕鱼。水煮菠菜加芝麻酱<br>周二：蒸南瓜、蒸芋头。茭白毛豆炒鸡丁、盐水鸭腿。水煮西蓝花加辣椒酱汁<br>周三：火腿口蘑毛豆糙米饭、茄汁牛肉酱、豆腐肉丸。水煮芥蓝加紫苏辣椒酱汁。<br>周四：芋头土豆泥、虾仁奶汁炖菜、盐水鸭腿。水煮菠菜、豆芽，加芝麻酱<br>周五：山药土豆泥、茄汁牛肉酱、茭白炒鸡丁，水煮秋葵加辣椒酱汁。  </p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title>减脂心得</title>
    <url>/2020/05/13/life/%E5%87%8F%E8%84%82%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h2 id="减脂最重要的点"><a href="#减脂最重要的点" class="headerlink" title="减脂最重要的点"></a>减脂最重要的点</h2><p><strong>如果只是单纯的减脂，做好饮食就可以成功。</strong></p>
<p>饮食要遵循几条原则：</p>
<ol>
<li><p>补充营养学的知识</p>
<ul>
<li><p>比如说：你要知道大豆类以及豆制品有很多优质植物蛋白质，热量低，可以增加摄入。</p>
</li>
<li><p>鱼肉、鸡肉、牛肉、瘦猪肉，也都是很好的蛋白质来源，最好每天都要吃一些。</p>
</li>
<li><p>如果是生的或者水煮的蔬菜的热量几乎可以忽略不计，一顿吃200多g蔬菜，提供维生素和膳食纤维，而且很容易吃到，没有经济压力。</p>
</li>
<li><p>主食不仅仅有大米和馒头，很多杂粮蛋白质，膳食纤维以及各种维生素含量都远超大米，以及薯类也是不错的主食。杂粮和薯类 GI 值低，饱腹感强，通俗点说就是你吃杂粮一顿饭很难能吃下150g以上，米饭的话…</p>
</li>
<li><p>这里推荐关注<a href="https://weibo.com/foodnutrition?topnav=1&wvr=6&topsug=1&is_all=1" target="_blank" rel="noopener">范志红老师的微博</a>，可以用一点时间好好看看范志红老师的文章，终身受益。</p>
</li>
</ul>
</li>
<li><p>要会看食物营养价值标签，相信我，看懂了之后，垃圾食品的诱惑力会直线下降。这里推荐看<a href="https://www.zhihu.com/question/355691966/answer/932565416" target="_blank" rel="noopener">你买食品时会或有意或无意地看成分表吗？ - 芝麻酱的回答 - 知乎</a></p>
</li>
<li><p>好吃，难吃的要死吃两次就不想吃了，不能坚持。</p>
<ul>
<li><p>水煮菜难吃可以调个酱汁，或者煮的时候加点香油。</p>
</li>
<li><p>沙拉可以加点沙拉酱，热量也远远比烧菜低得多。</p>
</li>
<li><p>鸡胸可以腌制一下。</p>
</li>
<li><p>等等等等等，可以关注一下美食博主，有很多菜谱。</p>
</li>
</ul>
</li>
<li><p>蛋白质 碳水 脂肪的配比要均衡，都要吃够。</p>
</li>
<li><p>热量差不能过大，也就是说不能节食，如果没有运动，那就保持每天的热量差不超过400 kcal，有运动那就多吃点，一个月瘦 3 斤是不错的减脂速度，非大基数或者专业人士，一个月超过 5 斤，可能会导致流失很多肌肉，即使瘦下来，线条也很不好看。</p>
</li>
</ol>
<p>无论是体脂高的想要减脂，还是怕日常饮食长肉的。第一步都需要，明确自己每天大概需要多少热量，一餐大概摄入多少热量，保证每天的热量缺口在500 kcal，是十分合理健康的速度。</p>
<h2 id="我的饮食"><a href="#我的饮食" class="headerlink" title="我的饮食"></a>我的饮食</h2><p>就我目前来说：身高175cm，体重145 斤，基本时间都坐在电脑前。一天大概需要1800~2000 kcal 的热量。</p>
<hr>
<ul>
<li>早餐：</li>
</ul>
<p>​    30g 苹果 + 30g 火龙果 + 50g 无糖即食燕麦 + 250ml 全脂牛奶发酵酸奶 + 15g ON 蛋白粉（423 kcal）</p>
<p>​    以上做成一碗酸奶水果燕麦，吃的时候可以加点坚果或者黑芝麻，味道十分棒。</p>
<ul>
<li>午餐：</li>
</ul>
<p>​    主食：50g 燕麦 + 50ml 酸奶 + 15g ON蛋白粉 + 半个鸡蛋（321 kcal）做成饼</p>
<p>​    菜：在家妈妈做什么菜就吃什么，基本都是两个中式炒菜，热量感觉挺高的。</p>
<ul>
<li>下午：</li>
</ul>
<p>​    MP 蛋白粉冲 40 g</p>
<ul>
<li><p>晚餐：同早餐</p>
</li>
<li><p>一天总热量：</p>
<p>1329 kcal（不包括中午吃妈妈做的菜）</p>
</li>
</ul>
<hr>
<p>所以一天下来摄入大概在1800~2000 kcal 左右，如果傍晚出门变速跑5 km, 每天是有热量缺口的。不做有氧，做一些无氧，热量缺口很少。</p>
<p>饮食的蛋白质摄入量还不错，碳水稍低，燕麦的膳食纤维含量很高。脂肪有牛奶和坚果还有吃的炒菜，也是够的。</p>
<h2 id="最近三个月的减脂成果"><a href="#最近三个月的减脂成果" class="headerlink" title="最近三个月的减脂成果"></a>最近三个月的减脂成果</h2><p>2月底开始减脂，那时候大概152斤左右，因为基本是靠节食瘦的，身体状态很差，肌肉流失很多。每天吃的碳水太少，脸色很难看，身体根本没有一点线条。</p>
<p>到今天不到三个月的时间，瘦了 8 斤，速度还是很棒的。最重要的是身体状态变好很多。最近这段时间摄入的蛋白质和总体热量提升了是因为现在不能简单的减脂了，而是需要保证饮食的均衡，配合无氧训练，才能有好身材。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
</search>
